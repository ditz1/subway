# MagicaVoxel @ Ephtracy

newmtl palette
illum 1
Ka 0.000 0.000 0.000
Kd 1.000 1.000 1.000
Ks 0.000 0.000 0.000
map_Kd car.png
# MagicaVoxel @ Ephtracy

# group
o 

# material
mtllib car.mtl
usemtl palette

# normals
vn -1 0 0
vn 1 0 0
vn 0 0 1
vn 0 0 -1
vn 0 -1 0
vn 0 1 0

# texcoords
vt 0.0214844 0.5
vt 0.876953 0.5
vt 0.958984 0.5
vt 0.966797 0.5
vt 0.978516 0.5
vt 0.982422 0.5
vt 0.986328 0.5
vt 0.994141 0.5

# verts
v -0.7 0.5 1.5
v -0.7 0.5 -1.2
v -0.7 0.6 1.6
v -0.7 0.6 1.5
v -0.7 0.6 -1.2
v -0.7 0.6 -1.3
v -0.7 0.7 1.4
v -0.7 0.7 -1.1
v -0.7 0.8 1.4
v -0.7 0.8 -1.1
v -0.7 0.9 1.4
v -0.7 0.9 -1.1
v -0.7 1 1.4
v -0.7 1 -1.1
v -0.7 2 1.4
v -0.7 2 1.3
v -0.7 2 -1
v -0.7 2 -1.1
v -0.7 2.1 1.3
v -0.7 2.1 -1
v -0.7 2.2 1.6
v -0.7 2.2 1.5
v -0.7 2.2 -1.2
v -0.7 2.2 -1.3
v -0.7 2.3 1.5
v -0.7 2.3 1.3
v -0.7 2.3 1.1
v -0.7 2.3 -0.8
v -0.7 2.3 -1
v -0.7 2.3 -1.2
v -0.7 2.4 1.3
v -0.7 2.4 1.1
v -0.7 2.4 -0.8
v -0.7 2.4 -1
v -0.6 0.2 1.4
v -0.6 0.2 1.1
v -0.6 0.2 -0.8
v -0.6 0.2 -1.1
v -0.6 0.3 1.3
v -0.6 0.3 1.2
v -0.6 0.3 -0.9
v -0.6 0.3 -1
v -0.6 0.4 1.5
v -0.6 0.4 1.4
v -0.6 0.4 1.3
v -0.6 0.4 1.2
v -0.6 0.4 1.1
v -0.6 0.4 1
v -0.6 0.4 -0.7
v -0.6 0.4 -0.8
v -0.6 0.4 -0.9
v -0.6 0.4 -1
v -0.6 0.4 -1.1
v -0.6 0.4 -1.2
v -0.6 0.5 1.6
v -0.6 0.5 1.5
v -0.6 0.5 1
v -0.6 0.5 -0.7
v -0.6 0.5 -1.2
v -0.6 0.5 -1.3
v -0.6 0.6 1.7
v -0.6 0.6 1.6
v -0.6 0.6 1.5
v -0.6 0.6 -1.2
v -0.6 0.6 -1.3
v -0.6 0.6 -1.4
v -0.6 1 1.4
v -0.6 1 -1.1
v -0.6 1.1 1.3
v -0.6 1.1 0.7
v -0.6 1.1 0.5
v -0.6 1.1 0.2
v -0.6 1.1 0.0999999
v -0.6 1.1 -0.2
v -0.6 1.1 -0.4
v -0.6 1.1 -1
v -0.6 2 1.4
v -0.6 2 1.3
v -0.6 2 0.7
v -0.6 2 0.5
v -0.6 2 0.2
v -0.6 2 0.0999999
v -0.6 2 -0.2
v -0.6 2 -0.4
v -0.6 2 -1
v -0.6 2 -1.1
v -0.6 2.1 1.3
v -0.6 2.1 -1
v -0.6 2.2 1.7
v -0.6 2.2 1.6
v -0.6 2.2 1.5
v -0.6 2.2 -1.2
v -0.6 2.2 -1.3
v -0.6 2.2 -1.4
v -0.6 2.3 1.6
v -0.6 2.3 1.5
v -0.6 2.3 1.3
v -0.6 2.3 1.1
v -0.6 2.3 -0.8
v -0.6 2.3 -1
v -0.6 2.3 -1.2
v -0.6 2.3 -1.3
v -0.6 2.4 1.5
v -0.6 2.4 1.3
v -0.6 2.4 1.1
v -0.6 2.4 -0.8
v -0.6 2.4 -1
v -0.6 2.4 -1.2
v -0.6 2.5 1.3
v -0.6 2.5 1.1
v -0.6 2.5 -0.8
v -0.6 2.5 -1
v -0.5 0.5 1.7
v -0.5 0.5 1.6
v -0.5 0.5 -1.3
v -0.5 0.5 -1.4
v -0.5 0.6 1.7
v -0.5 0.6 1.6
v -0.5 0.6 -1.3
v -0.5 0.6 -1.4
v -0.5 1.1 1.3
v -0.5 1.1 1.2
v -0.5 1.1 0.7
v -0.5 1.1 0.5
v -0.5 1.1 0.3
v -0.5 1.1 0.2
v -0.5 1.1 0.0999999
v -0.5 1.1 -2.38419e-07
v -0.5 1.1 -0.2
v -0.5 1.1 -0.4
v -0.5 1.1 -0.5
v -0.5 1.1 -1
v -0.5 1.2 1.3
v -0.5 1.2 1.2
v -0.5 1.2 1.1
v -0.5 1.3 -0.4
v -0.5 1.3 -0.5
v -0.5 1.3 -0.6
v -0.5 1.4 1.2
v -0.5 1.4 1.1
v -0.5 1.4 1
v -0.5 1.4 -0.5
v -0.5 1.4 -0.6
v -0.5 1.4 -0.7
v -0.5 1.5 1.1
v -0.5 1.5 1
v -0.5 1.5 0.9
v -0.5 1.6 -0.6
v -0.5 1.6 -0.7
v -0.5 1.6 -0.8
v -0.5 1.7 1
v -0.5 1.7 0.9
v -0.5 1.7 0.8
v -0.5 1.7 -0.7
v -0.5 1.7 -0.8
v -0.5 1.7 -0.9
v -0.5 1.8 0.9
v -0.5 1.8 0.8
v -0.5 1.8 0.7
v -0.5 1.9 -0.8
v -0.5 1.9 -0.9
v -0.5 1.9 -1
v -0.5 2 1.3
v -0.5 2 0.8
v -0.5 2 0.7
v -0.5 2 0.5
v -0.5 2 0.3
v -0.5 2 0.2
v -0.5 2 0.0999999
v -0.5 2 -2.38419e-07
v -0.5 2 -0.2
v -0.5 2 -0.4
v -0.5 2 -0.9
v -0.5 2 -1
v -0.5 2.2 1.7
v -0.5 2.2 1.6
v -0.5 2.2 -1.3
v -0.5 2.2 -1.4
v -0.5 2.3 1.7
v -0.5 2.3 1.6
v -0.5 2.3 1.5
v -0.5 2.3 -1.2
v -0.5 2.3 -1.3
v -0.5 2.3 -1.4
v -0.5 2.4 1.6
v -0.5 2.4 1.5
v -0.5 2.4 1.3
v -0.5 2.4 1.1
v -0.5 2.4 -0.8
v -0.5 2.4 -1
v -0.5 2.4 -1.2
v -0.5 2.4 -1.3
v -0.5 2.5 1.5
v -0.5 2.5 1.3
v -0.5 2.5 1.1
v -0.5 2.5 -0.8
v -0.5 2.5 -1
v -0.5 2.5 -1.2
v -0.5 2.6 1.3
v -0.5 2.6 1.1
v -0.5 2.6 -0.8
v -0.5 2.6 -1
v -0.4 2.3 1.7
v -0.4 2.3 1.6
v -0.4 2.3 -1.3
v -0.4 2.3 -1.4
v -0.4 2.4 1.7
v -0.4 2.4 1.6
v -0.4 2.4 1.5
v -0.4 2.4 -1.2
v -0.4 2.4 -1.3
v -0.4 2.4 -1.4
v -0.4 2.5 1.6
v -0.4 2.5 1.5
v -0.4 2.5 -1.2
v -0.4 2.5 -1.3
v -0.3 2.5 1.5
v -0.3 2.5 1.3
v -0.3 2.5 1.1
v -0.3 2.5 -0.8
v -0.3 2.5 -1
v -0.3 2.5 -1.2
v -0.3 2.6 1.5
v -0.3 2.6 1.3
v -0.3 2.6 1.1
v -0.3 2.6 -0.8
v -0.3 2.6 -1
v -0.3 2.6 -1.2
v -0.3 2.7 1.3
v -0.3 2.7 1.1
v -0.3 2.7 -0.8
v -0.3 2.7 -1
v -0.2 0.5 1.8
v -0.2 0.5 1.7
v -0.2 0.5 -1.4
v -0.2 0.5 -1.5
v -0.2 0.6 1.8
v -0.2 0.6 1.7
v -0.2 0.6 -1.4
v -0.2 0.6 -1.5
v -0.2 2.5 1.6
v -0.2 2.5 1.5
v -0.2 2.5 -1.2
v -0.2 2.5 -1.3
v -0.2 2.6 1.6
v -0.2 2.6 1.5
v -0.2 2.6 -1.2
v -0.2 2.6 -1.3
v -0.1 0.5 1.9
v -0.1 0.5 1.8
v -0.1 0.5 -1.5
v -0.1 0.5 -1.6
v -0.1 0.6 1.9
v -0.1 0.6 1.8
v -0.1 0.6 -1.5
v -0.1 0.6 -1.6
v -0.1 2.6 1.1
v -0.1 2.6 -0.8
v -0.1 2.7 1.1
v -0.1 2.7 -0.8
v 5.96046e-08 0.5 2
v 5.96046e-08 0.5 1.9
v 5.96046e-08 0.5 -1.6
v 5.96046e-08 0.5 -1.7
v 5.96046e-08 0.6 2
v 5.96046e-08 0.6 1.9
v 5.96046e-08 0.6 -1.6
v 5.96046e-08 0.6 -1.7
v 0.1 2.6 1.1
v 0.1 2.6 -0.8
v 0.1 2.7 1.1
v 0.1 2.7 -0.8
v 0.4 0.2 1.4
v 0.4 0.2 1.1
v 0.4 0.2 -0.8
v 0.4 0.2 -1.1
v 0.4 0.4 1.5
v 0.4 0.4 1.4
v 0.4 0.4 1.1
v 0.4 0.4 1
v 0.4 0.4 -0.7
v 0.4 0.4 -0.8
v 0.4 0.4 -1.1
v 0.4 0.4 -1.2
v 0.4 0.5 1.5
v 0.4 0.5 1
v 0.4 0.5 -0.7
v 0.4 0.5 -1.2
v -0.3 0.2 1.4
v -0.3 0.2 1.1
v -0.3 0.2 -0.8
v -0.3 0.2 -1.1
v -0.3 0.4 1.5
v -0.3 0.4 1.4
v -0.3 0.4 1.1
v -0.3 0.4 1
v -0.3 0.4 -0.7
v -0.3 0.4 -0.8
v -0.3 0.4 -1.1
v -0.3 0.4 -1.2
v -0.3 0.5 1.5
v -0.3 0.5 1
v -0.3 0.5 -0.7
v -0.3 0.5 -1.2
v 5.96046e-08 2.6 1.1
v 5.96046e-08 2.6 -0.8
v 5.96046e-08 2.7 1.1
v 5.96046e-08 2.7 -0.8
v 0.1 0.5 2
v 0.1 0.5 1.9
v 0.1 0.5 -1.6
v 0.1 0.5 -1.7
v 0.1 0.6 2
v 0.1 0.6 1.9
v 0.1 0.6 -1.6
v 0.1 0.6 -1.7
v 0.2 0.5 1.9
v 0.2 0.5 1.8
v 0.2 0.5 -1.5
v 0.2 0.5 -1.6
v 0.2 0.6 1.9
v 0.2 0.6 1.8
v 0.2 0.6 -1.5
v 0.2 0.6 -1.6
v 0.2 2.6 1.1
v 0.2 2.6 -0.8
v 0.2 2.7 1.1
v 0.2 2.7 -0.8
v 0.3 0.5 1.8
v 0.3 0.5 1.7
v 0.3 0.5 -1.4
v 0.3 0.5 -1.5
v 0.3 0.6 1.8
v 0.3 0.6 1.7
v 0.3 0.6 -1.4
v 0.3 0.6 -1.5
v 0.3 2.5 1.6
v 0.3 2.5 1.5
v 0.3 2.5 -1.2
v 0.3 2.5 -1.3
v 0.3 2.6 1.6
v 0.3 2.6 1.5
v 0.3 2.6 -1.2
v 0.3 2.6 -1.3
v 0.4 2.5 1.5
v 0.4 2.5 1.3
v 0.4 2.5 1.1
v 0.4 2.5 -0.8
v 0.4 2.5 -1
v 0.4 2.5 -1.2
v 0.4 2.6 1.5
v 0.4 2.6 1.3
v 0.4 2.6 1.1
v 0.4 2.6 -0.8
v 0.4 2.6 -1
v 0.4 2.6 -1.2
v 0.4 2.7 1.3
v 0.4 2.7 1.1
v 0.4 2.7 -0.8
v 0.4 2.7 -1
v 0.5 2.3 1.7
v 0.5 2.3 1.6
v 0.5 2.3 -1.3
v 0.5 2.3 -1.4
v 0.5 2.4 1.7
v 0.5 2.4 1.6
v 0.5 2.4 1.5
v 0.5 2.4 -1.2
v 0.5 2.4 -1.3
v 0.5 2.4 -1.4
v 0.5 2.5 1.6
v 0.5 2.5 1.5
v 0.5 2.5 -1.2
v 0.5 2.5 -1.3
v 0.6 0.5 1.7
v 0.6 0.5 1.6
v 0.6 0.5 -1.3
v 0.6 0.5 -1.4
v 0.6 0.6 1.7
v 0.6 0.6 1.6
v 0.6 0.6 -1.3
v 0.6 0.6 -1.4
v 0.6 1.1 1.3
v 0.6 1.1 0.8
v 0.6 1.1 0.7
v 0.6 1.1 0.5
v 0.6 1.1 0.3
v 0.6 1.1 0.2
v 0.6 1.1 0.0999999
v 0.6 1.1 -2.38419e-07
v 0.6 1.1 -0.2
v 0.6 1.1 -0.4
v 0.6 1.1 -0.9
v 0.6 1.1 -1
v 0.6 1.2 0.9
v 0.6 1.2 0.8
v 0.6 1.2 0.7
v 0.6 1.3 -0.8
v 0.6 1.3 -0.9
v 0.6 1.3 -1
v 0.6 1.4 1
v 0.6 1.4 0.9
v 0.6 1.4 0.8
v 0.6 1.4 -0.7
v 0.6 1.4 -0.8
v 0.6 1.4 -0.9
v 0.6 1.5 1.1
v 0.6 1.5 1
v 0.6 1.5 0.9
v 0.6 1.6 -0.6
v 0.6 1.6 -0.7
v 0.6 1.6 -0.8
v 0.6 1.7 1.2
v 0.6 1.7 1.1
v 0.6 1.7 1
v 0.6 1.7 -0.5
v 0.6 1.7 -0.6
v 0.6 1.7 -0.7
v 0.6 1.8 1.3
v 0.6 1.8 1.2
v 0.6 1.8 1.1
v 0.6 1.9 -0.4
v 0.6 1.9 -0.5
v 0.6 1.9 -0.6
v 0.6 2 1.3
v 0.6 2 1.2
v 0.6 2 0.7
v 0.6 2 0.5
v 0.6 2 0.3
v 0.6 2 0.2
v 0.6 2 0.0999999
v 0.6 2 -2.38419e-07
v 0.6 2 -0.2
v 0.6 2 -0.4
v 0.6 2 -0.5
v 0.6 2 -1
v 0.6 2.2 1.7
v 0.6 2.2 1.6
v 0.6 2.2 -1.3
v 0.6 2.2 -1.4
v 0.6 2.3 1.7
v 0.6 2.3 1.6
v 0.6 2.3 1.5
v 0.6 2.3 -1.2
v 0.6 2.3 -1.3
v 0.6 2.3 -1.4
v 0.6 2.4 1.6
v 0.6 2.4 1.5
v 0.6 2.4 1.3
v 0.6 2.4 1.1
v 0.6 2.4 -0.8
v 0.6 2.4 -1
v 0.6 2.4 -1.2
v 0.6 2.4 -1.3
v 0.6 2.5 1.5
v 0.6 2.5 1.3
v 0.6 2.5 1.1
v 0.6 2.5 -0.8
v 0.6 2.5 -1
v 0.6 2.5 -1.2
v 0.6 2.6 1.3
v 0.6 2.6 1.1
v 0.6 2.6 -0.8
v 0.6 2.6 -1
v 0.7 0.2 1.4
v 0.7 0.2 1.1
v 0.7 0.2 -0.8
v 0.7 0.2 -1.1
v 0.7 0.3 1.3
v 0.7 0.3 1.2
v 0.7 0.3 -0.9
v 0.7 0.3 -1
v 0.7 0.4 1.5
v 0.7 0.4 1.4
v 0.7 0.4 1.3
v 0.7 0.4 1.2
v 0.7 0.4 1.1
v 0.7 0.4 1
v 0.7 0.4 -0.7
v 0.7 0.4 -0.8
v 0.7 0.4 -0.9
v 0.7 0.4 -1
v 0.7 0.4 -1.1
v 0.7 0.4 -1.2
v 0.7 0.5 1.6
v 0.7 0.5 1.5
v 0.7 0.5 1
v 0.7 0.5 -0.7
v 0.7 0.5 -1.2
v 0.7 0.5 -1.3
v 0.7 0.6 1.7
v 0.7 0.6 1.6
v 0.7 0.6 1.5
v 0.7 0.6 -1.2
v 0.7 0.6 -1.3
v 0.7 0.6 -1.4
v 0.7 1 1.4
v 0.7 1 -1.1
v 0.7 1.1 1.3
v 0.7 1.1 0.7
v 0.7 1.1 0.5
v 0.7 1.1 0.2
v 0.7 1.1 0.0999999
v 0.7 1.1 -0.2
v 0.7 1.1 -0.4
v 0.7 1.1 -1
v 0.7 2 1.4
v 0.7 2 1.3
v 0.7 2 0.7
v 0.7 2 0.5
v 0.7 2 0.2
v 0.7 2 0.0999999
v 0.7 2 -0.2
v 0.7 2 -0.4
v 0.7 2 -1
v 0.7 2 -1.1
v 0.7 2.1 1.3
v 0.7 2.1 -1
v 0.7 2.2 1.7
v 0.7 2.2 1.6
v 0.7 2.2 1.5
v 0.7 2.2 -1.2
v 0.7 2.2 -1.3
v 0.7 2.2 -1.4
v 0.7 2.3 1.6
v 0.7 2.3 1.5
v 0.7 2.3 1.3
v 0.7 2.3 1.1
v 0.7 2.3 -0.8
v 0.7 2.3 -1
v 0.7 2.3 -1.2
v 0.7 2.3 -1.3
v 0.7 2.4 1.5
v 0.7 2.4 1.3
v 0.7 2.4 1.1
v 0.7 2.4 -0.8
v 0.7 2.4 -1
v 0.7 2.4 -1.2
v 0.7 2.5 1.3
v 0.7 2.5 1.1
v 0.7 2.5 -0.8
v 0.7 2.5 -1
v 0.8 0.5 1.5
v 0.8 0.5 -1.2
v 0.8 0.6 1.6
v 0.8 0.6 1.5
v 0.8 0.6 -1.2
v 0.8 0.6 -1.3
v 0.8 0.7 1.4
v 0.8 0.7 -1.1
v 0.8 0.8 1.4
v 0.8 0.8 -1.1
v 0.8 0.9 1.4
v 0.8 0.9 -1.1
v 0.8 1 1.4
v 0.8 1 -1.1
v 0.8 2 1.4
v 0.8 2 1.3
v 0.8 2 -1
v 0.8 2 -1.1
v 0.8 2.1 1.3
v 0.8 2.1 -1
v 0.8 2.2 1.6
v 0.8 2.2 1.5
v 0.8 2.2 -1.2
v 0.8 2.2 -1.3
v 0.8 2.3 1.5
v 0.8 2.3 1.3
v 0.8 2.3 1.1
v 0.8 2.3 -0.8
v 0.8 2.3 -1
v 0.8 2.3 -1.2
v 0.8 2.4 1.3
v 0.8 2.4 1.1
v 0.8 2.4 -0.8
v 0.8 2.4 -1
v 5.96046e-08 0.5 2
v 5.96046e-08 0.6 2
v 0.1 0.5 2
v 0.1 0.6 2
v -0.1 0.5 1.9
v -0.1 0.6 1.9
v 5.96046e-08 0.5 1.9
v 5.96046e-08 0.6 1.9
v 0.1 0.5 1.9
v 0.1 0.6 1.9
v 0.2 0.5 1.9
v 0.2 0.6 1.9
v -0.2 0.5 1.8
v -0.2 0.6 1.8
v -0.1 0.5 1.8
v -0.1 0.6 1.8
v 0.2 0.5 1.8
v 0.2 0.6 1.8
v 0.3 0.5 1.8
v 0.3 0.6 1.8
v -0.6 0.6 1.7
v -0.6 2.2 1.7
v -0.5 0.5 1.7
v -0.5 0.6 1.7
v -0.5 2.2 1.7
v -0.5 2.3 1.7
v -0.4 2.3 1.7
v -0.4 2.4 1.7
v -0.2 0.5 1.7
v -0.2 0.6 1.7
v 0.3 0.5 1.7
v 0.3 0.6 1.7
v 0.5 2.3 1.7
v 0.5 2.4 1.7
v 0.6 0.5 1.7
v 0.6 0.6 1.7
v 0.6 2.2 1.7
v 0.6 2.3 1.7
v 0.7 0.6 1.7
v 0.7 2.2 1.7
v -0.7 0.6 1.6
v -0.7 2.2 1.6
v -0.6 0.5 1.6
v -0.6 0.6 1.6
v -0.6 2.2 1.6
v -0.6 2.3 1.6
v -0.5 0.5 1.6
v -0.5 0.6 1.6
v -0.5 2.2 1.6
v -0.5 2.3 1.6
v -0.5 2.4 1.6
v -0.4 2.3 1.6
v -0.4 2.4 1.6
v -0.4 2.5 1.6
v -0.2 2.5 1.6
v -0.2 2.6 1.6
v 0.3 2.5 1.6
v 0.3 2.6 1.6
v 0.5 2.3 1.6
v 0.5 2.4 1.6
v 0.5 2.5 1.6
v 0.6 0.5 1.6
v 0.6 0.6 1.6
v 0.6 2.2 1.6
v 0.6 2.3 1.6
v 0.6 2.4 1.6
v 0.7 0.5 1.6
v 0.7 0.6 1.6
v 0.7 2.2 1.6
v 0.7 2.3 1.6
v 0.8 0.6 1.6
v 0.8 2.2 1.6
v -0.7 0.5 1.5
v -0.7 0.6 1.5
v -0.7 2.2 1.5
v -0.7 2.3 1.5
v -0.6 0.4 1.5
v -0.6 0.5 1.5
v -0.6 0.6 1.5
v -0.6 2.2 1.5
v -0.6 2.3 1.5
v -0.6 2.4 1.5
v -0.5 2.3 1.5
v -0.5 2.4 1.5
v -0.5 2.5 1.5
v -0.4 2.4 1.5
v -0.4 2.5 1.5
v -0.3 0.4 1.5
v -0.3 0.5 1.5
v -0.3 2.5 1.5
v -0.3 2.6 1.5
v -0.2 2.5 1.5
v -0.2 2.6 1.5
v 0.3 2.5 1.5
v 0.3 2.6 1.5
v 0.4 0.4 1.5
v 0.4 0.5 1.5
v 0.4 2.5 1.5
v 0.4 2.6 1.5
v 0.5 2.4 1.5
v 0.5 2.5 1.5
v 0.6 2.3 1.5
v 0.6 2.4 1.5
v 0.6 2.5 1.5
v 0.7 0.4 1.5
v 0.7 0.5 1.5
v 0.7 0.6 1.5
v 0.7 2.2 1.5
v 0.7 2.3 1.5
v 0.7 2.4 1.5
v 0.8 0.5 1.5
v 0.8 0.6 1.5
v 0.8 2.2 1.5
v 0.8 2.3 1.5
v -0.6 0.2 1.4
v -0.6 0.4 1.4
v -0.3 0.2 1.4
v -0.3 0.4 1.4
v 0.4 0.2 1.4
v 0.4 0.4 1.4
v 0.7 0.2 1.4
v 0.7 0.4 1.4
v -0.7 2.3 1.3
v -0.7 2.4 1.3
v -0.6 2.3 1.3
v -0.6 2.4 1.3
v -0.6 2.5 1.3
v -0.5 2.4 1.3
v -0.5 2.5 1.3
v -0.5 2.6 1.3
v -0.3 2.5 1.3
v -0.3 2.6 1.3
v -0.3 2.7 1.3
v 0.4 2.5 1.3
v 0.4 2.6 1.3
v 0.4 2.7 1.3
v 0.6 2.4 1.3
v 0.6 2.5 1.3
v 0.6 2.6 1.3
v 0.7 2.3 1.3
v 0.7 2.4 1.3
v 0.7 2.5 1.3
v 0.8 2.3 1.3
v 0.8 2.4 1.3
v -0.6 1.1 0.7
v -0.6 2 0.7
v -0.5 1.1 0.7
v -0.5 1.8 0.7
v -0.5 2 0.7
v 0.6 1.1 0.7
v 0.6 1.2 0.7
v 0.6 2 0.7
v 0.7 1.1 0.7
v 0.7 2 0.7
v -0.6 1.1 0.2
v -0.6 2 0.2
v -0.5 1.1 0.2
v -0.5 2 0.2
v 0.6 1.1 0.2
v 0.6 2 0.2
v 0.7 1.1 0.2
v 0.7 2 0.2
v -0.6 1.1 -0.2
v -0.6 2 -0.2
v -0.5 1.1 -0.2
v -0.5 2 -0.2
v 0.6 1.1 -0.2
v 0.6 2 -0.2
v 0.7 1.1 -0.2
v 0.7 2 -0.2
v -0.6 0.4 -0.7
v -0.6 0.5 -0.7
v -0.3 0.4 -0.7
v -0.3 0.5 -0.7
v 0.4 0.4 -0.7
v 0.4 0.5 -0.7
v 0.7 0.4 -0.7
v 0.7 0.5 -0.7
v -0.7 2.3 -0.8
v -0.7 2.4 -0.8
v -0.6 0.2 -0.8
v -0.6 0.4 -0.8
v -0.6 2.3 -0.8
v -0.6 2.4 -0.8
v -0.6 2.5 -0.8
v -0.5 2.4 -0.8
v -0.5 2.5 -0.8
v -0.5 2.6 -0.8
v -0.3 0.2 -0.8
v -0.3 0.4 -0.8
v -0.3 2.5 -0.8
v -0.3 2.6 -0.8
v -0.3 2.7 -0.8
v -0.1 2.6 -0.8
v -0.1 2.7 -0.8
v 5.96046e-08 2.6 -0.8
v 5.96046e-08 2.7 -0.8
v 0.1 2.6 -0.8
v 0.1 2.7 -0.8
v 0.2 2.6 -0.8
v 0.2 2.7 -0.8
v 0.4 0.2 -0.8
v 0.4 0.4 -0.8
v 0.4 2.5 -0.8
v 0.4 2.6 -0.8
v 0.4 2.7 -0.8
v 0.6 2.4 -0.8
v 0.6 2.5 -0.8
v 0.6 2.6 -0.8
v 0.7 0.2 -0.8
v 0.7 0.4 -0.8
v 0.7 2.3 -0.8
v 0.7 2.4 -0.8
v 0.7 2.5 -0.8
v 0.8 2.3 -0.8
v 0.8 2.4 -0.8
v -0.7 2 -1
v -0.7 2.1 -1
v -0.6 1.1 -1
v -0.6 2 -1
v -0.6 2.1 -1
v -0.5 1.1 -1
v -0.5 1.9 -1
v -0.5 2 -1
v 0.6 1.1 -1
v 0.6 1.3 -1
v 0.6 2 -1
v 0.7 1.1 -1
v 0.7 2 -1
v 0.7 2.1 -1
v 0.8 2 -1
v 0.8 2.1 -1
v -0.7 1 -1.1
v -0.7 2 -1.1
v -0.6 1 -1.1
v -0.6 2 -1.1
v 0.7 1 -1.1
v 0.7 2 -1.1
v 0.8 1 -1.1
v 0.8 2 -1.1
v -0.7 1 1.4
v -0.7 2 1.4
v -0.6 1 1.4
v -0.6 2 1.4
v 0.7 1 1.4
v 0.7 2 1.4
v 0.8 1 1.4
v 0.8 2 1.4
v -0.7 2 1.3
v -0.7 2.1 1.3
v -0.6 1.1 1.3
v -0.6 2 1.3
v -0.6 2.1 1.3
v -0.5 1.1 1.3
v -0.5 1.2 1.3
v -0.5 2 1.3
v 0.6 1.1 1.3
v 0.6 1.8 1.3
v 0.6 2 1.3
v 0.7 1.1 1.3
v 0.7 2 1.3
v 0.7 2.1 1.3
v 0.8 2 1.3
v 0.8 2.1 1.3
v -0.7 2.3 1.1
v -0.7 2.4 1.1
v -0.6 0.2 1.1
v -0.6 0.4 1.1
v -0.6 2.3 1.1
v -0.6 2.4 1.1
v -0.6 2.5 1.1
v -0.5 2.4 1.1
v -0.5 2.5 1.1
v -0.5 2.6 1.1
v -0.3 0.2 1.1
v -0.3 0.4 1.1
v -0.3 2.5 1.1
v -0.3 2.6 1.1
v -0.3 2.7 1.1
v -0.1 2.6 1.1
v -0.1 2.7 1.1
v 5.96046e-08 2.6 1.1
v 5.96046e-08 2.7 1.1
v 0.1 2.6 1.1
v 0.1 2.7 1.1
v 0.2 2.6 1.1
v 0.2 2.7 1.1
v 0.4 0.2 1.1
v 0.4 0.4 1.1
v 0.4 2.5 1.1
v 0.4 2.6 1.1
v 0.4 2.7 1.1
v 0.6 2.4 1.1
v 0.6 2.5 1.1
v 0.6 2.6 1.1
v 0.7 0.2 1.1
v 0.7 0.4 1.1
v 0.7 2.3 1.1
v 0.7 2.4 1.1
v 0.7 2.5 1.1
v 0.8 2.3 1.1
v 0.8 2.4 1.1
v -0.6 0.4 1
v -0.6 0.5 1
v -0.3 0.4 1
v -0.3 0.5 1
v 0.4 0.4 1
v 0.4 0.5 1
v 0.7 0.4 1
v 0.7 0.5 1
v -0.6 1.1 0.5
v -0.6 2 0.5
v -0.5 1.1 0.5
v -0.5 2 0.5
v 0.6 1.1 0.5
v 0.6 2 0.5
v 0.7 1.1 0.5
v 0.7 2 0.5
v -0.6 1.1 0.0999999
v -0.6 2 0.0999999
v -0.5 1.1 0.0999999
v -0.5 2 0.0999999
v 0.6 1.1 0.0999999
v 0.6 2 0.0999999
v 0.7 1.1 0.0999999
v 0.7 2 0.0999999
v -0.6 1.1 -0.4
v -0.6 2 -0.4
v -0.5 1.1 -0.4
v -0.5 1.3 -0.4
v -0.5 2 -0.4
v 0.6 1.1 -0.4
v 0.6 1.9 -0.4
v 0.6 2 -0.4
v 0.7 1.1 -0.4
v 0.7 2 -0.4
v -0.7 2.3 -1
v -0.7 2.4 -1
v -0.6 2.3 -1
v -0.6 2.4 -1
v -0.6 2.5 -1
v -0.5 2.4 -1
v -0.5 2.5 -1
v -0.5 2.6 -1
v -0.3 2.5 -1
v -0.3 2.6 -1
v -0.3 2.7 -1
v 0.4 2.5 -1
v 0.4 2.6 -1
v 0.4 2.7 -1
v 0.6 2.4 -1
v 0.6 2.5 -1
v 0.6 2.6 -1
v 0.7 2.3 -1
v 0.7 2.4 -1
v 0.7 2.5 -1
v 0.8 2.3 -1
v 0.8 2.4 -1
v -0.6 0.2 -1.1
v -0.6 0.4 -1.1
v -0.3 0.2 -1.1
v -0.3 0.4 -1.1
v 0.4 0.2 -1.1
v 0.4 0.4 -1.1
v 0.7 0.2 -1.1
v 0.7 0.4 -1.1
v -0.7 0.5 -1.2
v -0.7 0.6 -1.2
v -0.7 2.2 -1.2
v -0.7 2.3 -1.2
v -0.6 0.4 -1.2
v -0.6 0.5 -1.2
v -0.6 0.6 -1.2
v -0.6 2.2 -1.2
v -0.6 2.3 -1.2
v -0.6 2.4 -1.2
v -0.5 2.3 -1.2
v -0.5 2.4 -1.2
v -0.5 2.5 -1.2
v -0.4 2.4 -1.2
v -0.4 2.5 -1.2
v -0.3 0.4 -1.2
v -0.3 0.5 -1.2
v -0.3 2.5 -1.2
v -0.3 2.6 -1.2
v -0.2 2.5 -1.2
v -0.2 2.6 -1.2
v 0.3 2.5 -1.2
v 0.3 2.6 -1.2
v 0.4 0.4 -1.2
v 0.4 0.5 -1.2
v 0.4 2.5 -1.2
v 0.4 2.6 -1.2
v 0.5 2.4 -1.2
v 0.5 2.5 -1.2
v 0.6 2.3 -1.2
v 0.6 2.4 -1.2
v 0.6 2.5 -1.2
v 0.7 0.4 -1.2
v 0.7 0.5 -1.2
v 0.7 0.6 -1.2
v 0.7 2.2 -1.2
v 0.7 2.3 -1.2
v 0.7 2.4 -1.2
v 0.8 0.5 -1.2
v 0.8 0.6 -1.2
v 0.8 2.2 -1.2
v 0.8 2.3 -1.2
v -0.7 0.6 -1.3
v -0.7 2.2 -1.3
v -0.6 0.5 -1.3
v -0.6 0.6 -1.3
v -0.6 2.2 -1.3
v -0.6 2.3 -1.3
v -0.5 0.5 -1.3
v -0.5 0.6 -1.3
v -0.5 2.2 -1.3
v -0.5 2.3 -1.3
v -0.5 2.4 -1.3
v -0.4 2.3 -1.3
v -0.4 2.4 -1.3
v -0.4 2.5 -1.3
v -0.2 2.5 -1.3
v -0.2 2.6 -1.3
v 0.3 2.5 -1.3
v 0.3 2.6 -1.3
v 0.5 2.3 -1.3
v 0.5 2.4 -1.3
v 0.5 2.5 -1.3
v 0.6 0.5 -1.3
v 0.6 0.6 -1.3
v 0.6 2.2 -1.3
v 0.6 2.3 -1.3
v 0.6 2.4 -1.3
v 0.7 0.5 -1.3
v 0.7 0.6 -1.3
v 0.7 2.2 -1.3
v 0.7 2.3 -1.3
v 0.8 0.6 -1.3
v 0.8 2.2 -1.3
v -0.6 0.6 -1.4
v -0.6 2.2 -1.4
v -0.5 0.5 -1.4
v -0.5 0.6 -1.4
v -0.5 2.2 -1.4
v -0.5 2.3 -1.4
v -0.4 2.3 -1.4
v -0.4 2.4 -1.4
v -0.2 0.5 -1.4
v -0.2 0.6 -1.4
v 0.3 0.5 -1.4
v 0.3 0.6 -1.4
v 0.5 2.3 -1.4
v 0.5 2.4 -1.4
v 0.6 0.5 -1.4
v 0.6 0.6 -1.4
v 0.6 2.2 -1.4
v 0.6 2.3 -1.4
v 0.7 0.6 -1.4
v 0.7 2.2 -1.4
v -0.2 0.5 -1.5
v -0.2 0.6 -1.5
v -0.1 0.5 -1.5
v -0.1 0.6 -1.5
v 0.2 0.5 -1.5
v 0.2 0.6 -1.5
v 0.3 0.5 -1.5
v 0.3 0.6 -1.5
v -0.1 0.5 -1.6
v -0.1 0.6 -1.6
v 5.96046e-08 0.5 -1.6
v 5.96046e-08 0.6 -1.6
v 0.1 0.5 -1.6
v 0.1 0.6 -1.6
v 0.2 0.5 -1.6
v 0.2 0.6 -1.6
v 5.96046e-08 0.5 -1.7
v 5.96046e-08 0.6 -1.7
v 0.1 0.5 -1.7
v 0.1 0.6 -1.7
v -0.6 0.2 1.4
v -0.3 0.2 1.4
v 0.4 0.2 1.4
v 0.7 0.2 1.4
v -0.6 0.2 1.1
v -0.3 0.2 1.1
v 0.4 0.2 1.1
v 0.7 0.2 1.1
v -0.6 0.2 -0.8
v -0.3 0.2 -0.8
v 0.4 0.2 -0.8
v 0.7 0.2 -0.8
v -0.6 0.2 -1.1
v -0.3 0.2 -1.1
v 0.4 0.2 -1.1
v 0.7 0.2 -1.1
v -0.6 0.4 1.5
v -0.3 0.4 1.5
v 0.4 0.4 1.5
v 0.7 0.4 1.5
v -0.6 0.4 1.4
v -0.3 0.4 1.4
v 0.4 0.4 1.4
v 0.7 0.4 1.4
v -0.6 0.4 1.1
v -0.3 0.4 1.1
v 0.4 0.4 1.1
v 0.7 0.4 1.1
v -0.6 0.4 1
v -0.3 0.4 1
v 0.4 0.4 1
v 0.7 0.4 1
v -0.6 0.4 -0.7
v -0.3 0.4 -0.7
v 0.4 0.4 -0.7
v 0.7 0.4 -0.7
v -0.6 0.4 -0.8
v -0.3 0.4 -0.8
v 0.4 0.4 -0.8
v 0.7 0.4 -0.8
v -0.6 0.4 -1.1
v -0.3 0.4 -1.1
v 0.4 0.4 -1.1
v 0.7 0.4 -1.1
v -0.6 0.4 -1.2
v -0.3 0.4 -1.2
v 0.4 0.4 -1.2
v 0.7 0.4 -1.2
v 5.96046e-08 0.5 2
v 0.1 0.5 2
v -0.1 0.5 1.9
v 5.96046e-08 0.5 1.9
v 0.1 0.5 1.9
v 0.2 0.5 1.9
v -0.2 0.5 1.8
v -0.1 0.5 1.8
v 0.2 0.5 1.8
v 0.3 0.5 1.8
v -0.5 0.5 1.7
v -0.2 0.5 1.7
v 0.3 0.5 1.7
v 0.6 0.5 1.7
v -0.6 0.5 1.6
v -0.5 0.5 1.6
v 0.6 0.5 1.6
v 0.7 0.5 1.6
v -0.7 0.5 1.5
v -0.6 0.5 1.5
v -0.3 0.5 1.5
v 0.4 0.5 1.5
v 0.7 0.5 1.5
v 0.8 0.5 1.5
v -0.6 0.5 1
v -0.3 0.5 1
v 0.4 0.5 1
v 0.7 0.5 1
v -0.6 0.5 -0.7
v -0.3 0.5 -0.7
v 0.4 0.5 -0.7
v 0.7 0.5 -0.7
v -0.7 0.5 -1.2
v -0.6 0.5 -1.2
v -0.3 0.5 -1.2
v 0.4 0.5 -1.2
v 0.7 0.5 -1.2
v 0.8 0.5 -1.2
v -0.6 0.5 -1.3
v -0.5 0.5 -1.3
v 0.6 0.5 -1.3
v 0.7 0.5 -1.3
v -0.5 0.5 -1.4
v -0.2 0.5 -1.4
v 0.3 0.5 -1.4
v 0.6 0.5 -1.4
v -0.2 0.5 -1.5
v -0.1 0.5 -1.5
v 0.2 0.5 -1.5
v 0.3 0.5 -1.5
v -0.1 0.5 -1.6
v 5.96046e-08 0.5 -1.6
v 0.1 0.5 -1.6
v 0.2 0.5 -1.6
v 5.96046e-08 0.5 -1.7
v 0.1 0.5 -1.7
v -0.6 0.6 1.7
v -0.5 0.6 1.7
v 0.6 0.6 1.7
v 0.7 0.6 1.7
v -0.7 0.6 1.6
v -0.6 0.6 1.6
v -0.5 0.6 1.6
v 0.6 0.6 1.6
v 0.7 0.6 1.6
v 0.8 0.6 1.6
v -0.7 0.6 1.5
v -0.6 0.6 1.5
v 0.7 0.6 1.5
v 0.8 0.6 1.5
v -0.7 0.6 -1.2
v -0.6 0.6 -1.2
v 0.7 0.6 -1.2
v 0.8 0.6 -1.2
v -0.7 0.6 -1.3
v -0.6 0.6 -1.3
v -0.5 0.6 -1.3
v 0.6 0.6 -1.3
v 0.7 0.6 -1.3
v 0.8 0.6 -1.3
v -0.6 0.6 -1.4
v -0.5 0.6 -1.4
v 0.6 0.6 -1.4
v 0.7 0.6 -1.4
v -0.7 2 1.4
v -0.6 2 1.4
v 0.7 2 1.4
v 0.8 2 1.4
v -0.7 2 1.3
v -0.6 2 1.3
v -0.5 2 1.3
v 0.6 2 1.3
v 0.7 2 1.3
v 0.8 2 1.3
v 0.6 2 1.2
v -0.5 2 0.8
v -0.6 2 0.7
v -0.5 2 0.7
v 0.6 2 0.7
v 0.7 2 0.7
v -0.6 2 0.5
v -0.5 2 0.5
v 0.6 2 0.5
v 0.7 2 0.5
v -0.5 2 0.3
v 0.6 2 0.3
v -0.6 2 0.2
v -0.5 2 0.2
v 0.6 2 0.2
v 0.7 2 0.2
v -0.6 2 0.0999999
v -0.5 2 0.0999999
v 0.6 2 0.0999999
v 0.7 2 0.0999999
v -0.5 2 -2.38419e-07
v 0.6 2 -2.38419e-07
v -0.6 2 -0.2
v -0.5 2 -0.2
v 0.6 2 -0.2
v 0.7 2 -0.2
v -0.6 2 -0.4
v -0.5 2 -0.4
v 0.6 2 -0.4
v 0.7 2 -0.4
v 0.6 2 -0.5
v -0.5 2 -0.9
v -0.7 2 -1
v -0.6 2 -1
v -0.5 2 -1
v 0.6 2 -1
v 0.7 2 -1
v 0.8 2 -1
v -0.7 2 -1.1
v -0.6 2 -1.1
v 0.7 2 -1.1
v 0.8 2 -1.1
v -0.7 2.1 1.3
v -0.6 2.1 1.3
v 0.7 2.1 1.3
v 0.8 2.1 1.3
v -0.7 2.1 -1
v -0.6 2.1 -1
v 0.7 2.1 -1
v 0.8 2.1 -1
v 5.96046e-08 0.6 2
v 0.1 0.6 2
v -0.1 0.6 1.9
v 5.96046e-08 0.6 1.9
v 0.1 0.6 1.9
v 0.2 0.6 1.9
v -0.2 0.6 1.8
v -0.1 0.6 1.8
v 0.2 0.6 1.8
v 0.3 0.6 1.8
v -0.2 0.6 1.7
v 0.3 0.6 1.7
v -0.2 0.6 -1.4
v 0.3 0.6 -1.4
v -0.2 0.6 -1.5
v -0.1 0.6 -1.5
v 0.2 0.6 -1.5
v 0.3 0.6 -1.5
v -0.1 0.6 -1.6
v 5.96046e-08 0.6 -1.6
v 0.1 0.6 -1.6
v 0.2 0.6 -1.6
v 5.96046e-08 0.6 -1.7
v 0.1 0.6 -1.7
v -0.7 1 1.4
v -0.6 1 1.4
v 0.7 1 1.4
v 0.8 1 1.4
v -0.7 1 -1.1
v -0.6 1 -1.1
v 0.7 1 -1.1
v 0.8 1 -1.1
v -0.6 1.1 1.3
v -0.5 1.1 1.3
v 0.6 1.1 1.3
v 0.7 1.1 1.3
v -0.5 1.1 1.2
v 0.6 1.1 0.8
v -0.6 1.1 0.7
v -0.5 1.1 0.7
v 0.6 1.1 0.7
v 0.7 1.1 0.7
v -0.6 1.1 0.5
v -0.5 1.1 0.5
v 0.6 1.1 0.5
v 0.7 1.1 0.5
v -0.5 1.1 0.3
v 0.6 1.1 0.3
v -0.6 1.1 0.2
v -0.5 1.1 0.2
v 0.6 1.1 0.2
v 0.7 1.1 0.2
v -0.6 1.1 0.0999999
v -0.5 1.1 0.0999999
v 0.6 1.1 0.0999999
v 0.7 1.1 0.0999999
v -0.5 1.1 -2.38419e-07
v 0.6 1.1 -2.38419e-07
v -0.6 1.1 -0.2
v -0.5 1.1 -0.2
v 0.6 1.1 -0.2
v 0.7 1.1 -0.2
v -0.6 1.1 -0.4
v -0.5 1.1 -0.4
v 0.6 1.1 -0.4
v 0.7 1.1 -0.4
v -0.5 1.1 -0.5
v 0.6 1.1 -0.9
v -0.6 1.1 -1
v -0.5 1.1 -1
v 0.6 1.1 -1
v 0.7 1.1 -1
v -0.6 2.2 1.7
v -0.5 2.2 1.7
v 0.6 2.2 1.7
v 0.7 2.2 1.7
v -0.7 2.2 1.6
v -0.6 2.2 1.6
v -0.5 2.2 1.6
v 0.6 2.2 1.6
v 0.7 2.2 1.6
v 0.8 2.2 1.6
v -0.7 2.2 1.5
v -0.6 2.2 1.5
v 0.7 2.2 1.5
v 0.8 2.2 1.5
v -0.7 2.2 -1.2
v -0.6 2.2 -1.2
v 0.7 2.2 -1.2
v 0.8 2.2 -1.2
v -0.7 2.2 -1.3
v -0.6 2.2 -1.3
v -0.5 2.2 -1.3
v 0.6 2.2 -1.3
v 0.7 2.2 -1.3
v 0.8 2.2 -1.3
v -0.6 2.2 -1.4
v -0.5 2.2 -1.4
v 0.6 2.2 -1.4
v 0.7 2.2 -1.4
v -0.5 2.3 1.7
v -0.4 2.3 1.7
v 0.5 2.3 1.7
v 0.6 2.3 1.7
v -0.6 2.3 1.6
v -0.5 2.3 1.6
v -0.4 2.3 1.6
v 0.5 2.3 1.6
v 0.6 2.3 1.6
v 0.7 2.3 1.6
v -0.7 2.3 1.5
v -0.6 2.3 1.5
v -0.5 2.3 1.5
v 0.6 2.3 1.5
v 0.7 2.3 1.5
v 0.8 2.3 1.5
v -0.7 2.3 1.3
v -0.6 2.3 1.3
v 0.7 2.3 1.3
v 0.8 2.3 1.3
v -0.7 2.3 1.1
v -0.6 2.3 1.1
v 0.7 2.3 1.1
v 0.8 2.3 1.1
v -0.7 2.3 -0.8
v -0.6 2.3 -0.8
v 0.7 2.3 -0.8
v 0.8 2.3 -0.8
v -0.7 2.3 -1
v -0.6 2.3 -1
v 0.7 2.3 -1
v 0.8 2.3 -1
v -0.7 2.3 -1.2
v -0.6 2.3 -1.2
v -0.5 2.3 -1.2
v 0.6 2.3 -1.2
v 0.7 2.3 -1.2
v 0.8 2.3 -1.2
v -0.6 2.3 -1.3
v -0.5 2.3 -1.3
v -0.4 2.3 -1.3
v 0.5 2.3 -1.3
v 0.6 2.3 -1.3
v 0.7 2.3 -1.3
v -0.5 2.3 -1.4
v -0.4 2.3 -1.4
v 0.5 2.3 -1.4
v 0.6 2.3 -1.4
v -0.4 2.4 1.7
v 0.5 2.4 1.7
v -0.5 2.4 1.6
v -0.4 2.4 1.6
v 0.5 2.4 1.6
v 0.6 2.4 1.6
v -0.6 2.4 1.5
v -0.5 2.4 1.5
v -0.4 2.4 1.5
v 0.5 2.4 1.5
v 0.6 2.4 1.5
v 0.7 2.4 1.5
v -0.7 2.4 1.3
v -0.6 2.4 1.3
v -0.5 2.4 1.3
v 0.6 2.4 1.3
v 0.7 2.4 1.3
v 0.8 2.4 1.3
v -0.7 2.4 1.1
v -0.6 2.4 1.1
v -0.5 2.4 1.1
v 0.6 2.4 1.1
v 0.7 2.4 1.1
v 0.8 2.4 1.1
v -0.7 2.4 -0.8
v -0.6 2.4 -0.8
v -0.5 2.4 -0.8
v 0.6 2.4 -0.8
v 0.7 2.4 -0.8
v 0.8 2.4 -0.8
v -0.7 2.4 -1
v -0.6 2.4 -1
v -0.5 2.4 -1
v 0.6 2.4 -1
v 0.7 2.4 -1
v 0.8 2.4 -1
v -0.6 2.4 -1.2
v -0.5 2.4 -1.2
v -0.4 2.4 -1.2
v 0.5 2.4 -1.2
v 0.6 2.4 -1.2
v 0.7 2.4 -1.2
v -0.5 2.4 -1.3
v -0.4 2.4 -1.3
v 0.5 2.4 -1.3
v 0.6 2.4 -1.3
v -0.4 2.4 -1.4
v 0.5 2.4 -1.4
v -0.4 2.5 1.6
v -0.2 2.5 1.6
v 0.3 2.5 1.6
v 0.5 2.5 1.6
v -0.5 2.5 1.5
v -0.4 2.5 1.5
v -0.3 2.5 1.5
v -0.2 2.5 1.5
v 0.3 2.5 1.5
v 0.4 2.5 1.5
v 0.5 2.5 1.5
v 0.6 2.5 1.5
v -0.6 2.5 1.3
v -0.5 2.5 1.3
v -0.3 2.5 1.3
v 0.4 2.5 1.3
v 0.6 2.5 1.3
v 0.7 2.5 1.3
v -0.6 2.5 1.1
v -0.5 2.5 1.1
v -0.3 2.5 1.1
v 0.4 2.5 1.1
v 0.6 2.5 1.1
v 0.7 2.5 1.1
v -0.6 2.5 -0.8
v -0.5 2.5 -0.8
v -0.3 2.5 -0.8
v 0.4 2.5 -0.8
v 0.6 2.5 -0.8
v 0.7 2.5 -0.8
v -0.6 2.5 -1
v -0.5 2.5 -1
v -0.3 2.5 -1
v 0.4 2.5 -1
v 0.6 2.5 -1
v 0.7 2.5 -1
v -0.5 2.5 -1.2
v -0.4 2.5 -1.2
v -0.3 2.5 -1.2
v -0.2 2.5 -1.2
v 0.3 2.5 -1.2
v 0.4 2.5 -1.2
v 0.5 2.5 -1.2
v 0.6 2.5 -1.2
v -0.4 2.5 -1.3
v -0.2 2.5 -1.3
v 0.3 2.5 -1.3
v 0.5 2.5 -1.3
v -0.2 2.6 1.6
v 0.3 2.6 1.6
v -0.3 2.6 1.5
v -0.2 2.6 1.5
v 0.3 2.6 1.5
v 0.4 2.6 1.5
v -0.5 2.6 1.3
v -0.3 2.6 1.3
v 0.4 2.6 1.3
v 0.6 2.6 1.3
v -0.5 2.6 1.1
v -0.3 2.6 1.1
v -0.1 2.6 1.1
v 5.96046e-08 2.6 1.1
v 0.1 2.6 1.1
v 0.2 2.6 1.1
v 0.4 2.6 1.1
v 0.6 2.6 1.1
v -0.5 2.6 -0.8
v -0.3 2.6 -0.8
v -0.1 2.6 -0.8
v 5.96046e-08 2.6 -0.8
v 0.1 2.6 -0.8
v 0.2 2.6 -0.8
v 0.4 2.6 -0.8
v 0.6 2.6 -0.8
v -0.5 2.6 -1
v -0.3 2.6 -1
v 0.4 2.6 -1
v 0.6 2.6 -1
v -0.3 2.6 -1.2
v -0.2 2.6 -1.2
v 0.3 2.6 -1.2
v 0.4 2.6 -1.2
v -0.2 2.6 -1.3
v 0.3 2.6 -1.3
v -0.3 2.7 1.3
v 0.4 2.7 1.3
v -0.3 2.7 1.1
v -0.1 2.7 1.1
v 5.96046e-08 2.7 1.1
v 0.1 2.7 1.1
v 0.2 2.7 1.1
v 0.4 2.7 1.1
v -0.3 2.7 -0.8
v -0.1 2.7 -0.8
v 5.96046e-08 2.7 -0.8
v 0.1 2.7 -0.8
v 0.2 2.7 -0.8
v 0.4 2.7 -0.8
v -0.3 2.7 -1
v 0.4 2.7 -1

# faces
f 4/8/1 2/8/1 1/8/1
f 5/8/1 2/8/1 4/8/1
f 7/7/1 4/7/1 3/7/1
f 7/7/1 6/7/1 5/7/1
f 7/7/1 5/7/1 4/7/1
f 8/7/1 6/7/1 7/7/1
f 9/7/1 7/7/1 3/7/1
f 9/6/1 8/6/1 7/6/1
f 10/7/1 6/7/1 8/7/1
f 10/6/1 8/6/1 9/6/1
f 11/7/1 9/7/1 3/7/1
f 11/7/1 10/7/1 9/7/1
f 12/7/1 6/7/1 10/7/1
f 12/7/1 10/7/1 11/7/1
f 13/7/1 11/7/1 3/7/1
f 13/6/1 12/6/1 11/6/1
f 14/7/1 6/7/1 12/7/1
f 14/6/1 12/6/1 13/6/1
f 15/7/1 13/7/1 3/7/1
f 18/7/1 6/7/1 14/7/1
f 19/7/1 16/7/1 15/7/1
f 20/7/1 18/7/1 17/7/1
f 21/7/1 19/7/1 15/7/1
f 21/7/1 20/7/1 19/7/1
f 21/7/1 15/7/1 3/7/1
f 22/7/1 20/7/1 21/7/1
f 23/7/1 18/7/1 20/7/1
f 23/7/1 20/7/1 22/7/1
f 23/7/1 6/7/1 18/7/1
f 24/7/1 6/7/1 23/7/1
f 25/7/1 23/7/1 22/7/1
f 26/7/1 23/7/1 25/7/1
f 27/7/1 23/7/1 26/7/1
f 28/7/1 23/7/1 27/7/1
f 29/7/1 23/7/1 28/7/1
f 30/7/1 23/7/1 29/7/1
f 31/7/1 27/7/1 26/7/1
f 32/7/1 27/7/1 31/7/1
f 33/7/1 29/7/1 28/7/1
f 34/7/1 29/7/1 33/7/1
f 39/2/1 36/2/1 35/2/1
f 40/2/1 36/2/1 39/2/1
f 41/2/1 38/2/1 37/2/1
f 42/2/1 38/2/1 41/2/1
f 44/2/1 39/2/1 35/2/1
f 45/1/1 40/1/1 39/1/1
f 45/2/1 39/2/1 44/2/1
f 46/2/1 36/2/1 40/2/1
f 46/1/1 40/1/1 45/1/1
f 47/2/1 36/2/1 46/2/1
f 50/2/1 41/2/1 37/2/1
f 51/1/1 42/1/1 41/1/1
f 51/2/1 41/2/1 50/2/1
f 52/2/1 38/2/1 42/2/1
f 52/1/1 42/1/1 51/1/1
f 53/2/1 38/2/1 52/2/1
f 56/2/1 45/2/1 44/2/1
f 56/2/1 44/2/1 43/2/1
f 56/2/1 48/2/1 47/2/1
f 56/2/1 46/2/1 45/2/1
f 56/2/1 47/2/1 46/2/1
f 57/2/1 48/2/1 56/2/1
f 58/2/1 54/2/1 53/2/1
f 58/2/1 51/2/1 50/2/1
f 58/2/1 53/2/1 52/2/1
f 58/2/1 52/2/1 51/2/1
f 58/2/1 50/2/1 49/2/1
f 59/2/1 54/2/1 58/2/1
f 62/8/1 56/8/1 55/8/1
f 63/8/1 56/8/1 62/8/1
f 64/8/1 60/8/1 59/8/1
f 65/8/1 60/8/1 64/8/1
f 69/7/1 68/7/1 67/7/1
f 70/7/1 68/7/1 69/7/1
f 71/7/1 68/7/1 70/7/1
f 72/7/1 68/7/1 71/7/1
f 73/7/1 68/7/1 72/7/1
f 74/7/1 68/7/1 73/7/1
f 75/7/1 68/7/1 74/7/1
f 76/7/1 68/7/1 75/7/1
f 77/7/1 69/7/1 67/7/1
f 78/7/1 69/7/1 77/7/1
f 79/7/1 71/7/1 70/7/1
f 80/7/1 71/7/1 79/7/1
f 81/7/1 73/7/1 72/7/1
f 82/7/1 73/7/1 81/7/1
f 83/7/1 75/7/1 74/7/1
f 84/7/1 75/7/1 83/7/1
f 85/7/1 68/7/1 76/7/1
f 86/7/1 68/7/1 85/7/1
f 87/7/1 84/7/1 83/7/1
f 87/7/1 82/7/1 81/7/1
f 87/7/1 85/7/1 84/7/1
f 87/7/1 83/7/1 82/7/1
f 87/7/1 80/7/1 79/7/1
f 87/7/1 81/7/1 80/7/1
f 87/7/1 79/7/1 78/7/1
f 88/7/1 85/7/1 87/7/1
f 89/7/1 62/7/1 61/7/1
f 90/7/1 62/7/1 89/7/1
f 93/7/1 66/7/1 65/7/1
f 94/7/1 66/7/1 93/7/1
f 95/7/1 91/7/1 90/7/1
f 96/7/1 91/7/1 95/7/1
f 101/7/1 93/7/1 92/7/1
f 102/7/1 93/7/1 101/7/1
f 103/7/1 97/7/1 96/7/1
f 104/7/1 97/7/1 103/7/1
f 105/7/1 99/7/1 98/7/1
f 106/7/1 99/7/1 105/7/1
f 107/7/1 101/7/1 100/7/1
f 108/7/1 101/7/1 107/7/1
f 109/7/1 105/7/1 104/7/1
f 110/7/1 105/7/1 109/7/1
f 111/7/1 107/7/1 106/7/1
f 112/7/1 107/7/1 111/7/1
f 117/8/1 114/8/1 113/8/1
f 118/8/1 114/8/1 117/8/1
f 119/8/1 116/8/1 115/8/1
f 120/8/1 116/8/1 119/8/1
f 133/4/1 122/4/1 121/4/1
f 134/3/1 123/3/1 122/3/1
f 134/4/1 122/4/1 133/4/1
f 135/3/1 123/3/1 134/3/1
f 136/4/1 131/4/1 130/4/1
f 137/3/1 132/3/1 131/3/1
f 137/4/1 131/4/1 136/4/1
f 138/3/1 132/3/1 137/3/1
f 139/3/1 134/3/1 133/3/1
f 139/4/1 135/4/1 134/4/1
f 140/3/1 123/3/1 135/3/1
f 140/4/1 135/4/1 139/4/1
f 141/3/1 123/3/1 140/3/1
f 142/4/1 138/4/1 137/4/1
f 142/3/1 137/3/1 136/3/1
f 143/3/1 132/3/1 138/3/1
f 143/4/1 138/4/1 142/4/1
f 144/3/1 132/3/1 143/3/1
f 145/4/1 141/4/1 140/4/1
f 145/3/1 140/3/1 139/3/1
f 146/3/1 123/3/1 141/3/1
f 146/4/1 141/4/1 145/4/1
f 147/3/1 123/3/1 146/3/1
f 148/4/1 144/4/1 143/4/1
f 148/3/1 143/3/1 142/3/1
f 149/3/1 132/3/1 144/3/1
f 149/4/1 144/4/1 148/4/1
f 150/3/1 132/3/1 149/3/1
f 151/4/1 147/4/1 146/4/1
f 151/3/1 146/3/1 145/3/1
f 152/3/1 123/3/1 147/3/1
f 152/4/1 147/4/1 151/4/1
f 153/3/1 123/3/1 152/3/1
f 154/4/1 150/4/1 149/4/1
f 154/3/1 149/3/1 148/3/1
f 155/3/1 132/3/1 150/3/1
f 155/4/1 150/4/1 154/4/1
f 156/3/1 132/3/1 155/3/1
f 157/4/1 153/4/1 152/4/1
f 157/3/1 152/3/1 151/3/1
f 158/3/1 123/3/1 153/3/1
f 158/4/1 153/4/1 157/4/1
f 159/3/1 123/3/1 158/3/1
f 160/4/1 156/4/1 155/4/1
f 160/3/1 155/3/1 154/3/1
f 161/3/1 132/3/1 156/3/1
f 161/4/1 156/4/1 160/4/1
f 162/3/1 132/3/1 161/3/1
f 163/3/1 139/3/1 133/3/1
f 163/3/1 145/3/1 139/3/1
f 163/3/1 151/3/1 145/3/1
f 163/3/1 157/3/1 151/3/1
f 163/3/1 158/3/1 157/3/1
f 164/4/1 159/4/1 158/4/1
f 164/3/1 158/3/1 163/3/1
f 165/4/1 159/4/1 164/4/1
f 166/3/1 125/3/1 124/3/1
f 167/4/1 126/4/1 125/4/1
f 167/3/1 125/3/1 166/3/1
f 168/4/1 126/4/1 167/4/1
f 169/4/1 128/4/1 127/4/1
f 170/3/1 129/3/1 128/3/1
f 170/4/1 128/4/1 169/4/1
f 171/3/1 129/3/1 170/3/1
f 172/3/1 142/3/1 136/3/1
f 172/3/1 148/3/1 142/3/1
f 172/3/1 161/3/1 160/3/1
f 172/3/1 154/3/1 148/3/1
f 172/3/1 160/3/1 154/3/1
f 173/4/1 162/4/1 161/4/1
f 173/3/1 161/3/1 172/3/1
f 174/4/1 162/4/1 173/4/1
f 179/7/1 176/7/1 175/7/1
f 180/7/1 176/7/1 179/7/1
f 183/7/1 178/7/1 177/7/1
f 184/7/1 178/7/1 183/7/1
f 185/7/1 181/7/1 180/7/1
f 186/7/1 181/7/1 185/7/1
f 191/7/1 183/7/1 182/7/1
f 192/7/1 183/7/1 191/7/1
f 193/7/1 187/7/1 186/7/1
f 194/7/1 187/7/1 193/7/1
f 195/7/1 189/7/1 188/7/1
f 196/7/1 189/7/1 195/7/1
f 197/7/1 191/7/1 190/7/1
f 198/7/1 191/7/1 197/7/1
f 199/7/1 195/7/1 194/7/1
f 200/7/1 195/7/1 199/7/1
f 201/7/1 197/7/1 196/7/1
f 202/7/1 197/7/1 201/7/1
f 207/7/1 204/7/1 203/7/1
f 208/7/1 204/7/1 207/7/1
f 211/7/1 206/7/1 205/7/1
f 212/7/1 206/7/1 211/7/1
f 213/7/1 209/7/1 208/7/1
f 214/7/1 209/7/1 213/7/1
f 215/7/1 211/7/1 210/7/1
f 216/7/1 211/7/1 215/7/1
f 223/7/1 218/7/1 217/7/1
f 224/7/1 218/7/1 223/7/1
f 225/7/1 220/7/1 219/7/1
f 226/7/1 220/7/1 225/7/1
f 227/7/1 222/7/1 221/7/1
f 228/7/1 222/7/1 227/7/1
f 229/7/1 225/7/1 224/7/1
f 230/7/1 225/7/1 229/7/1
f 231/7/1 227/7/1 226/7/1
f 232/7/1 227/7/1 231/7/1
f 237/5/1 234/5/1 233/5/1
f 238/5/1 234/5/1 237/5/1
f 239/5/1 236/5/1 235/5/1
f 240/5/1 236/5/1 239/5/1
f 245/7/1 242/7/1 241/7/1
f 246/7/1 242/7/1 245/7/1
f 247/7/1 244/7/1 243/7/1
f 248/7/1 244/7/1 247/7/1
f 253/5/1 250/5/1 249/5/1
f 254/5/1 250/5/1 253/5/1
f 255/5/1 252/5/1 251/5/1
f 256/5/1 252/5/1 255/5/1
f 259/6/1 258/6/1 257/6/1
f 260/6/1 258/6/1 259/6/1
f 265/5/1 262/5/1 261/5/1
f 266/5/1 262/5/1 265/5/1
f 267/5/1 264/5/1 263/5/1
f 268/5/1 264/5/1 267/5/1
f 271/6/1 270/6/1 269/6/1
f 272/6/1 270/6/1 271/6/1
f 278/2/1 274/2/1 273/2/1
f 279/2/1 274/2/1 278/2/1
f 282/2/1 276/2/1 275/2/1
f 283/2/1 276/2/1 282/2/1
f 285/2/1 280/2/1 279/2/1
f 285/2/1 278/2/1 277/2/1
f 285/2/1 279/2/1 278/2/1
f 286/2/1 280/2/1 285/2/1
f 287/2/1 284/2/1 283/2/1
f 287/2/1 283/2/1 282/2/1
f 287/2/1 282/2/1 281/2/1
f 288/2/1 284/2/1 287/2/1
f 289/2/2 290/2/2 294/2/2
f 294/2/2 290/2/2 295/2/2
f 291/2/2 292/2/2 298/2/2
f 298/2/2 292/2/2 299/2/2
f 295/2/2 296/2/2 301/2/2
f 293/2/2 294/2/2 301/2/2
f 294/2/2 295/2/2 301/2/2
f 301/2/2 296/2/2 302/2/2
f 299/2/2 300/2/2 303/2/2
f 298/2/2 299/2/2 303/2/2
f 297/2/2 298/2/2 303/2/2
f 303/2/2 300/2/2 304/2/2
f 305/6/2 306/6/2 307/6/2
f 307/6/2 306/6/2 308/6/2
f 309/5/2 310/5/2 313/5/2
f 313/5/2 310/5/2 314/5/2
f 311/5/2 312/5/2 315/5/2
f 315/5/2 312/5/2 316/5/2
f 317/5/2 318/5/2 321/5/2
f 321/5/2 318/5/2 322/5/2
f 319/5/2 320/5/2 323/5/2
f 323/5/2 320/5/2 324/5/2
f 325/6/2 326/6/2 327/6/2
f 327/6/2 326/6/2 328/6/2
f 329/5/2 330/5/2 333/5/2
f 333/5/2 330/5/2 334/5/2
f 331/5/2 332/5/2 335/5/2
f 335/5/2 332/5/2 336/5/2
f 337/7/2 338/7/2 341/7/2
f 341/7/2 338/7/2 342/7/2
f 339/7/2 340/7/2 343/7/2
f 343/7/2 340/7/2 344/7/2
f 345/7/2 346/7/2 351/7/2
f 351/7/2 346/7/2 352/7/2
f 347/7/2 348/7/2 353/7/2
f 353/7/2 348/7/2 354/7/2
f 349/7/2 350/7/2 355/7/2
f 355/7/2 350/7/2 356/7/2
f 352/7/2 353/7/2 357/7/2
f 357/7/2 353/7/2 358/7/2
f 354/7/2 355/7/2 359/7/2
f 359/7/2 355/7/2 360/7/2
f 361/7/2 362/7/2 365/7/2
f 365/7/2 362/7/2 366/7/2
f 363/7/2 364/7/2 369/7/2
f 369/7/2 364/7/2 370/7/2
f 366/7/2 367/7/2 371/7/2
f 371/7/2 367/7/2 372/7/2
f 368/7/2 369/7/2 373/7/2
f 373/7/2 369/7/2 374/7/2
f 375/8/2 376/8/2 379/8/2
f 379/8/2 376/8/2 380/8/2
f 377/8/2 378/8/2 381/8/2
f 381/8/2 378/8/2 382/8/2
f 383/3/2 384/3/2 395/3/2
f 384/4/2 385/4/2 396/4/2
f 395/3/2 384/3/2 396/3/2
f 396/4/2 385/4/2 397/4/2
f 392/3/2 393/3/2 398/3/2
f 393/4/2 394/4/2 399/4/2
f 398/3/2 393/3/2 399/3/2
f 399/4/2 394/4/2 400/4/2
f 383/3/2 395/3/2 401/3/2
f 395/4/2 396/4/2 402/4/2
f 401/3/2 395/3/2 402/3/2
f 396/3/2 397/3/2 403/3/2
f 402/4/2 396/4/2 403/4/2
f 392/3/2 398/3/2 404/3/2
f 398/4/2 399/4/2 405/4/2
f 404/3/2 398/3/2 405/3/2
f 399/3/2 400/3/2 406/3/2
f 405/4/2 399/4/2 406/4/2
f 383/3/2 401/3/2 407/3/2
f 401/4/2 402/4/2 408/4/2
f 407/3/2 401/3/2 408/3/2
f 402/3/2 403/3/2 409/3/2
f 408/4/2 402/4/2 409/4/2
f 392/3/2 404/3/2 410/3/2
f 404/4/2 405/4/2 411/4/2
f 410/3/2 404/3/2 411/3/2
f 405/3/2 406/3/2 412/3/2
f 411/4/2 405/4/2 412/4/2
f 383/3/2 407/3/2 413/3/2
f 407/4/2 408/4/2 414/4/2
f 413/3/2 407/3/2 414/3/2
f 408/3/2 409/3/2 415/3/2
f 414/4/2 408/4/2 415/4/2
f 392/3/2 410/3/2 416/3/2
f 410/4/2 411/4/2 417/4/2
f 416/3/2 410/3/2 417/3/2
f 411/3/2 412/3/2 418/3/2
f 417/4/2 411/4/2 418/4/2
f 383/3/2 413/3/2 419/3/2
f 413/4/2 414/4/2 420/4/2
f 419/3/2 413/3/2 420/3/2
f 414/3/2 415/3/2 421/3/2
f 420/4/2 414/4/2 421/4/2
f 392/3/2 416/3/2 422/3/2
f 416/4/2 417/4/2 423/4/2
f 422/3/2 416/3/2 423/3/2
f 417/3/2 418/3/2 424/3/2
f 423/4/2 417/4/2 424/4/2
f 419/4/2 420/4/2 425/4/2
f 420/3/2 421/3/2 426/3/2
f 425/4/2 420/4/2 426/4/2
f 403/3/2 397/3/2 427/3/2
f 426/3/2 421/3/2 427/3/2
f 409/3/2 403/3/2 427/3/2
f 415/3/2 409/3/2 427/3/2
f 421/3/2 415/3/2 427/3/2
f 386/3/2 387/3/2 428/3/2
f 387/4/2 388/4/2 429/4/2
f 428/3/2 387/3/2 429/3/2
f 429/4/2 388/4/2 430/4/2
f 389/4/2 390/4/2 431/4/2
f 390/3/2 391/3/2 432/3/2
f 431/4/2 390/4/2 432/4/2
f 432/3/2 391/3/2 433/3/2
f 422/4/2 423/4/2 434/4/2
f 423/3/2 424/3/2 435/3/2
f 434/4/2 423/4/2 435/4/2
f 412/3/2 406/3/2 436/3/2
f 435/3/2 424/3/2 436/3/2
f 406/3/2 400/3/2 436/3/2
f 418/3/2 412/3/2 436/3/2
f 424/3/2 418/3/2 436/3/2
f 437/7/2 438/7/2 441/7/2
f 441/7/2 438/7/2 442/7/2
f 439/7/2 440/7/2 445/7/2
f 445/7/2 440/7/2 446/7/2
f 442/7/2 443/7/2 447/7/2
f 447/7/2 443/7/2 448/7/2
f 444/7/2 445/7/2 453/7/2
f 453/7/2 445/7/2 454/7/2
f 448/7/2 449/7/2 455/7/2
f 455/7/2 449/7/2 456/7/2
f 450/7/2 451/7/2 457/7/2
f 457/7/2 451/7/2 458/7/2
f 452/7/2 453/7/2 459/7/2
f 459/7/2 453/7/2 460/7/2
f 456/7/2 457/7/2 461/7/2
f 461/7/2 457/7/2 462/7/2
f 458/7/2 459/7/2 463/7/2
f 463/7/2 459/7/2 464/7/2
f 465/2/2 466/2/2 469/2/2
f 469/2/2 466/2/2 470/2/2
f 467/2/2 468/2/2 471/2/2
f 471/2/2 468/2/2 472/2/2
f 465/2/2 469/2/2 474/2/2
f 469/1/2 470/1/2 475/1/2
f 474/2/2 469/2/2 475/2/2
f 470/2/2 466/2/2 476/2/2
f 475/1/2 470/1/2 476/1/2
f 476/2/2 466/2/2 477/2/2
f 467/2/2 471/2/2 480/2/2
f 471/1/2 472/1/2 481/1/2
f 480/2/2 471/2/2 481/2/2
f 472/2/2 468/2/2 482/2/2
f 481/1/2 472/1/2 482/1/2
f 482/2/2 468/2/2 483/2/2
f 474/2/2 475/2/2 486/2/2
f 473/2/2 474/2/2 486/2/2
f 477/2/2 478/2/2 486/2/2
f 475/2/2 476/2/2 486/2/2
f 476/2/2 477/2/2 486/2/2
f 486/2/2 478/2/2 487/2/2
f 483/2/2 484/2/2 488/2/2
f 480/2/2 481/2/2 488/2/2
f 482/2/2 483/2/2 488/2/2
f 481/2/2 482/2/2 488/2/2
f 479/2/2 480/2/2 488/2/2
f 488/2/2 484/2/2 489/2/2
f 485/8/2 486/8/2 492/8/2
f 492/8/2 486/8/2 493/8/2
f 489/8/2 490/8/2 494/8/2
f 494/8/2 490/8/2 495/8/2
f 497/7/2 498/7/2 499/7/2
f 499/7/2 498/7/2 500/7/2
f 500/7/2 498/7/2 501/7/2
f 501/7/2 498/7/2 502/7/2
f 502/7/2 498/7/2 503/7/2
f 503/7/2 498/7/2 504/7/2
f 504/7/2 498/7/2 505/7/2
f 505/7/2 498/7/2 506/7/2
f 497/7/2 499/7/2 507/7/2
f 507/7/2 499/7/2 508/7/2
f 500/7/2 501/7/2 509/7/2
f 509/7/2 501/7/2 510/7/2
f 502/7/2 503/7/2 511/7/2
f 511/7/2 503/7/2 512/7/2
f 504/7/2 505/7/2 513/7/2
f 513/7/2 505/7/2 514/7/2
f 506/7/2 498/7/2 515/7/2
f 515/7/2 498/7/2 516/7/2
f 513/7/2 514/7/2 517/7/2
f 511/7/2 512/7/2 517/7/2
f 514/7/2 515/7/2 517/7/2
f 512/7/2 513/7/2 517/7/2
f 509/7/2 510/7/2 517/7/2
f 510/7/2 511/7/2 517/7/2
f 508/7/2 509/7/2 517/7/2
f 517/7/2 515/7/2 518/7/2
f 491/7/2 492/7/2 519/7/2
f 519/7/2 492/7/2 520/7/2
f 495/7/2 496/7/2 523/7/2
f 523/7/2 496/7/2 524/7/2
f 520/7/2 521/7/2 525/7/2
f 525/7/2 521/7/2 526/7/2
f 522/7/2 523/7/2 531/7/2
f 531/7/2 523/7/2 532/7/2
f 526/7/2 527/7/2 533/7/2
f 533/7/2 527/7/2 534/7/2
f 528/7/2 529/7/2 535/7/2
f 535/7/2 529/7/2 536/7/2
f 530/7/2 531/7/2 537/7/2
f 537/7/2 531/7/2 538/7/2
f 534/7/2 535/7/2 539/7/2
f 539/7/2 535/7/2 540/7/2
f 536/7/2 537/7/2 541/7/2
f 541/7/2 537/7/2 542/7/2
f 543/8/2 544/8/2 546/8/2
f 546/8/2 544/8/2 547/8/2
f 545/7/2 546/7/2 549/7/2
f 547/7/2 548/7/2 549/7/2
f 546/7/2 547/7/2 549/7/2
f 549/7/2 548/7/2 550/7/2
f 545/7/2 549/7/2 551/7/2
f 549/6/2 550/6/2 551/6/2
f 550/7/2 548/7/2 552/7/2
f 551/6/2 550/6/2 552/6/2
f 545/7/2 551/7/2 553/7/2
f 551/7/2 552/7/2 553/7/2
f 552/7/2 548/7/2 554/7/2
f 553/7/2 552/7/2 554/7/2
f 545/7/2 553/7/2 555/7/2
f 553/6/2 554/6/2 555/6/2
f 554/7/2 548/7/2 556/7/2
f 555/6/2 554/6/2 556/6/2
f 545/7/2 555/7/2 557/7/2
f 556/7/2 548/7/2 560/7/2
f 557/7/2 558/7/2 561/7/2
f 559/7/2 560/7/2 562/7/2
f 557/7/2 561/7/2 563/7/2
f 561/7/2 562/7/2 563/7/2
f 545/7/2 557/7/2 563/7/2
f 563/7/2 562/7/2 564/7/2
f 562/7/2 560/7/2 565/7/2
f 564/7/2 562/7/2 565/7/2
f 560/7/2 548/7/2 565/7/2
f 565/7/2 548/7/2 566/7/2
f 564/7/2 565/7/2 567/7/2
f 567/7/2 565/7/2 568/7/2
f 568/7/2 565/7/2 569/7/2
f 569/7/2 565/7/2 570/7/2
f 570/7/2 565/7/2 571/7/2
f 571/7/2 565/7/2 572/7/2
f 568/7/2 569/7/2 573/7/2
f 573/7/2 569/7/2 574/7/2
f 570/7/2 571/7/2 575/7/2
f 575/7/2 571/7/2 576/7/2
f 579/5/3 578/5/3 577/5/3
f 580/5/3 578/5/3 579/5/3
f 583/5/3 582/5/3 581/5/3
f 584/5/3 582/5/3 583/5/3
f 587/5/3 586/5/3 585/5/3
f 588/5/3 586/5/3 587/5/3
f 591/5/3 590/5/3 589/5/3
f 592/5/3 590/5/3 591/5/3
f 595/5/3 594/5/3 593/5/3
f 596/5/3 594/5/3 595/5/3
f 600/7/3 598/7/3 597/7/3
f 601/7/3 598/7/3 600/7/3
f 603/7/3 601/7/3 600/7/3
f 603/7/3 602/7/3 601/7/3
f 605/8/3 600/8/3 599/8/3
f 606/7/3 604/7/3 603/7/3
f 606/8/3 600/8/3 605/8/3
f 606/7/3 603/7/3 600/7/3
f 608/7/3 604/7/3 606/7/3
f 609/7/3 604/7/3 608/7/3
f 610/7/3 604/7/3 609/7/3
f 611/8/3 608/8/3 607/8/3
f 612/7/3 609/7/3 608/7/3
f 612/8/3 608/8/3 611/8/3
f 613/7/3 609/7/3 612/7/3
f 614/7/3 609/7/3 613/7/3
f 615/7/3 613/7/3 612/7/3
f 616/7/3 613/7/3 615/7/3
f 620/7/3 618/7/3 617/7/3
f 621/7/3 618/7/3 620/7/3
f 623/8/3 620/8/3 619/8/3
f 624/8/3 620/8/3 623/8/3
f 625/7/3 622/7/3 621/7/3
f 626/7/3 622/7/3 625/7/3
f 628/7/3 627/7/3 626/7/3
f 629/7/3 627/7/3 628/7/3
f 631/7/3 630/7/3 629/7/3
f 633/7/3 631/7/3 629/7/3
f 633/7/3 632/7/3 631/7/3
f 634/7/3 632/7/3 633/7/3
f 636/7/3 633/7/3 629/7/3
f 637/7/3 633/7/3 636/7/3
f 641/7/3 636/7/3 635/7/3
f 642/7/3 636/7/3 641/7/3
f 643/8/3 639/8/3 638/8/3
f 644/8/3 639/8/3 643/8/3
f 645/7/3 641/7/3 640/7/3
f 646/7/3 641/7/3 645/7/3
f 647/7/3 645/7/3 644/7/3
f 648/7/3 645/7/3 647/7/3
f 654/8/3 650/8/3 649/8/3
f 655/8/3 650/8/3 654/8/3
f 656/7/3 652/7/3 651/7/3
f 657/7/3 652/7/3 656/7/3
f 659/7/3 658/7/3 657/7/3
f 660/7/3 658/7/3 659/7/3
f 662/7/3 661/7/3 660/7/3
f 663/7/3 661/7/3 662/7/3
f 664/2/3 654/2/3 653/2/3
f 665/2/3 654/2/3 664/2/3
f 668/7/3 667/7/3 666/7/3
f 669/7/3 667/7/3 668/7/3
f 674/7/3 671/7/3 670/7/3
f 675/7/3 671/7/3 674/7/3
f 679/7/3 677/7/3 676/7/3
f 680/7/3 677/7/3 679/7/3
f 681/2/3 673/2/3 672/2/3
f 682/2/3 673/2/3 681/2/3
f 685/7/3 679/7/3 678/7/3
f 686/7/3 679/7/3 685/7/3
f 687/8/3 683/8/3 682/8/3
f 688/8/3 683/8/3 687/8/3
f 689/7/3 685/7/3 684/7/3
f 690/7/3 685/7/3 689/7/3
f 693/2/3 692/2/3 691/2/3
f 694/2/3 692/2/3 693/2/3
f 697/2/3 696/2/3 695/2/3
f 698/2/3 696/2/3 697/2/3
f 701/7/3 700/7/3 699/7/3
f 702/7/3 700/7/3 701/7/3
f 704/7/3 703/7/3 702/7/3
f 705/7/3 703/7/3 704/7/3
f 707/7/3 706/7/3 705/7/3
f 708/7/3 706/7/3 707/7/3
f 711/7/3 709/7/3 708/7/3
f 712/7/3 709/7/3 711/7/3
f 714/7/3 711/7/3 710/7/3
f 715/7/3 711/7/3 714/7/3
f 717/7/3 714/7/3 713/7/3
f 718/7/3 714/7/3 717/7/3
f 719/7/3 717/7/3 716/7/3
f 720/7/3 717/7/3 719/7/3
f 723/7/3 722/7/3 721/7/3
f 724/7/3 722/7/3 723/7/3
f 725/7/3 722/7/3 724/7/3
f 729/7/3 727/7/3 726/7/3
f 729/7/3 728/7/3 727/7/3
f 730/7/3 728/7/3 729/7/3
f 733/7/3 732/7/3 731/7/3
f 734/7/3 732/7/3 733/7/3
f 737/7/3 736/7/3 735/7/3
f 738/7/3 736/7/3 737/7/3
f 741/7/3 740/7/3 739/7/3
f 742/7/3 740/7/3 741/7/3
f 745/7/3 744/7/3 743/7/3
f 746/7/3 744/7/3 745/7/3
f 749/2/3 748/2/3 747/2/3
f 750/2/3 748/2/3 749/2/3
f 753/2/3 752/2/3 751/2/3
f 754/2/3 752/2/3 753/2/3
f 759/7/3 756/7/3 755/7/3
f 760/7/3 756/7/3 759/7/3
f 762/7/3 761/7/3 760/7/3
f 763/7/3 761/7/3 762/7/3
f 765/2/3 758/2/3 757/2/3
f 766/2/3 758/2/3 765/2/3
f 767/7/3 764/7/3 763/7/3
f 768/7/3 764/7/3 767/7/3
f 770/7/3 769/7/3 768/7/3
f 771/7/3 769/7/3 770/7/3
f 774/7/3 773/7/3 772/7/3
f 775/7/3 773/7/3 774/7/3
f 781/7/3 777/7/3 776/7/3
f 782/7/3 777/7/3 781/7/3
f 784/7/3 781/7/3 780/7/3
f 785/7/3 781/7/3 784/7/3
f 786/2/3 779/2/3 778/2/3
f 787/2/3 779/2/3 786/2/3
f 789/7/3 784/7/3 783/7/3
f 790/7/3 784/7/3 789/7/3
f 791/7/3 789/7/3 788/7/3
f 792/7/3 789/7/3 791/7/3
f 796/7/3 794/7/3 793/7/3
f 797/7/3 794/7/3 796/7/3
f 798/7/3 796/7/3 795/7/3
f 799/7/3 796/7/3 798/7/3
f 800/7/3 796/7/3 799/7/3
f 804/7/3 802/7/3 801/7/3
f 804/7/3 803/7/3 802/7/3
f 805/7/3 803/7/3 804/7/3
f 807/7/3 806/7/3 805/7/3
f 808/7/3 806/7/3 807/7/3
f 811/7/3 810/7/3 809/7/3
f 812/7/3 810/7/3 811/7/3
f 815/7/3 814/7/3 813/7/3
f 816/7/3 814/7/3 815/7/3
f 817/7/4 818/7/4 819/7/4
f 819/7/4 818/7/4 820/7/4
f 821/7/4 822/7/4 823/7/4
f 823/7/4 822/7/4 824/7/4
f 825/7/4 826/7/4 828/7/4
f 828/7/4 826/7/4 829/7/4
f 827/7/4 828/7/4 830/7/4
f 830/7/4 828/7/4 831/7/4
f 831/7/4 828/7/4 832/7/4
f 833/7/4 834/7/4 836/7/4
f 834/7/4 835/7/4 836/7/4
f 836/7/4 835/7/4 837/7/4
f 837/7/4 838/7/4 839/7/4
f 839/7/4 838/7/4 840/7/4
f 841/7/4 842/7/4 845/7/4
f 845/7/4 842/7/4 846/7/4
f 846/7/4 847/7/4 848/7/4
f 848/7/4 847/7/4 849/7/4
f 843/2/4 844/2/4 851/2/4
f 851/2/4 844/2/4 852/2/4
f 849/7/4 850/7/4 853/7/4
f 853/7/4 850/7/4 854/7/4
f 854/7/4 855/7/4 856/7/4
f 856/7/4 855/7/4 857/7/4
f 858/7/4 859/7/4 860/7/4
f 860/7/4 859/7/4 861/7/4
f 862/7/4 863/7/4 867/7/4
f 867/7/4 863/7/4 868/7/4
f 866/7/4 867/7/4 870/7/4
f 870/7/4 867/7/4 871/7/4
f 864/2/4 865/2/4 872/2/4
f 872/2/4 865/2/4 873/2/4
f 869/7/4 870/7/4 875/7/4
f 875/7/4 870/7/4 876/7/4
f 874/7/4 875/7/4 877/7/4
f 877/7/4 875/7/4 878/7/4
f 879/2/4 880/2/4 881/2/4
f 881/2/4 880/2/4 882/2/4
f 883/2/4 884/2/4 885/2/4
f 885/2/4 884/2/4 886/2/4
f 887/7/4 888/7/4 889/7/4
f 889/7/4 888/7/4 890/7/4
f 891/7/4 892/7/4 893/7/4
f 893/7/4 892/7/4 894/7/4
f 895/7/4 896/7/4 897/7/4
f 897/7/4 896/7/4 898/7/4
f 899/7/4 900/7/4 901/7/4
f 901/7/4 900/7/4 902/7/4
f 903/7/4 904/7/4 905/7/4
f 905/7/4 904/7/4 906/7/4
f 906/7/4 904/7/4 907/7/4
f 908/7/4 909/7/4 911/7/4
f 909/7/4 910/7/4 911/7/4
f 911/7/4 910/7/4 912/7/4
f 913/7/4 914/7/4 915/7/4
f 915/7/4 914/7/4 916/7/4
f 916/7/4 917/7/4 918/7/4
f 918/7/4 917/7/4 919/7/4
f 919/7/4 920/7/4 921/7/4
f 921/7/4 920/7/4 922/7/4
f 922/7/4 923/7/4 925/7/4
f 925/7/4 923/7/4 926/7/4
f 924/7/4 925/7/4 928/7/4
f 928/7/4 925/7/4 929/7/4
f 927/7/4 928/7/4 931/7/4
f 931/7/4 928/7/4 932/7/4
f 930/7/4 931/7/4 933/7/4
f 933/7/4 931/7/4 934/7/4
f 935/2/4 936/2/4 937/2/4
f 937/2/4 936/2/4 938/2/4
f 939/2/4 940/2/4 941/2/4
f 941/2/4 940/2/4 942/2/4
f 943/8/4 944/8/4 948/8/4
f 948/8/4 944/8/4 949/8/4
f 945/7/4 946/7/4 950/7/4
f 950/7/4 946/7/4 951/7/4
f 951/7/4 952/7/4 953/7/4
f 953/7/4 952/7/4 954/7/4
f 954/7/4 955/7/4 956/7/4
f 956/7/4 955/7/4 957/7/4
f 947/2/4 948/2/4 958/2/4
f 958/2/4 948/2/4 959/2/4
f 960/7/4 961/7/4 962/7/4
f 962/7/4 961/7/4 963/7/4
f 964/7/4 965/7/4 968/7/4
f 968/7/4 965/7/4 969/7/4
f 970/7/4 971/7/4 973/7/4
f 973/7/4 971/7/4 974/7/4
f 966/2/4 967/2/4 975/2/4
f 975/2/4 967/2/4 976/2/4
f 972/7/4 973/7/4 979/7/4
f 979/7/4 973/7/4 980/7/4
f 976/8/4 977/8/4 981/8/4
f 981/8/4 977/8/4 982/8/4
f 978/7/4 979/7/4 983/7/4
f 983/7/4 979/7/4 984/7/4
f 985/7/4 986/7/4 988/7/4
f 988/7/4 986/7/4 989/7/4
f 987/8/4 988/8/4 991/8/4
f 991/8/4 988/8/4 992/8/4
f 989/7/4 990/7/4 993/7/4
f 993/7/4 990/7/4 994/7/4
f 994/7/4 995/7/4 996/7/4
f 996/7/4 995/7/4 997/7/4
f 997/7/4 998/7/4 999/7/4
f 997/7/4 999/7/4 1001/7/4
f 999/7/4 1000/7/4 1001/7/4
f 1001/7/4 1000/7/4 1002/7/4
f 997/7/4 1001/7/4 1004/7/4
f 1004/7/4 1001/7/4 1005/7/4
f 1003/7/4 1004/7/4 1009/7/4
f 1009/7/4 1004/7/4 1010/7/4
f 1006/8/4 1007/8/4 1011/8/4
f 1011/8/4 1007/8/4 1012/8/4
f 1008/7/4 1009/7/4 1013/7/4
f 1013/7/4 1009/7/4 1014/7/4
f 1012/7/4 1013/7/4 1015/7/4
f 1015/7/4 1013/7/4 1016/7/4
f 1017/7/4 1018/7/4 1020/7/4
f 1020/7/4 1018/7/4 1021/7/4
f 1020/7/4 1021/7/4 1023/7/4
f 1021/7/4 1022/7/4 1023/7/4
f 1019/8/4 1020/8/4 1025/8/4
f 1023/7/4 1024/7/4 1026/7/4
f 1025/8/4 1020/8/4 1026/8/4
f 1020/7/4 1023/7/4 1026/7/4
f 1026/7/4 1024/7/4 1028/7/4
f 1028/7/4 1024/7/4 1029/7/4
f 1029/7/4 1024/7/4 1030/7/4
f 1027/8/4 1028/8/4 1031/8/4
f 1028/7/4 1029/7/4 1032/7/4
f 1031/8/4 1028/8/4 1032/8/4
f 1032/7/4 1029/7/4 1033/7/4
f 1033/7/4 1029/7/4 1034/7/4
f 1032/7/4 1033/7/4 1035/7/4
f 1035/7/4 1033/7/4 1036/7/4
f 1037/5/4 1038/5/4 1039/5/4
f 1039/5/4 1038/5/4 1040/5/4
f 1041/5/4 1042/5/4 1043/5/4
f 1043/5/4 1042/5/4 1044/5/4
f 1045/5/4 1046/5/4 1047/5/4
f 1047/5/4 1046/5/4 1048/5/4
f 1049/5/4 1050/5/4 1051/5/4
f 1051/5/4 1050/5/4 1052/5/4
f 1053/5/4 1054/5/4 1055/5/4
f 1055/5/4 1054/5/4 1056/5/4
f 1061/2/5 1058/2/5 1057/2/5
f 1062/2/5 1058/2/5 1061/2/5
f 1063/2/5 1060/2/5 1059/2/5
f 1064/2/5 1060/2/5 1063/2/5
f 1069/2/5 1066/2/5 1065/2/5
f 1070/2/5 1066/2/5 1069/2/5
f 1071/2/5 1068/2/5 1067/2/5
f 1072/2/5 1068/2/5 1071/2/5
f 1077/2/5 1074/2/5 1073/2/5
f 1078/2/5 1074/2/5 1077/2/5
f 1079/2/5 1076/2/5 1075/2/5
f 1080/2/5 1076/2/5 1079/2/5
f 1085/2/5 1082/2/5 1081/2/5
f 1086/2/5 1082/2/5 1085/2/5
f 1087/2/5 1084/2/5 1083/2/5
f 1088/2/5 1084/2/5 1087/2/5
f 1093/2/5 1090/2/5 1089/2/5
f 1094/2/5 1090/2/5 1093/2/5
f 1095/2/5 1092/2/5 1091/2/5
f 1096/2/5 1092/2/5 1095/2/5
f 1101/2/5 1098/2/5 1097/2/5
f 1102/2/5 1098/2/5 1101/2/5
f 1103/2/5 1100/2/5 1099/2/5
f 1104/2/5 1100/2/5 1103/2/5
f 1108/5/5 1106/5/5 1105/5/5
f 1109/5/5 1106/5/5 1108/5/5
f 1112/5/5 1108/5/5 1107/5/5
f 1112/5/5 1110/5/5 1109/5/5
f 1112/5/5 1109/5/5 1108/5/5
f 1113/5/5 1110/5/5 1112/5/5
f 1116/5/5 1112/5/5 1111/5/5
f 1116/5/5 1114/5/5 1113/5/5
f 1116/5/5 1113/5/5 1112/5/5
f 1117/5/5 1114/5/5 1116/5/5
f 1120/8/5 1116/8/5 1115/8/5
f 1120/8/5 1118/8/5 1117/8/5
f 1120/8/5 1117/8/5 1116/8/5
f 1121/8/5 1118/8/5 1120/8/5
f 1124/8/5 1120/8/5 1119/8/5
f 1124/8/5 1122/8/5 1121/8/5
f 1124/8/5 1121/8/5 1120/8/5
f 1125/8/5 1122/8/5 1124/8/5
f 1126/8/5 1122/8/5 1125/8/5
f 1127/8/5 1122/8/5 1126/8/5
f 1129/8/5 1124/8/5 1123/8/5
f 1130/8/5 1126/8/5 1125/8/5
f 1131/8/5 1126/8/5 1130/8/5
f 1132/8/5 1128/8/5 1127/8/5
f 1133/8/5 1131/8/5 1130/8/5
f 1133/8/5 1132/8/5 1131/8/5
f 1133/8/5 1129/8/5 1123/8/5
f 1133/8/5 1130/8/5 1129/8/5
f 1134/8/5 1132/8/5 1133/8/5
f 1135/8/5 1132/8/5 1134/8/5
f 1136/8/5 1128/8/5 1132/8/5
f 1136/8/5 1132/8/5 1135/8/5
f 1137/8/5 1133/8/5 1123/8/5
f 1138/8/5 1133/8/5 1137/8/5
f 1139/8/5 1135/8/5 1134/8/5
f 1140/8/5 1135/8/5 1139/8/5
f 1141/8/5 1128/8/5 1136/8/5
f 1142/8/5 1128/8/5 1141/8/5
f 1143/8/5 1140/8/5 1139/8/5
f 1143/8/5 1141/8/5 1140/8/5
f 1143/8/5 1139/8/5 1138/8/5
f 1144/8/5 1141/8/5 1143/8/5
f 1145/8/5 1141/8/5 1144/8/5
f 1146/8/5 1141/8/5 1145/8/5
f 1147/8/5 1145/8/5 1144/8/5
f 1148/8/5 1145/8/5 1147/8/5
f 1149/8/5 1145/8/5 1148/8/5
f 1150/8/5 1145/8/5 1149/8/5
f 1151/5/5 1149/5/5 1148/5/5
f 1152/5/5 1149/5/5 1151/5/5
f 1153/5/5 1149/5/5 1152/5/5
f 1154/5/5 1149/5/5 1153/5/5
f 1155/5/5 1153/5/5 1152/5/5
f 1156/5/5 1153/5/5 1155/5/5
f 1157/5/5 1153/5/5 1156/5/5
f 1158/5/5 1153/5/5 1157/5/5
f 1159/5/5 1157/5/5 1156/5/5
f 1160/5/5 1157/5/5 1159/5/5
f 1166/7/5 1162/7/5 1161/7/5
f 1167/7/5 1162/7/5 1166/7/5
f 1168/7/5 1164/7/5 1163/7/5
f 1169/7/5 1164/7/5 1168/7/5
f 1171/7/5 1166/7/5 1165/7/5
f 1172/7/5 1166/7/5 1171/7/5
f 1173/7/5 1170/7/5 1169/7/5
f 1174/7/5 1170/7/5 1173/7/5
f 1179/7/5 1176/7/5 1175/7/5
f 1180/7/5 1176/7/5 1179/7/5
f 1183/7/5 1178/7/5 1177/7/5
f 1184/7/5 1178/7/5 1183/7/5
f 1185/7/5 1181/7/5 1180/7/5
f 1186/7/5 1181/7/5 1185/7/5
f 1187/7/5 1183/7/5 1182/7/5
f 1188/7/5 1183/7/5 1187/7/5
f 1193/7/5 1190/7/5 1189/7/5
f 1194/7/5 1190/7/5 1193/7/5
f 1197/7/5 1192/7/5 1191/7/5
f 1198/7/5 1192/7/5 1197/7/5
f 1199/7/5 1197/7/5 1196/7/5
f 1200/7/5 1195/7/5 1194/7/5
f 1201/7/5 1200/7/5 1194/7/5
f 1202/7/5 1200/7/5 1201/7/5
f 1203/7/5 1197/7/5 1199/7/5
f 1204/7/5 1197/7/5 1203/7/5
f 1209/7/5 1206/7/5 1205/7/5
f 1210/7/5 1208/7/5 1207/7/5
f 1211/7/5 1209/7/5 1205/7/5
f 1212/7/5 1209/7/5 1211/7/5
f 1213/7/5 1208/7/5 1210/7/5
f 1214/7/5 1208/7/5 1213/7/5
f 1219/7/5 1216/7/5 1215/7/5
f 1220/7/5 1218/7/5 1217/7/5
f 1221/7/5 1219/7/5 1215/7/5
f 1222/7/5 1219/7/5 1221/7/5
f 1223/7/5 1218/7/5 1220/7/5
f 1224/7/5 1218/7/5 1223/7/5
f 1229/7/5 1228/7/5 1227/7/5
f 1230/7/5 1226/7/5 1225/7/5
f 1232/7/5 1230/7/5 1225/7/5
f 1233/7/5 1230/7/5 1232/7/5
f 1234/7/5 1228/7/5 1229/7/5
f 1235/7/5 1228/7/5 1234/7/5
f 1237/7/5 1232/7/5 1231/7/5
f 1238/7/5 1232/7/5 1237/7/5
f 1239/7/5 1236/7/5 1235/7/5
f 1240/7/5 1236/7/5 1239/7/5
f 1245/7/5 1242/7/5 1241/7/5
f 1246/7/5 1242/7/5 1245/7/5
f 1247/7/5 1244/7/5 1243/7/5
f 1248/7/5 1244/7/5 1247/7/5
f 1249/5/6 1250/5/6 1252/5/6
f 1252/5/6 1250/5/6 1253/5/6
f 1251/5/6 1252/5/6 1256/5/6
f 1253/5/6 1254/5/6 1256/5/6
f 1252/5/6 1253/5/6 1256/5/6
f 1256/5/6 1254/5/6 1257/5/6
f 1255/5/6 1256/5/6 1259/5/6
f 1257/5/6 1258/5/6 1259/5/6
f 1256/5/6 1257/5/6 1259/5/6
f 1259/5/6 1258/5/6 1260/5/6
f 1261/5/6 1262/5/6 1263/5/6
f 1263/5/6 1262/5/6 1264/5/6
f 1264/5/6 1262/5/6 1265/5/6
f 1265/5/6 1262/5/6 1266/5/6
f 1264/5/6 1265/5/6 1267/5/6
f 1267/5/6 1265/5/6 1268/5/6
f 1268/5/6 1265/5/6 1269/5/6
f 1269/5/6 1265/5/6 1270/5/6
f 1268/5/6 1269/5/6 1271/5/6
f 1271/5/6 1269/5/6 1272/5/6
f 1273/6/6 1274/6/6 1277/6/6
f 1277/6/6 1274/6/6 1278/6/6
f 1275/6/6 1276/6/6 1279/6/6
f 1279/6/6 1276/6/6 1280/6/6
f 1281/7/6 1282/7/6 1285/7/6
f 1283/7/6 1284/7/6 1286/7/6
f 1281/7/6 1285/7/6 1287/7/6
f 1287/7/6 1285/7/6 1288/7/6
f 1286/7/6 1284/7/6 1289/7/6
f 1289/7/6 1284/7/6 1290/7/6
f 1291/7/6 1292/7/6 1295/7/6
f 1293/7/6 1294/7/6 1296/7/6
f 1291/7/6 1295/7/6 1297/7/6
f 1297/7/6 1295/7/6 1298/7/6
f 1296/7/6 1294/7/6 1299/7/6
f 1299/7/6 1294/7/6 1300/7/6
f 1301/7/6 1302/7/6 1305/7/6
f 1303/7/6 1304/7/6 1306/7/6
f 1301/7/6 1305/7/6 1307/7/6
f 1307/7/6 1305/7/6 1308/7/6
f 1306/7/6 1304/7/6 1309/7/6
f 1309/7/6 1304/7/6 1310/7/6
f 1311/7/6 1312/7/6 1315/7/6
f 1313/7/6 1314/7/6 1316/7/6
f 1311/7/6 1315/7/6 1317/7/6
f 1317/7/6 1315/7/6 1318/7/6
f 1316/7/6 1314/7/6 1319/7/6
f 1319/7/6 1314/7/6 1320/7/6
f 1321/7/6 1322/7/6 1326/7/6
f 1326/7/6 1322/7/6 1327/7/6
f 1323/7/6 1324/7/6 1328/7/6
f 1328/7/6 1324/7/6 1329/7/6
f 1325/7/6 1326/7/6 1331/7/6
f 1331/7/6 1326/7/6 1332/7/6
f 1329/7/6 1330/7/6 1333/7/6
f 1333/7/6 1330/7/6 1334/7/6
f 1335/7/6 1336/7/6 1339/7/6
f 1339/7/6 1336/7/6 1340/7/6
f 1337/7/6 1338/7/6 1343/7/6
f 1343/7/6 1338/7/6 1344/7/6
f 1340/7/6 1341/7/6 1345/7/6
f 1345/7/6 1341/7/6 1346/7/6
f 1342/7/6 1343/7/6 1347/7/6
f 1347/7/6 1343/7/6 1348/7/6
f 1349/7/6 1350/7/6 1354/7/6
f 1354/7/6 1350/7/6 1355/7/6
f 1351/7/6 1352/7/6 1356/7/6
f 1356/7/6 1352/7/6 1357/7/6
f 1353/7/6 1354/7/6 1360/7/6
f 1360/7/6 1354/7/6 1361/7/6
f 1357/7/6 1358/7/6 1362/7/6
f 1362/7/6 1358/7/6 1363/7/6
f 1359/7/6 1360/7/6 1365/7/6
f 1365/7/6 1360/7/6 1366/7/6
f 1363/7/6 1364/7/6 1367/7/6
f 1367/7/6 1364/7/6 1368/7/6
f 1369/7/6 1370/7/6 1373/7/6
f 1373/7/6 1370/7/6 1374/7/6
f 1371/7/6 1372/7/6 1375/7/6
f 1375/7/6 1372/7/6 1376/7/6
f 1377/7/6 1378/7/6 1381/7/6
f 1381/7/6 1378/7/6 1382/7/6
f 1379/7/6 1380/7/6 1385/7/6
f 1385/7/6 1380/7/6 1386/7/6
f 1382/7/6 1383/7/6 1387/7/6
f 1387/7/6 1383/7/6 1388/7/6
f 1384/7/6 1385/7/6 1391/7/6
f 1391/7/6 1385/7/6 1392/7/6
f 1388/7/6 1389/7/6 1393/7/6
f 1393/7/6 1389/7/6 1394/7/6
f 1390/7/6 1391/7/6 1395/7/6
f 1395/7/6 1391/7/6 1396/7/6
f 1397/7/6 1398/7/6 1400/7/6
f 1400/7/6 1398/7/6 1401/7/6
f 1399/7/6 1400/7/6 1404/7/6
f 1404/7/6 1400/7/6 1405/7/6
f 1401/7/6 1402/7/6 1406/7/6
f 1406/7/6 1402/7/6 1407/7/6
f 1403/7/6 1404/7/6 1410/7/6
f 1410/7/6 1404/7/6 1411/7/6
f 1407/7/6 1408/7/6 1412/7/6
f 1412/7/6 1408/7/6 1413/7/6
f 1409/7/6 1410/7/6 1415/7/6
f 1415/7/6 1410/7/6 1416/7/6
f 1413/7/6 1414/7/6 1419/7/6
f 1419/7/6 1414/7/6 1420/7/6
f 1416/7/6 1417/7/6 1422/7/6
f 1422/7/6 1417/7/6 1423/7/6
f 1418/7/6 1419/7/6 1424/7/6
f 1424/7/6 1419/7/6 1425/7/6
f 1421/7/6 1422/7/6 1427/7/6
f 1427/7/6 1422/7/6 1428/7/6
f 1425/7/6 1426/7/6 1431/7/6
f 1431/7/6 1426/7/6 1432/7/6
f 1428/7/6 1429/7/6 1433/7/6
f 1433/7/6 1429/7/6 1434/7/6
f 1430/7/6 1431/7/6 1437/7/6
f 1437/7/6 1431/7/6 1438/7/6
f 1434/7/6 1435/7/6 1439/7/6
f 1439/7/6 1435/7/6 1440/7/6
f 1436/7/6 1437/7/6 1441/7/6
f 1441/7/6 1437/7/6 1442/7/6
f 1440/7/6 1441/7/6 1443/7/6
f 1443/7/6 1441/7/6 1444/7/6
f 1445/7/6 1446/7/6 1450/7/6
f 1450/7/6 1446/7/6 1451/7/6
f 1451/7/6 1446/7/6 1452/7/6
f 1447/7/6 1448/7/6 1453/7/6
f 1453/7/6 1448/7/6 1454/7/6
f 1454/7/6 1448/7/6 1455/7/6
f 1449/7/6 1450/7/6 1458/7/6
f 1450/7/6 1451/7/6 1458/7/6
f 1458/7/6 1451/7/6 1459/7/6
f 1455/7/6 1456/7/6 1460/7/6
f 1454/7/6 1455/7/6 1460/7/6
f 1460/7/6 1456/7/6 1461/7/6
f 1457/7/6 1458/7/6 1463/7/6
f 1463/7/6 1458/7/6 1464/7/6
f 1461/7/6 1462/7/6 1467/7/6
f 1467/7/6 1462/7/6 1468/7/6
f 1464/7/6 1465/7/6 1470/7/6
f 1470/7/6 1465/7/6 1471/7/6
f 1466/7/6 1467/7/6 1472/7/6
f 1472/7/6 1467/7/6 1473/7/6
f 1469/7/6 1470/7/6 1475/7/6
f 1475/7/6 1470/7/6 1476/7/6
f 1473/7/6 1474/7/6 1479/7/6
f 1479/7/6 1474/7/6 1480/7/6
f 1476/7/6 1477/7/6 1481/7/6
f 1481/7/6 1477/7/6 1482/7/6
f 1482/7/6 1477/7/6 1483/7/6
f 1478/7/6 1479/7/6 1486/7/6
f 1486/7/6 1479/7/6 1487/7/6
f 1487/7/6 1479/7/6 1488/7/6
f 1483/7/6 1484/7/6 1489/7/6
f 1482/7/6 1483/7/6 1489/7/6
f 1489/7/6 1484/7/6 1490/7/6
f 1486/7/6 1487/7/6 1491/7/6
f 1485/7/6 1486/7/6 1491/7/6
f 1491/7/6 1487/7/6 1492/7/6
f 1493/7/6 1494/7/6 1496/7/6
f 1496/7/6 1494/7/6 1497/7/6
f 1495/7/6 1496/7/6 1500/7/6
f 1497/7/6 1498/7/6 1500/7/6
f 1496/7/6 1497/7/6 1500/7/6
f 1500/7/6 1498/7/6 1501/7/6
f 1499/7/6 1500/7/6 1503/7/6
f 1503/7/6 1500/7/6 1504/7/6
f 1501/7/6 1502/7/6 1509/7/6
f 1509/7/6 1502/7/6 1510/7/6
f 1504/7/6 1505/7/6 1512/7/6
f 1512/7/6 1505/7/6 1513/7/6
f 1506/7/6 1507/7/6 1514/7/6
f 1514/7/6 1507/7/6 1515/7/6
f 1508/7/6 1509/7/6 1516/7/6
f 1516/7/6 1509/7/6 1517/7/6
f 1511/7/6 1512/7/6 1519/7/6
f 1519/7/6 1512/7/6 1520/7/6
f 1517/7/6 1518/7/6 1521/7/6
f 1521/7/6 1518/7/6 1522/7/6
f 1520/7/6 1521/7/6 1523/7/6
f 1523/7/6 1521/7/6 1524/7/6
f 1524/7/6 1521/7/6 1525/7/6
f 1525/7/6 1521/7/6 1526/7/6
f 1524/7/6 1525/7/6 1527/7/6
f 1527/7/6 1525/7/6 1528/7/6
f 1529/7/6 1530/7/6 1531/7/6
f 1531/7/6 1530/7/6 1532/7/6
f 1532/7/6 1530/7/6 1533/7/6
f 1533/7/6 1530/7/6 1534/7/6
f 1534/7/6 1530/7/6 1535/7/6
f 1535/7/6 1530/7/6 1536/7/6
f 1532/6/6 1533/6/6 1538/6/6
f 1538/6/6 1533/6/6 1539/6/6
f 1534/6/6 1535/6/6 1540/6/6
f 1540/6/6 1535/6/6 1541/6/6
f 1538/7/6 1539/7/6 1543/7/6
f 1541/7/6 1542/7/6 1543/7/6
f 1540/7/6 1541/7/6 1543/7/6
f 1539/7/6 1540/7/6 1543/7/6
f 1537/7/6 1538/7/6 1543/7/6
f 1543/7/6 1542/7/6 1544/7/6
PNG

   IHDR         1Ypw  iCCPkCGColorSpaceGenericRGB  8U]hU>+$5lRem,lAi&3i)>A['!j-P(G	3k~s,[%,-:t}}-+*& gPG8"e ]A	b	;l  W2_E,(#Zs<5)"E6N#EkO0}*rUt.iei	# ]r
>cU{t7+gxu<D1_
u~R *-z#Mi*Wh6f}-gi:9fA,V>WB_-%=^t0uvW9%/VBW'_tMP\>@y0`D i|[`
hh) Tj0B#hU#~yhu	fp#1I/I"0! 'Sdd:J5"sdy#R7wAgdJ7kn^:}nWFVst$gj-tr__7Z~V54V
}o[G=Nd>-UlaY5V }xg[?k&>srq].r_r_qsGjy4k
iQBZ-<(d=dKO	a/zv7]od}sn?TF'|3Nn#I?"mzv~K=sl<b|_|4>?pQrib
2*(h {28oIyes8';Z9h6g >xRx'b8WO[xn% |^z} %xc   8eXIfMM *    i                              f   UIDAT8cg0Y 9g eQ@h@%p~{{@~D*|.a mQp    IENDB`# MagicaVoxel @ Ephtracy

newmtl palette
illum 1
Ka 0.000 0.000 0.000
Kd 1.000 1.000 1.000
Ks 0.000 0.000 0.000
map_Kd head.png
# MagicaVoxel @ Ephtracy

# group
o 

# material
mtllib head.mtl
usemtl palette

# normals
vn -1 0 0
vn 1 0 0
vn 0 0 1
vn 0 0 -1
vn 0 -1 0
vn 0 1 0

# texcoords
vt 0.0136719 0.5
vt 0.0214844 0.5
vt 0.845703 0.5
vt 0.853516 0.5
vt 0.876953 0.5
vt 0.958984 0.5
vt 0.966797 0.5
vt 0.978516 0.5
vt 0.982422 0.5
vt 0.986328 0.5
vt 0.994141 0.5

# verts
v -0.7 0.5 1.5
v -0.7 0.5 -1.2
v -0.7 0.6 1.6
v -0.7 0.6 1.5
v -0.7 0.6 -1.2
v -0.7 0.6 -1.3
v -0.7 0.7 1.4
v -0.7 0.7 -1.1
v -0.7 0.8 1.4
v -0.7 0.8 -1.1
v -0.7 0.9 1.7
v -0.7 0.9 1.6
v -0.7 0.9 1.4
v -0.7 0.9 -1.1
v -0.7 1 1.4
v -0.7 1 -1.1
v -0.7 2 1.4
v -0.7 2 1.3
v -0.7 2 -1
v -0.7 2 -1.1
v -0.7 2.1 1.7
v -0.7 2.1 1.6
v -0.7 2.1 1.3
v -0.7 2.1 -1
v -0.7 2.2 1.6
v -0.7 2.2 1.5
v -0.7 2.2 -1.2
v -0.7 2.2 -1.3
v -0.7 2.3 1.5
v -0.7 2.3 1.3
v -0.7 2.3 1.1
v -0.7 2.3 -0.8
v -0.7 2.3 -1
v -0.7 2.3 -1.2
v -0.7 2.4 1.3
v -0.7 2.4 1.1
v -0.7 2.4 -0.8
v -0.7 2.4 -1
v -0.6 0.2 1.4
v -0.6 0.2 1.1
v -0.6 0.2 -0.8
v -0.6 0.2 -1.1
v -0.6 0.3 1.3
v -0.6 0.3 1.2
v -0.6 0.3 -0.9
v -0.6 0.3 -1
v -0.6 0.4 1.5
v -0.6 0.4 1.4
v -0.6 0.4 1.3
v -0.6 0.4 1.2
v -0.6 0.4 1.1
v -0.6 0.4 1
v -0.6 0.4 -0.7
v -0.6 0.4 -0.8
v -0.6 0.4 -0.9
v -0.6 0.4 -1
v -0.6 0.4 -1.1
v -0.6 0.4 -1.2
v -0.6 0.5 1.6
v -0.6 0.5 1.5
v -0.6 0.5 1
v -0.6 0.5 -0.7
v -0.6 0.5 -1.2
v -0.6 0.5 -1.3
v -0.6 0.6 1.7
v -0.6 0.6 1.6
v -0.6 0.6 1.5
v -0.6 0.6 -1.2
v -0.6 0.6 -1.3
v -0.6 0.6 -1.4
v -0.6 0.8 1.8
v -0.6 0.8 1.7
v -0.6 0.8 1.6
v -0.6 0.9 1.7
v -0.6 0.9 1.6
v -0.6 1 1.4
v -0.6 1 -1.1
v -0.6 1.1 1.3
v -0.6 1.1 0.7
v -0.6 1.1 0.5
v -0.6 1.1 0.2
v -0.6 1.1 0.0999999
v -0.6 1.1 -0.2
v -0.6 1.1 -0.4
v -0.6 1.1 -1
v -0.6 2 1.4
v -0.6 2 1.3
v -0.6 2 0.7
v -0.6 2 0.5
v -0.6 2 0.2
v -0.6 2 0.0999999
v -0.6 2 -0.2
v -0.6 2 -0.4
v -0.6 2 -1
v -0.6 2 -1.1
v -0.6 2.1 1.7
v -0.6 2.1 1.6
v -0.6 2.1 1.3
v -0.6 2.1 -1
v -0.6 2.2 1.8
v -0.6 2.2 1.6
v -0.6 2.2 1.5
v -0.6 2.2 -1.2
v -0.6 2.2 -1.3
v -0.6 2.2 -1.4
v -0.6 2.3 1.6
v -0.6 2.3 1.5
v -0.6 2.3 1.3
v -0.6 2.3 1.1
v -0.6 2.3 -0.8
v -0.6 2.3 -1
v -0.6 2.3 -1.2
v -0.6 2.3 -1.3
v -0.6 2.4 1.5
v -0.6 2.4 1.3
v -0.6 2.4 1.1
v -0.6 2.4 -0.8
v -0.6 2.4 -1
v -0.6 2.4 -1.2
v -0.6 2.5 1.3
v -0.6 2.5 1.1
v -0.6 2.5 -0.8
v -0.6 2.5 -1
v -0.5 0.5 1.7
v -0.5 0.5 1.6
v -0.5 0.5 -1.3
v -0.5 0.5 -1.4
v -0.5 0.6 1.7
v -0.5 0.6 1.6
v -0.5 0.6 -1.3
v -0.5 0.6 -1.4
v -0.5 0.7 1.8
v -0.5 0.7 1.7
v -0.5 0.8 1.8
v -0.5 0.8 1.7
v -0.5 1.1 1.3
v -0.5 1.1 1.2
v -0.5 1.1 0.7
v -0.5 1.1 0.5
v -0.5 1.1 0.3
v -0.5 1.1 0.2
v -0.5 1.1 0.0999999
v -0.5 1.1 0
v -0.5 1.1 -0.2
v -0.5 1.1 -0.4
v -0.5 1.1 -0.5
v -0.5 1.1 -1
v -0.5 1.2 1.3
v -0.5 1.2 1.2
v -0.5 1.2 1.1
v -0.5 1.3 -0.4
v -0.5 1.3 -0.5
v -0.5 1.3 -0.6
v -0.5 1.4 1.2
v -0.5 1.4 1.1
v -0.5 1.4 1
v -0.5 1.4 -0.5
v -0.5 1.4 -0.6
v -0.5 1.4 -0.7
v -0.5 1.5 1.1
v -0.5 1.5 1
v -0.5 1.5 0.9
v -0.5 1.6 -0.6
v -0.5 1.6 -0.7
v -0.5 1.6 -0.8
v -0.5 1.7 1
v -0.5 1.7 0.9
v -0.5 1.7 0.8
v -0.5 1.7 -0.7
v -0.5 1.7 -0.8
v -0.5 1.7 -0.9
v -0.5 1.8 0.9
v -0.5 1.8 0.8
v -0.5 1.8 0.7
v -0.5 1.9 -0.8
v -0.5 1.9 -0.9
v -0.5 1.9 -1
v -0.5 2 1.3
v -0.5 2 0.8
v -0.5 2 0.7
v -0.5 2 0.5
v -0.5 2 0.3
v -0.5 2 0.2
v -0.5 2 0.0999999
v -0.5 2 0
v -0.5 2 -0.2
v -0.5 2 -0.4
v -0.5 2 -0.9
v -0.5 2 -1
v -0.5 2.2 1.8
v -0.5 2.2 1.6
v -0.5 2.2 -1.3
v -0.5 2.2 -1.4
v -0.5 2.3 1.8
v -0.5 2.3 1.6
v -0.5 2.3 1.5
v -0.5 2.3 -1.2
v -0.5 2.3 -1.3
v -0.5 2.3 -1.4
v -0.5 2.4 1.6
v -0.5 2.4 1.5
v -0.5 2.4 1.3
v -0.5 2.4 1.1
v -0.5 2.4 -0.8
v -0.5 2.4 -1
v -0.5 2.4 -1.2
v -0.5 2.4 -1.3
v -0.5 2.5 1.5
v -0.5 2.5 1.3
v -0.5 2.5 1.1
v -0.5 2.5 -0.8
v -0.5 2.5 -1
v -0.5 2.5 -1.2
v -0.5 2.6 1.3
v -0.5 2.6 1.1
v -0.5 2.6 -0.8
v -0.5 2.6 -1
v -0.4 2.3 1.7
v -0.4 2.3 1.6
v -0.4 2.3 -1.3
v -0.4 2.3 -1.4
v -0.4 2.4 1.7
v -0.4 2.4 1.6
v -0.4 2.4 1.5
v -0.4 2.4 -1.2
v -0.4 2.4 -1.3
v -0.4 2.4 -1.4
v -0.4 2.5 1.6
v -0.4 2.5 1.5
v -0.4 2.5 -1.2
v -0.4 2.5 -1.3
v -0.3 2.5 1.5
v -0.3 2.5 1.3
v -0.3 2.5 1.1
v -0.3 2.5 -0.8
v -0.3 2.5 -1
v -0.3 2.5 -1.2
v -0.3 2.6 1.5
v -0.3 2.6 1.3
v -0.3 2.6 1.1
v -0.3 2.6 -0.8
v -0.3 2.6 -1
v -0.3 2.6 -1.2
v -0.3 2.7 1.3
v -0.3 2.7 1.1
v -0.3 2.7 -0.8
v -0.3 2.7 -1
v -0.2 0.5 -1.4
v -0.2 0.5 -1.5
v -0.2 0.6 -1.4
v -0.2 0.6 -1.5
v -0.2 2.5 1.6
v -0.2 2.5 1.5
v -0.2 2.5 -1.2
v -0.2 2.5 -1.3
v -0.2 2.6 1.6
v -0.2 2.6 1.5
v -0.2 2.6 -1.2
v -0.2 2.6 -1.3
v -0.1 0.5 -1.5
v -0.1 0.5 -1.6
v -0.1 0.6 -1.5
v -0.1 0.6 -1.6
v -0.1 2.6 1.1
v -0.1 2.6 -0.8
v -0.1 2.7 1.1
v -0.1 2.7 -0.8
v 5.96046e-08 0.5 -1.6
v 5.96046e-08 0.5 -1.7
v 5.96046e-08 0.6 -1.6
v 5.96046e-08 0.6 -1.7
v 5.96046e-08 1.5 1.8
v 5.96046e-08 1.5 1.7
v 5.96046e-08 2.1 1.8
v 5.96046e-08 2.1 1.7
v 0.1 2.6 1.1
v 0.1 2.6 -0.8
v 0.1 2.7 1.1
v 0.1 2.7 -0.8
v 0.4 0.2 1.4
v 0.4 0.2 1.1
v 0.4 0.2 -0.8
v 0.4 0.2 -1.1
v 0.4 0.4 1.5
v 0.4 0.4 1.4
v 0.4 0.4 1.1
v 0.4 0.4 1
v 0.4 0.4 -0.7
v 0.4 0.4 -0.8
v 0.4 0.4 -1.1
v 0.4 0.4 -1.2
v 0.4 0.5 1.5
v 0.4 0.5 1
v 0.4 0.5 -0.7
v 0.4 0.5 -1.2
v 0.5 1.5 1.8
v 0.5 1.5 1.7
v 0.5 2.1 1.8
v 0.5 2.1 1.7
v -0.4 1.5 1.8
v -0.4 1.5 1.7
v -0.4 2.1 1.8
v -0.4 2.1 1.7
v -0.3 0.2 1.4
v -0.3 0.2 1.1
v -0.3 0.2 -0.8
v -0.3 0.2 -1.1
v -0.3 0.4 1.5
v -0.3 0.4 1.4
v -0.3 0.4 1.1
v -0.3 0.4 1
v -0.3 0.4 -0.7
v -0.3 0.4 -0.8
v -0.3 0.4 -1.1
v -0.3 0.4 -1.2
v -0.3 0.5 1.5
v -0.3 0.5 1
v -0.3 0.5 -0.7
v -0.3 0.5 -1.2
v 5.96046e-08 2.6 1.1
v 5.96046e-08 2.6 -0.8
v 5.96046e-08 2.7 1.1
v 5.96046e-08 2.7 -0.8
v 0.1 0.5 -1.6
v 0.1 0.5 -1.7
v 0.1 0.6 -1.6
v 0.1 0.6 -1.7
v 0.1 1.5 1.8
v 0.1 1.5 1.7
v 0.1 2.1 1.8
v 0.1 2.1 1.7
v 0.2 0.5 -1.5
v 0.2 0.5 -1.6
v 0.2 0.6 -1.5
v 0.2 0.6 -1.6
v 0.2 2.6 1.1
v 0.2 2.6 -0.8
v 0.2 2.7 1.1
v 0.2 2.7 -0.8
v 0.3 0.5 -1.4
v 0.3 0.5 -1.5
v 0.3 0.6 -1.4
v 0.3 0.6 -1.5
v 0.3 2.5 1.6
v 0.3 2.5 1.5
v 0.3 2.5 -1.2
v 0.3 2.5 -1.3
v 0.3 2.6 1.6
v 0.3 2.6 1.5
v 0.3 2.6 -1.2
v 0.3 2.6 -1.3
v 0.4 2.5 1.5
v 0.4 2.5 1.3
v 0.4 2.5 1.1
v 0.4 2.5 -0.8
v 0.4 2.5 -1
v 0.4 2.5 -1.2
v 0.4 2.6 1.5
v 0.4 2.6 1.3
v 0.4 2.6 1.1
v 0.4 2.6 -0.8
v 0.4 2.6 -1
v 0.4 2.6 -1.2
v 0.4 2.7 1.3
v 0.4 2.7 1.1
v 0.4 2.7 -0.8
v 0.4 2.7 -1
v 0.5 2.3 1.7
v 0.5 2.3 1.6
v 0.5 2.3 -1.3
v 0.5 2.3 -1.4
v 0.5 2.4 1.7
v 0.5 2.4 1.6
v 0.5 2.4 1.5
v 0.5 2.4 -1.2
v 0.5 2.4 -1.3
v 0.5 2.4 -1.4
v 0.5 2.5 1.6
v 0.5 2.5 1.5
v 0.5 2.5 -1.2
v 0.5 2.5 -1.3
v 0.6 0.5 1.7
v 0.6 0.5 1.6
v 0.6 0.5 -1.3
v 0.6 0.5 -1.4
v 0.6 0.6 1.7
v 0.6 0.6 1.6
v 0.6 0.6 -1.3
v 0.6 0.6 -1.4
v 0.6 0.7 1.8
v 0.6 0.7 1.7
v 0.6 0.8 1.8
v 0.6 0.8 1.7
v 0.6 1.1 1.3
v 0.6 1.1 0.8
v 0.6 1.1 0.7
v 0.6 1.1 0.5
v 0.6 1.1 0.3
v 0.6 1.1 0.2
v 0.6 1.1 0.0999999
v 0.6 1.1 0
v 0.6 1.1 -0.2
v 0.6 1.1 -0.4
v 0.6 1.1 -0.9
v 0.6 1.1 -1
v 0.6 1.2 0.9
v 0.6 1.2 0.8
v 0.6 1.2 0.7
v 0.6 1.3 -0.8
v 0.6 1.3 -0.9
v 0.6 1.3 -1
v 0.6 1.4 1
v 0.6 1.4 0.9
v 0.6 1.4 0.8
v 0.6 1.4 -0.7
v 0.6 1.4 -0.8
v 0.6 1.4 -0.9
v 0.6 1.5 1.1
v 0.6 1.5 1
v 0.6 1.5 0.9
v 0.6 1.6 -0.6
v 0.6 1.6 -0.7
v 0.6 1.6 -0.8
v 0.6 1.7 1.2
v 0.6 1.7 1.1
v 0.6 1.7 1
v 0.6 1.7 -0.5
v 0.6 1.7 -0.6
v 0.6 1.7 -0.7
v 0.6 1.8 1.3
v 0.6 1.8 1.2
v 0.6 1.8 1.1
v 0.6 1.9 -0.4
v 0.6 1.9 -0.5
v 0.6 1.9 -0.6
v 0.6 2 1.3
v 0.6 2 1.2
v 0.6 2 0.7
v 0.6 2 0.5
v 0.6 2 0.3
v 0.6 2 0.2
v 0.6 2 0.0999999
v 0.6 2 0
v 0.6 2 -0.2
v 0.6 2 -0.4
v 0.6 2 -0.5
v 0.6 2 -1
v 0.6 2.2 1.8
v 0.6 2.2 1.6
v 0.6 2.2 -1.3
v 0.6 2.2 -1.4
v 0.6 2.3 1.8
v 0.6 2.3 1.6
v 0.6 2.3 1.5
v 0.6 2.3 -1.2
v 0.6 2.3 -1.3
v 0.6 2.3 -1.4
v 0.6 2.4 1.6
v 0.6 2.4 1.5
v 0.6 2.4 1.3
v 0.6 2.4 1.1
v 0.6 2.4 -0.8
v 0.6 2.4 -1
v 0.6 2.4 -1.2
v 0.6 2.4 -1.3
v 0.6 2.5 1.5
v 0.6 2.5 1.3
v 0.6 2.5 1.1
v 0.6 2.5 -0.8
v 0.6 2.5 -1
v 0.6 2.5 -1.2
v 0.6 2.6 1.3
v 0.6 2.6 1.1
v 0.6 2.6 -0.8
v 0.6 2.6 -1
v 0.7 0.2 1.4
v 0.7 0.2 1.1
v 0.7 0.2 -0.8
v 0.7 0.2 -1.1
v 0.7 0.3 1.3
v 0.7 0.3 1.2
v 0.7 0.3 -0.9
v 0.7 0.3 -1
v 0.7 0.4 1.5
v 0.7 0.4 1.4
v 0.7 0.4 1.3
v 0.7 0.4 1.2
v 0.7 0.4 1.1
v 0.7 0.4 1
v 0.7 0.4 -0.7
v 0.7 0.4 -0.8
v 0.7 0.4 -0.9
v 0.7 0.4 -1
v 0.7 0.4 -1.1
v 0.7 0.4 -1.2
v 0.7 0.5 1.6
v 0.7 0.5 1.5
v 0.7 0.5 1
v 0.7 0.5 -0.7
v 0.7 0.5 -1.2
v 0.7 0.5 -1.3
v 0.7 0.6 1.7
v 0.7 0.6 1.6
v 0.7 0.6 1.5
v 0.7 0.6 -1.2
v 0.7 0.6 -1.3
v 0.7 0.6 -1.4
v 0.7 0.8 1.8
v 0.7 0.8 1.7
v 0.7 0.8 1.6
v 0.7 0.9 1.7
v 0.7 0.9 1.6
v 0.7 1 1.4
v 0.7 1 -1.1
v 0.7 1.1 1.3
v 0.7 1.1 0.7
v 0.7 1.1 0.5
v 0.7 1.1 0.2
v 0.7 1.1 0.0999999
v 0.7 1.1 -0.2
v 0.7 1.1 -0.4
v 0.7 1.1 -1
v 0.7 2 1.4
v 0.7 2 1.3
v 0.7 2 0.7
v 0.7 2 0.5
v 0.7 2 0.2
v 0.7 2 0.0999999
v 0.7 2 -0.2
v 0.7 2 -0.4
v 0.7 2 -1
v 0.7 2 -1.1
v 0.7 2.1 1.7
v 0.7 2.1 1.6
v 0.7 2.1 1.3
v 0.7 2.1 -1
v 0.7 2.2 1.8
v 0.7 2.2 1.6
v 0.7 2.2 1.5
v 0.7 2.2 -1.2
v 0.7 2.2 -1.3
v 0.7 2.2 -1.4
v 0.7 2.3 1.6
v 0.7 2.3 1.5
v 0.7 2.3 1.3
v 0.7 2.3 1.1
v 0.7 2.3 -0.8
v 0.7 2.3 -1
v 0.7 2.3 -1.2
v 0.7 2.3 -1.3
v 0.7 2.4 1.5
v 0.7 2.4 1.3
v 0.7 2.4 1.1
v 0.7 2.4 -0.8
v 0.7 2.4 -1
v 0.7 2.4 -1.2
v 0.7 2.5 1.3
v 0.7 2.5 1.1
v 0.7 2.5 -0.8
v 0.7 2.5 -1
v 0.8 0.5 1.5
v 0.8 0.5 -1.2
v 0.8 0.6 1.6
v 0.8 0.6 1.5
v 0.8 0.6 -1.2
v 0.8 0.6 -1.3
v 0.8 0.7 1.4
v 0.8 0.7 -1.1
v 0.8 0.8 1.4
v 0.8 0.8 -1.1
v 0.8 0.9 1.7
v 0.8 0.9 1.6
v 0.8 0.9 1.4
v 0.8 0.9 -1.1
v 0.8 1 1.4
v 0.8 1 -1.1
v 0.8 2 1.4
v 0.8 2 1.3
v 0.8 2 -1
v 0.8 2 -1.1
v 0.8 2.1 1.7
v 0.8 2.1 1.6
v 0.8 2.1 1.3
v 0.8 2.1 -1
v 0.8 2.2 1.6
v 0.8 2.2 1.5
v 0.8 2.2 -1.2
v 0.8 2.2 -1.3
v 0.8 2.3 1.5
v 0.8 2.3 1.3
v 0.8 2.3 1.1
v 0.8 2.3 -0.8
v 0.8 2.3 -1
v 0.8 2.3 -1.2
v 0.8 2.4 1.3
v 0.8 2.4 1.1
v 0.8 2.4 -0.8
v 0.8 2.4 -1
v -0.6 0.8 1.8
v -0.6 2.2 1.8
v -0.5 0.7 1.8
v -0.5 0.8 1.8
v -0.5 1 1.8
v -0.5 1.3 1.8
v -0.5 1.4 1.8
v -0.5 2.2 1.8
v -0.5 2.3 1.8
v -0.4 1.1 1.8
v -0.4 1.2 1.8
v -0.4 1.5 1.8
v -0.4 2.1 1.8
v -0.3 0.8 1.8
v -0.3 0.9 1.8
v -0.3 1.1 1.8
v -0.3 1.2 1.8
v -0.2 1 1.8
v -0.2 1.3 1.8
v -0.1 1 1.8
v -0.1 1.1 1.8
v -0.1 1.2 1.8
v -0.1 1.3 1.8
v 5.96046e-08 1.5 1.8
v 5.96046e-08 2.1 1.8
v 0.1 1.5 1.8
v 0.1 2.1 1.8
v 0.2 1 1.8
v 0.2 1.1 1.8
v 0.2 1.2 1.8
v 0.2 1.3 1.8
v 0.3 1 1.8
v 0.3 1.3 1.8
v 0.4 0.8 1.8
v 0.4 0.9 1.8
v 0.4 1.1 1.8
v 0.4 1.2 1.8
v 0.5 1.1 1.8
v 0.5 1.2 1.8
v 0.5 1.5 1.8
v 0.5 2.1 1.8
v 0.6 0.7 1.8
v 0.6 0.8 1.8
v 0.6 1 1.8
v 0.6 1.3 1.8
v 0.6 1.4 1.8
v 0.6 2.2 1.8
v 0.6 2.3 1.8
v 0.7 0.8 1.8
v 0.7 2.2 1.8
v -0.7 0.9 1.7
v -0.7 2.1 1.7
v -0.6 0.6 1.7
v -0.6 0.8 1.7
v -0.6 0.9 1.7
v -0.6 2.1 1.7
v -0.5 0.5 1.7
v -0.5 0.6 1.7
v -0.5 0.7 1.7
v -0.5 0.8 1.7
v -0.4 1.5 1.7
v -0.4 2.1 1.7
v -0.4 2.3 1.7
v -0.4 2.4 1.7
v -0.1 0.6 1.7
v -0.1 0.7 1.7
v -0.1 1.5 1.7
v -0.1 2.1 1.7
v 5.96046e-08 1.5 1.7
v 5.96046e-08 2.1 1.7
v 0.1 1.5 1.7
v 0.1 2.1 1.7
v 0.2 0.6 1.7
v 0.2 0.7 1.7
v 0.2 1.5 1.7
v 0.2 2.1 1.7
v 0.5 1.5 1.7
v 0.5 2.1 1.7
v 0.5 2.3 1.7
v 0.5 2.4 1.7
v 0.6 0.5 1.7
v 0.6 0.6 1.7
v 0.6 0.7 1.7
v 0.6 0.8 1.7
v 0.7 0.6 1.7
v 0.7 0.8 1.7
v 0.7 0.9 1.7
v 0.7 2.1 1.7
v 0.8 0.9 1.7
v 0.8 2.1 1.7
v -0.7 0.6 1.6
v -0.7 0.9 1.6
v -0.7 2.1 1.6
v -0.7 2.2 1.6
v -0.6 0.5 1.6
v -0.6 0.6 1.6
v -0.6 0.8 1.6
v -0.6 0.9 1.6
v -0.6 2.1 1.6
v -0.6 2.2 1.6
v -0.6 2.3 1.6
v -0.5 0.5 1.6
v -0.5 0.6 1.6
v -0.5 2.2 1.6
v -0.5 2.3 1.6
v -0.5 2.4 1.6
v -0.4 2.3 1.6
v -0.4 2.4 1.6
v -0.4 2.5 1.6
v -0.2 2.5 1.6
v -0.2 2.6 1.6
v 0.3 2.5 1.6
v 0.3 2.6 1.6
v 0.5 2.3 1.6
v 0.5 2.4 1.6
v 0.5 2.5 1.6
v 0.6 0.5 1.6
v 0.6 0.6 1.6
v 0.6 2.2 1.6
v 0.6 2.3 1.6
v 0.6 2.4 1.6
v 0.7 0.5 1.6
v 0.7 0.6 1.6
v 0.7 0.8 1.6
v 0.7 0.9 1.6
v 0.7 2.1 1.6
v 0.7 2.2 1.6
v 0.7 2.3 1.6
v 0.8 0.6 1.6
v 0.8 0.9 1.6
v 0.8 2.1 1.6
v 0.8 2.2 1.6
v -0.7 0.5 1.5
v -0.7 0.6 1.5
v -0.7 2.2 1.5
v -0.7 2.3 1.5
v -0.6 0.4 1.5
v -0.6 0.5 1.5
v -0.6 0.6 1.5
v -0.6 2.2 1.5
v -0.6 2.3 1.5
v -0.6 2.4 1.5
v -0.5 2.3 1.5
v -0.5 2.4 1.5
v -0.5 2.5 1.5
v -0.4 2.4 1.5
v -0.4 2.5 1.5
v -0.3 0.4 1.5
v -0.3 0.5 1.5
v -0.3 2.5 1.5
v -0.3 2.6 1.5
v -0.2 2.5 1.5
v -0.2 2.6 1.5
v 0.3 2.5 1.5
v 0.3 2.6 1.5
v 0.4 0.4 1.5
v 0.4 0.5 1.5
v 0.4 2.5 1.5
v 0.4 2.6 1.5
v 0.5 2.4 1.5
v 0.5 2.5 1.5
v 0.6 2.3 1.5
v 0.6 2.4 1.5
v 0.6 2.5 1.5
v 0.7 0.4 1.5
v 0.7 0.5 1.5
v 0.7 0.6 1.5
v 0.7 2.2 1.5
v 0.7 2.3 1.5
v 0.7 2.4 1.5
v 0.8 0.5 1.5
v 0.8 0.6 1.5
v 0.8 2.2 1.5
v 0.8 2.3 1.5
v -0.6 0.2 1.4
v -0.6 0.4 1.4
v -0.3 0.2 1.4
v -0.3 0.4 1.4
v 0.4 0.2 1.4
v 0.4 0.4 1.4
v 0.7 0.2 1.4
v 0.7 0.4 1.4
v -0.7 2.3 1.3
v -0.7 2.4 1.3
v -0.6 2.3 1.3
v -0.6 2.4 1.3
v -0.6 2.5 1.3
v -0.5 2.4 1.3
v -0.5 2.5 1.3
v -0.5 2.6 1.3
v -0.3 2.5 1.3
v -0.3 2.6 1.3
v -0.3 2.7 1.3
v 0.4 2.5 1.3
v 0.4 2.6 1.3
v 0.4 2.7 1.3
v 0.6 2.4 1.3
v 0.6 2.5 1.3
v 0.6 2.6 1.3
v 0.7 2.3 1.3
v 0.7 2.4 1.3
v 0.7 2.5 1.3
v 0.8 2.3 1.3
v 0.8 2.4 1.3
v -0.6 1.1 0.7
v -0.6 2 0.7
v -0.5 1.1 0.7
v -0.5 1.8 0.7
v -0.5 2 0.7
v 0.6 1.1 0.7
v 0.6 1.2 0.7
v 0.6 2 0.7
v 0.7 1.1 0.7
v 0.7 2 0.7
v -0.6 1.1 0.2
v -0.6 2 0.2
v -0.5 1.1 0.2
v -0.5 2 0.2
v 0.6 1.1 0.2
v 0.6 2 0.2
v 0.7 1.1 0.2
v 0.7 2 0.2
v -0.6 1.1 -0.2
v -0.6 2 -0.2
v -0.5 1.1 -0.2
v -0.5 2 -0.2
v 0.6 1.1 -0.2
v 0.6 2 -0.2
v 0.7 1.1 -0.2
v 0.7 2 -0.2
v -0.6 0.4 -0.7
v -0.6 0.5 -0.7
v -0.3 0.4 -0.7
v -0.3 0.5 -0.7
v 0.4 0.4 -0.7
v 0.4 0.5 -0.7
v 0.7 0.4 -0.7
v 0.7 0.5 -0.7
v -0.7 2.3 -0.8
v -0.7 2.4 -0.8
v -0.6 0.2 -0.8
v -0.6 0.4 -0.8
v -0.6 2.3 -0.8
v -0.6 2.4 -0.8
v -0.6 2.5 -0.8
v -0.5 2.4 -0.8
v -0.5 2.5 -0.8
v -0.5 2.6 -0.8
v -0.3 0.2 -0.8
v -0.3 0.4 -0.8
v -0.3 2.5 -0.8
v -0.3 2.6 -0.8
v -0.3 2.7 -0.8
v -0.1 2.6 -0.8
v -0.1 2.7 -0.8
v 5.96046e-08 2.6 -0.8
v 5.96046e-08 2.7 -0.8
v 0.1 2.6 -0.8
v 0.1 2.7 -0.8
v 0.2 2.6 -0.8
v 0.2 2.7 -0.8
v 0.4 0.2 -0.8
v 0.4 0.4 -0.8
v 0.4 2.5 -0.8
v 0.4 2.6 -0.8
v 0.4 2.7 -0.8
v 0.6 2.4 -0.8
v 0.6 2.5 -0.8
v 0.6 2.6 -0.8
v 0.7 0.2 -0.8
v 0.7 0.4 -0.8
v 0.7 2.3 -0.8
v 0.7 2.4 -0.8
v 0.7 2.5 -0.8
v 0.8 2.3 -0.8
v 0.8 2.4 -0.8
v -0.7 2 -1
v -0.7 2.1 -1
v -0.6 1.1 -1
v -0.6 2 -1
v -0.6 2.1 -1
v -0.5 1.1 -1
v -0.5 1.9 -1
v -0.5 2 -1
v 0.6 1.1 -1
v 0.6 1.3 -1
v 0.6 2 -1
v 0.7 1.1 -1
v 0.7 2 -1
v 0.7 2.1 -1
v 0.8 2 -1
v 0.8 2.1 -1
v -0.7 1 -1.1
v -0.7 2 -1.1
v -0.6 1 -1.1
v -0.6 2 -1.1
v 0.7 1 -1.1
v 0.7 2 -1.1
v 0.8 1 -1.1
v 0.8 2 -1.1
v -0.7 1 1.4
v -0.7 2 1.4
v -0.6 1 1.4
v -0.6 2 1.4
v 0.7 1 1.4
v 0.7 2 1.4
v 0.8 1 1.4
v 0.8 2 1.4
v -0.7 2 1.3
v -0.7 2.1 1.3
v -0.6 1.1 1.3
v -0.6 2 1.3
v -0.6 2.1 1.3
v -0.5 1.1 1.3
v -0.5 1.2 1.3
v -0.5 2 1.3
v 0.6 1.1 1.3
v 0.6 1.8 1.3
v 0.6 2 1.3
v 0.7 1.1 1.3
v 0.7 2 1.3
v 0.7 2.1 1.3
v 0.8 2 1.3
v 0.8 2.1 1.3
v -0.7 2.3 1.1
v -0.7 2.4 1.1
v -0.6 0.2 1.1
v -0.6 0.4 1.1
v -0.6 2.3 1.1
v -0.6 2.4 1.1
v -0.6 2.5 1.1
v -0.5 2.4 1.1
v -0.5 2.5 1.1
v -0.5 2.6 1.1
v -0.3 0.2 1.1
v -0.3 0.4 1.1
v -0.3 2.5 1.1
v -0.3 2.6 1.1
v -0.3 2.7 1.1
v -0.1 2.6 1.1
v -0.1 2.7 1.1
v 5.96046e-08 2.6 1.1
v 5.96046e-08 2.7 1.1
v 0.1 2.6 1.1
v 0.1 2.7 1.1
v 0.2 2.6 1.1
v 0.2 2.7 1.1
v 0.4 0.2 1.1
v 0.4 0.4 1.1
v 0.4 2.5 1.1
v 0.4 2.6 1.1
v 0.4 2.7 1.1
v 0.6 2.4 1.1
v 0.6 2.5 1.1
v 0.6 2.6 1.1
v 0.7 0.2 1.1
v 0.7 0.4 1.1
v 0.7 2.3 1.1
v 0.7 2.4 1.1
v 0.7 2.5 1.1
v 0.8 2.3 1.1
v 0.8 2.4 1.1
v -0.6 0.4 1
v -0.6 0.5 1
v -0.3 0.4 1
v -0.3 0.5 1
v 0.4 0.4 1
v 0.4 0.5 1
v 0.7 0.4 1
v 0.7 0.5 1
v -0.6 1.1 0.5
v -0.6 2 0.5
v -0.5 1.1 0.5
v -0.5 2 0.5
v 0.6 1.1 0.5
v 0.6 2 0.5
v 0.7 1.1 0.5
v 0.7 2 0.5
v -0.6 1.1 0.0999999
v -0.6 2 0.0999999
v -0.5 1.1 0.0999999
v -0.5 2 0.0999999
v 0.6 1.1 0.0999999
v 0.6 2 0.0999999
v 0.7 1.1 0.0999999
v 0.7 2 0.0999999
v -0.6 1.1 -0.4
v -0.6 2 -0.4
v -0.5 1.1 -0.4
v -0.5 1.3 -0.4
v -0.5 2 -0.4
v 0.6 1.1 -0.4
v 0.6 1.9 -0.4
v 0.6 2 -0.4
v 0.7 1.1 -0.4
v 0.7 2 -0.4
v -0.7 2.3 -1
v -0.7 2.4 -1
v -0.6 2.3 -1
v -0.6 2.4 -1
v -0.6 2.5 -1
v -0.5 2.4 -1
v -0.5 2.5 -1
v -0.5 2.6 -1
v -0.3 2.5 -1
v -0.3 2.6 -1
v -0.3 2.7 -1
v 0.4 2.5 -1
v 0.4 2.6 -1
v 0.4 2.7 -1
v 0.6 2.4 -1
v 0.6 2.5 -1
v 0.6 2.6 -1
v 0.7 2.3 -1
v 0.7 2.4 -1
v 0.7 2.5 -1
v 0.8 2.3 -1
v 0.8 2.4 -1
v -0.6 0.2 -1.1
v -0.6 0.4 -1.1
v -0.3 0.2 -1.1
v -0.3 0.4 -1.1
v 0.4 0.2 -1.1
v 0.4 0.4 -1.1
v 0.7 0.2 -1.1
v 0.7 0.4 -1.1
v -0.7 0.5 -1.2
v -0.7 0.6 -1.2
v -0.7 2.2 -1.2
v -0.7 2.3 -1.2
v -0.6 0.4 -1.2
v -0.6 0.5 -1.2
v -0.6 0.6 -1.2
v -0.6 2.2 -1.2
v -0.6 2.3 -1.2
v -0.6 2.4 -1.2
v -0.5 2.3 -1.2
v -0.5 2.4 -1.2
v -0.5 2.5 -1.2
v -0.4 2.4 -1.2
v -0.4 2.5 -1.2
v -0.3 0.4 -1.2
v -0.3 0.5 -1.2
v -0.3 2.5 -1.2
v -0.3 2.6 -1.2
v -0.2 2.5 -1.2
v -0.2 2.6 -1.2
v 0.3 2.5 -1.2
v 0.3 2.6 -1.2
v 0.4 0.4 -1.2
v 0.4 0.5 -1.2
v 0.4 2.5 -1.2
v 0.4 2.6 -1.2
v 0.5 2.4 -1.2
v 0.5 2.5 -1.2
v 0.6 2.3 -1.2
v 0.6 2.4 -1.2
v 0.6 2.5 -1.2
v 0.7 0.4 -1.2
v 0.7 0.5 -1.2
v 0.7 0.6 -1.2
v 0.7 2.2 -1.2
v 0.7 2.3 -1.2
v 0.7 2.4 -1.2
v 0.8 0.5 -1.2
v 0.8 0.6 -1.2
v 0.8 2.2 -1.2
v 0.8 2.3 -1.2
v -0.7 0.6 -1.3
v -0.7 2.2 -1.3
v -0.6 0.5 -1.3
v -0.6 0.6 -1.3
v -0.6 2.2 -1.3
v -0.6 2.3 -1.3
v -0.5 0.5 -1.3
v -0.5 0.6 -1.3
v -0.5 2.2 -1.3
v -0.5 2.3 -1.3
v -0.5 2.4 -1.3
v -0.4 2.3 -1.3
v -0.4 2.4 -1.3
v -0.4 2.5 -1.3
v -0.2 2.5 -1.3
v -0.2 2.6 -1.3
v 0.3 2.5 -1.3
v 0.3 2.6 -1.3
v 0.5 2.3 -1.3
v 0.5 2.4 -1.3
v 0.5 2.5 -1.3
v 0.6 0.5 -1.3
v 0.6 0.6 -1.3
v 0.6 2.2 -1.3
v 0.6 2.3 -1.3
v 0.6 2.4 -1.3
v 0.7 0.5 -1.3
v 0.7 0.6 -1.3
v 0.7 2.2 -1.3
v 0.7 2.3 -1.3
v 0.8 0.6 -1.3
v 0.8 2.2 -1.3
v -0.6 0.6 -1.4
v -0.6 2.2 -1.4
v -0.5 0.5 -1.4
v -0.5 0.6 -1.4
v -0.5 2.2 -1.4
v -0.5 2.3 -1.4
v -0.4 2.3 -1.4
v -0.4 2.4 -1.4
v -0.2 0.5 -1.4
v -0.2 0.6 -1.4
v 0.3 0.5 -1.4
v 0.3 0.6 -1.4
v 0.5 2.3 -1.4
v 0.5 2.4 -1.4
v 0.6 0.5 -1.4
v 0.6 0.6 -1.4
v 0.6 2.2 -1.4
v 0.6 2.3 -1.4
v 0.7 0.6 -1.4
v 0.7 2.2 -1.4
v -0.2 0.5 -1.5
v -0.2 0.6 -1.5
v -0.1 0.5 -1.5
v -0.1 0.6 -1.5
v 0.2 0.5 -1.5
v 0.2 0.6 -1.5
v 0.3 0.5 -1.5
v 0.3 0.6 -1.5
v -0.1 0.5 -1.6
v -0.1 0.6 -1.6
v 5.96046e-08 0.5 -1.6
v 5.96046e-08 0.6 -1.6
v 0.1 0.5 -1.6
v 0.1 0.6 -1.6
v 0.2 0.5 -1.6
v 0.2 0.6 -1.6
v 5.96046e-08 0.5 -1.7
v 5.96046e-08 0.6 -1.7
v 0.1 0.5 -1.7
v 0.1 0.6 -1.7
v -0.6 0.2 1.4
v -0.3 0.2 1.4
v 0.4 0.2 1.4
v 0.7 0.2 1.4
v -0.6 0.2 1.1
v -0.3 0.2 1.1
v 0.4 0.2 1.1
v 0.7 0.2 1.1
v -0.6 0.2 -0.8
v -0.3 0.2 -0.8
v 0.4 0.2 -0.8
v 0.7 0.2 -0.8
v -0.6 0.2 -1.1
v -0.3 0.2 -1.1
v 0.4 0.2 -1.1
v 0.7 0.2 -1.1
v -0.6 0.4 1.5
v -0.3 0.4 1.5
v 0.4 0.4 1.5
v 0.7 0.4 1.5
v -0.6 0.4 1.4
v -0.3 0.4 1.4
v 0.4 0.4 1.4
v 0.7 0.4 1.4
v -0.6 0.4 1.1
v -0.3 0.4 1.1
v 0.4 0.4 1.1
v 0.7 0.4 1.1
v -0.6 0.4 1
v -0.3 0.4 1
v 0.4 0.4 1
v 0.7 0.4 1
v -0.6 0.4 -0.7
v -0.3 0.4 -0.7
v 0.4 0.4 -0.7
v 0.7 0.4 -0.7
v -0.6 0.4 -0.8
v -0.3 0.4 -0.8
v 0.4 0.4 -0.8
v 0.7 0.4 -0.8
v -0.6 0.4 -1.1
v -0.3 0.4 -1.1
v 0.4 0.4 -1.1
v 0.7 0.4 -1.1
v -0.6 0.4 -1.2
v -0.3 0.4 -1.2
v 0.4 0.4 -1.2
v 0.7 0.4 -1.2
v -0.5 0.5 1.7
v 0.6 0.5 1.7
v -0.6 0.5 1.6
v -0.5 0.5 1.6
v 0.6 0.5 1.6
v 0.7 0.5 1.6
v -0.7 0.5 1.5
v -0.6 0.5 1.5
v -0.3 0.5 1.5
v 0.4 0.5 1.5
v 0.7 0.5 1.5
v 0.8 0.5 1.5
v -0.6 0.5 1
v -0.3 0.5 1
v 0.4 0.5 1
v 0.7 0.5 1
v -0.6 0.5 -0.7
v -0.3 0.5 -0.7
v 0.4 0.5 -0.7
v 0.7 0.5 -0.7
v -0.7 0.5 -1.2
v -0.6 0.5 -1.2
v -0.3 0.5 -1.2
v 0.4 0.5 -1.2
v 0.7 0.5 -1.2
v 0.8 0.5 -1.2
v -0.6 0.5 -1.3
v -0.5 0.5 -1.3
v 0.6 0.5 -1.3
v 0.7 0.5 -1.3
v -0.5 0.5 -1.4
v -0.2 0.5 -1.4
v 0.3 0.5 -1.4
v 0.6 0.5 -1.4
v -0.2 0.5 -1.5
v -0.1 0.5 -1.5
v 0.2 0.5 -1.5
v 0.3 0.5 -1.5
v -0.1 0.5 -1.6
v 5.96046e-08 0.5 -1.6
v 0.1 0.5 -1.6
v 0.2 0.5 -1.6
v 5.96046e-08 0.5 -1.7
v 0.1 0.5 -1.7
v -0.6 0.6 1.7
v -0.5 0.6 1.7
v 0.6 0.6 1.7
v 0.7 0.6 1.7
v -0.7 0.6 1.6
v -0.6 0.6 1.6
v -0.5 0.6 1.6
v 0.6 0.6 1.6
v 0.7 0.6 1.6
v 0.8 0.6 1.6
v -0.7 0.6 1.5
v -0.6 0.6 1.5
v 0.7 0.6 1.5
v 0.8 0.6 1.5
v -0.7 0.6 -1.2
v -0.6 0.6 -1.2
v 0.7 0.6 -1.2
v 0.8 0.6 -1.2
v -0.7 0.6 -1.3
v -0.6 0.6 -1.3
v -0.5 0.6 -1.3
v 0.6 0.6 -1.3
v 0.7 0.6 -1.3
v 0.8 0.6 -1.3
v -0.6 0.6 -1.4
v -0.5 0.6 -1.4
v 0.6 0.6 -1.4
v 0.7 0.6 -1.4
v -0.5 0.7 1.8
v 0.6 0.7 1.8
v -0.5 0.7 1.7
v -0.1 0.7 1.7
v 0.2 0.7 1.7
v 0.6 0.7 1.7
v -0.6 0.8 1.8
v -0.5 0.8 1.8
v 0.6 0.8 1.8
v 0.7 0.8 1.8
v -0.6 0.8 1.7
v -0.5 0.8 1.7
v 0.6 0.8 1.7
v 0.7 0.8 1.7
v -0.7 0.9 1.7
v -0.6 0.9 1.7
v 0.7 0.9 1.7
v 0.8 0.9 1.7
v -0.7 0.9 1.6
v -0.6 0.9 1.6
v 0.7 0.9 1.6
v 0.8 0.9 1.6
v -0.7 2 1.4
v -0.6 2 1.4
v 0.7 2 1.4
v 0.8 2 1.4
v -0.7 2 1.3
v -0.6 2 1.3
v -0.5 2 1.3
v 0.6 2 1.3
v 0.7 2 1.3
v 0.8 2 1.3
v 0.6 2 1.2
v -0.5 2 0.8
v -0.6 2 0.7
v -0.5 2 0.7
v 0.6 2 0.7
v 0.7 2 0.7
v -0.6 2 0.5
v -0.5 2 0.5
v 0.6 2 0.5
v 0.7 2 0.5
v -0.5 2 0.3
v 0.6 2 0.3
v -0.6 2 0.2
v -0.5 2 0.2
v 0.6 2 0.2
v 0.7 2 0.2
v -0.6 2 0.0999999
v -0.5 2 0.0999999
v 0.6 2 0.0999999
v 0.7 2 0.0999999
v -0.5 2 0
v 0.6 2 0
v -0.6 2 -0.2
v -0.5 2 -0.2
v 0.6 2 -0.2
v 0.7 2 -0.2
v -0.6 2 -0.4
v -0.5 2 -0.4
v 0.6 2 -0.4
v 0.7 2 -0.4
v 0.6 2 -0.5
v -0.5 2 -0.9
v -0.7 2 -1
v -0.6 2 -1
v -0.5 2 -1
v 0.6 2 -1
v 0.7 2 -1
v 0.8 2 -1
v -0.7 2 -1.1
v -0.6 2 -1.1
v 0.7 2 -1.1
v 0.8 2 -1.1
v -0.4 2.1 1.8
v 5.96046e-08 2.1 1.8
v 0.1 2.1 1.8
v 0.5 2.1 1.8
v -0.4 2.1 1.7
v -0.1 2.1 1.7
v 5.96046e-08 2.1 1.7
v 0.1 2.1 1.7
v 0.2 2.1 1.7
v 0.5 2.1 1.7
v -0.7 2.1 1.3
v -0.6 2.1 1.3
v 0.7 2.1 1.3
v 0.8 2.1 1.3
v -0.7 2.1 -1
v -0.6 2.1 -1
v 0.7 2.1 -1
v 0.8 2.1 -1
v -0.2 0.6 -1.4
v 0.3 0.6 -1.4
v -0.2 0.6 -1.5
v -0.1 0.6 -1.5
v 0.2 0.6 -1.5
v 0.3 0.6 -1.5
v -0.1 0.6 -1.6
v 5.96046e-08 0.6 -1.6
v 0.1 0.6 -1.6
v 0.2 0.6 -1.6
v 5.96046e-08 0.6 -1.7
v 0.1 0.6 -1.7
v -0.7 1 1.4
v -0.6 1 1.4
v 0.7 1 1.4
v 0.8 1 1.4
v -0.7 1 -1.1
v -0.6 1 -1.1
v 0.7 1 -1.1
v 0.8 1 -1.1
v -0.6 1.1 1.3
v -0.5 1.1 1.3
v 0.6 1.1 1.3
v 0.7 1.1 1.3
v -0.5 1.1 1.2
v 0.6 1.1 0.8
v -0.6 1.1 0.7
v -0.5 1.1 0.7
v 0.6 1.1 0.7
v 0.7 1.1 0.7
v -0.6 1.1 0.5
v -0.5 1.1 0.5
v 0.6 1.1 0.5
v 0.7 1.1 0.5
v -0.5 1.1 0.3
v 0.6 1.1 0.3
v -0.6 1.1 0.2
v -0.5 1.1 0.2
v 0.6 1.1 0.2
v 0.7 1.1 0.2
v -0.6 1.1 0.0999999
v -0.5 1.1 0.0999999
v 0.6 1.1 0.0999999
v 0.7 1.1 0.0999999
v -0.5 1.1 0
v 0.6 1.1 0
v -0.6 1.1 -0.2
v -0.5 1.1 -0.2
v 0.6 1.1 -0.2
v 0.7 1.1 -0.2
v -0.6 1.1 -0.4
v -0.5 1.1 -0.4
v 0.6 1.1 -0.4
v 0.7 1.1 -0.4
v -0.5 1.1 -0.5
v 0.6 1.1 -0.9
v -0.6 1.1 -1
v -0.5 1.1 -1
v 0.6 1.1 -1
v 0.7 1.1 -1
v -0.4 1.5 1.8
v 5.96046e-08 1.5 1.8
v 0.1 1.5 1.8
v 0.5 1.5 1.8
v -0.4 1.5 1.7
v -0.1 1.5 1.7
v 5.96046e-08 1.5 1.7
v 0.1 1.5 1.7
v 0.2 1.5 1.7
v 0.5 1.5 1.7
v -0.7 2.1 1.7
v -0.6 2.1 1.7
v 0.7 2.1 1.7
v 0.8 2.1 1.7
v -0.7 2.1 1.6
v -0.6 2.1 1.6
v 0.7 2.1 1.6
v 0.8 2.1 1.6
v -0.6 2.2 1.8
v -0.5 2.2 1.8
v 0.6 2.2 1.8
v 0.7 2.2 1.8
v -0.7 2.2 1.6
v -0.6 2.2 1.6
v -0.5 2.2 1.6
v 0.6 2.2 1.6
v 0.7 2.2 1.6
v 0.8 2.2 1.6
v -0.7 2.2 1.5
v -0.6 2.2 1.5
v 0.7 2.2 1.5
v 0.8 2.2 1.5
v -0.7 2.2 -1.2
v -0.6 2.2 -1.2
v 0.7 2.2 -1.2
v 0.8 2.2 -1.2
v -0.7 2.2 -1.3
v -0.6 2.2 -1.3
v -0.5 2.2 -1.3
v 0.6 2.2 -1.3
v 0.7 2.2 -1.3
v 0.8 2.2 -1.3
v -0.6 2.2 -1.4
v -0.5 2.2 -1.4
v 0.6 2.2 -1.4
v 0.7 2.2 -1.4
v -0.5 2.3 1.8
v 0.6 2.3 1.8
v -0.4 2.3 1.7
v 0.5 2.3 1.7
v -0.6 2.3 1.6
v -0.5 2.3 1.6
v -0.4 2.3 1.6
v 0.5 2.3 1.6
v 0.6 2.3 1.6
v 0.7 2.3 1.6
v -0.7 2.3 1.5
v -0.6 2.3 1.5
v -0.5 2.3 1.5
v 0.6 2.3 1.5
v 0.7 2.3 1.5
v 0.8 2.3 1.5
v -0.7 2.3 1.3
v -0.6 2.3 1.3
v 0.7 2.3 1.3
v 0.8 2.3 1.3
v -0.7 2.3 1.1
v -0.6 2.3 1.1
v 0.7 2.3 1.1
v 0.8 2.3 1.1
v -0.7 2.3 -0.8
v -0.6 2.3 -0.8
v 0.7 2.3 -0.8
v 0.8 2.3 -0.8
v -0.7 2.3 -1
v -0.6 2.3 -1
v 0.7 2.3 -1
v 0.8 2.3 -1
v -0.7 2.3 -1.2
v -0.6 2.3 -1.2
v -0.5 2.3 -1.2
v 0.6 2.3 -1.2
v 0.7 2.3 -1.2
v 0.8 2.3 -1.2
v -0.6 2.3 -1.3
v -0.5 2.3 -1.3
v -0.4 2.3 -1.3
v 0.5 2.3 -1.3
v 0.6 2.3 -1.3
v 0.7 2.3 -1.3
v -0.5 2.3 -1.4
v -0.4 2.3 -1.4
v 0.5 2.3 -1.4
v 0.6 2.3 -1.4
v -0.4 2.4 1.7
v 0.5 2.4 1.7
v -0.5 2.4 1.6
v -0.4 2.4 1.6
v 0.5 2.4 1.6
v 0.6 2.4 1.6
v -0.6 2.4 1.5
v -0.5 2.4 1.5
v -0.4 2.4 1.5
v 0.5 2.4 1.5
v 0.6 2.4 1.5
v 0.7 2.4 1.5
v -0.7 2.4 1.3
v -0.6 2.4 1.3
v -0.5 2.4 1.3
v 0.6 2.4 1.3
v 0.7 2.4 1.3
v 0.8 2.4 1.3
v -0.7 2.4 1.1
v -0.6 2.4 1.1
v -0.5 2.4 1.1
v 0.6 2.4 1.1
v 0.7 2.4 1.1
v 0.8 2.4 1.1
v -0.7 2.4 -0.8
v -0.6 2.4 -0.8
v -0.5 2.4 -0.8
v 0.6 2.4 -0.8
v 0.7 2.4 -0.8
v 0.8 2.4 -0.8
v -0.7 2.4 -1
v -0.6 2.4 -1
v -0.5 2.4 -1
v 0.6 2.4 -1
v 0.7 2.4 -1
v 0.8 2.4 -1
v -0.6 2.4 -1.2
v -0.5 2.4 -1.2
v -0.4 2.4 -1.2
v 0.5 2.4 -1.2
v 0.6 2.4 -1.2
v 0.7 2.4 -1.2
v -0.5 2.4 -1.3
v -0.4 2.4 -1.3
v 0.5 2.4 -1.3
v 0.6 2.4 -1.3
v -0.4 2.4 -1.4
v 0.5 2.4 -1.4
v -0.4 2.5 1.6
v -0.2 2.5 1.6
v 0.3 2.5 1.6
v 0.5 2.5 1.6
v -0.5 2.5 1.5
v -0.4 2.5 1.5
v -0.3 2.5 1.5
v -0.2 2.5 1.5
v 0.3 2.5 1.5
v 0.4 2.5 1.5
v 0.5 2.5 1.5
v 0.6 2.5 1.5
v -0.6 2.5 1.3
v -0.5 2.5 1.3
v -0.3 2.5 1.3
v 0.4 2.5 1.3
v 0.6 2.5 1.3
v 0.7 2.5 1.3
v -0.6 2.5 1.1
v -0.5 2.5 1.1
v -0.3 2.5 1.1
v 0.4 2.5 1.1
v 0.6 2.5 1.1
v 0.7 2.5 1.1
v -0.6 2.5 -0.8
v -0.5 2.5 -0.8
v -0.3 2.5 -0.8
v 0.4 2.5 -0.8
v 0.6 2.5 -0.8
v 0.7 2.5 -0.8
v -0.6 2.5 -1
v -0.5 2.5 -1
v -0.3 2.5 -1
v 0.4 2.5 -1
v 0.6 2.5 -1
v 0.7 2.5 -1
v -0.5 2.5 -1.2
v -0.4 2.5 -1.2
v -0.3 2.5 -1.2
v -0.2 2.5 -1.2
v 0.3 2.5 -1.2
v 0.4 2.5 -1.2
v 0.5 2.5 -1.2
v 0.6 2.5 -1.2
v -0.4 2.5 -1.3
v -0.2 2.5 -1.3
v 0.3 2.5 -1.3
v 0.5 2.5 -1.3
v -0.2 2.6 1.6
v 0.3 2.6 1.6
v -0.3 2.6 1.5
v -0.2 2.6 1.5
v 0.3 2.6 1.5
v 0.4 2.6 1.5
v -0.5 2.6 1.3
v -0.3 2.6 1.3
v 0.4 2.6 1.3
v 0.6 2.6 1.3
v -0.5 2.6 1.1
v -0.3 2.6 1.1
v -0.1 2.6 1.1
v 5.96046e-08 2.6 1.1
v 0.1 2.6 1.1
v 0.2 2.6 1.1
v 0.4 2.6 1.1
v 0.6 2.6 1.1
v -0.5 2.6 -0.8
v -0.3 2.6 -0.8
v -0.1 2.6 -0.8
v 5.96046e-08 2.6 -0.8
v 0.1 2.6 -0.8
v 0.2 2.6 -0.8
v 0.4 2.6 -0.8
v 0.6 2.6 -0.8
v -0.5 2.6 -1
v -0.3 2.6 -1
v 0.4 2.6 -1
v 0.6 2.6 -1
v -0.3 2.6 -1.2
v -0.2 2.6 -1.2
v 0.3 2.6 -1.2
v 0.4 2.6 -1.2
v -0.2 2.6 -1.3
v 0.3 2.6 -1.3
v -0.3 2.7 1.3
v 0.4 2.7 1.3
v -0.3 2.7 1.1
v -0.1 2.7 1.1
v 5.96046e-08 2.7 1.1
v 0.1 2.7 1.1
v 0.2 2.7 1.1
v 0.4 2.7 1.1
v -0.3 2.7 -0.8
v -0.1 2.7 -0.8
v 5.96046e-08 2.7 -0.8
v 0.1 2.7 -0.8
v 0.2 2.7 -0.8
v 0.4 2.7 -0.8
v -0.3 2.7 -1
v 0.4 2.7 -1

# faces
f 4/11/1 2/11/1 1/11/1
f 5/11/1 2/11/1 4/11/1
f 7/10/1 4/10/1 3/10/1
f 7/10/1 6/10/1 5/10/1
f 7/10/1 5/10/1 4/10/1
f 8/10/1 6/10/1 7/10/1
f 9/10/1 7/10/1 3/10/1
f 9/9/1 8/9/1 7/9/1
f 10/10/1 6/10/1 8/10/1
f 10/9/1 8/9/1 9/9/1
f 12/10/1 9/10/1 3/10/1
f 12/10/1 10/10/1 9/10/1
f 13/10/1 10/10/1 12/10/1
f 14/10/1 6/10/1 10/10/1
f 14/10/1 10/10/1 13/10/1
f 15/10/1 13/10/1 12/10/1
f 15/10/1 12/10/1 11/10/1
f 15/9/1 14/9/1 13/9/1
f 16/10/1 6/10/1 14/10/1
f 16/9/1 14/9/1 15/9/1
f 17/10/1 15/10/1 11/10/1
f 20/10/1 6/10/1 16/10/1
f 21/10/1 18/10/1 17/10/1
f 21/10/1 17/10/1 11/10/1
f 22/10/1 18/10/1 21/10/1
f 23/10/1 18/10/1 22/10/1
f 24/10/1 20/10/1 19/10/1
f 25/10/1 23/10/1 22/10/1
f 25/10/1 24/10/1 23/10/1
f 26/10/1 24/10/1 25/10/1
f 27/10/1 20/10/1 24/10/1
f 27/10/1 24/10/1 26/10/1
f 27/10/1 6/10/1 20/10/1
f 28/10/1 6/10/1 27/10/1
f 29/10/1 27/10/1 26/10/1
f 30/10/1 27/10/1 29/10/1
f 31/10/1 27/10/1 30/10/1
f 32/10/1 27/10/1 31/10/1
f 33/10/1 27/10/1 32/10/1
f 34/10/1 27/10/1 33/10/1
f 35/10/1 31/10/1 30/10/1
f 36/10/1 31/10/1 35/10/1
f 37/10/1 33/10/1 32/10/1
f 38/10/1 33/10/1 37/10/1
f 43/5/1 40/5/1 39/5/1
f 44/5/1 40/5/1 43/5/1
f 45/5/1 42/5/1 41/5/1
f 46/5/1 42/5/1 45/5/1
f 48/5/1 43/5/1 39/5/1
f 49/2/1 44/2/1 43/2/1
f 49/5/1 43/5/1 48/5/1
f 50/5/1 40/5/1 44/5/1
f 50/2/1 44/2/1 49/2/1
f 51/5/1 40/5/1 50/5/1
f 54/5/1 45/5/1 41/5/1
f 55/2/1 46/2/1 45/2/1
f 55/5/1 45/5/1 54/5/1
f 56/5/1 42/5/1 46/5/1
f 56/2/1 46/2/1 55/2/1
f 57/5/1 42/5/1 56/5/1
f 60/5/1 49/5/1 48/5/1
f 60/5/1 48/5/1 47/5/1
f 60/5/1 52/5/1 51/5/1
f 60/5/1 50/5/1 49/5/1
f 60/5/1 51/5/1 50/5/1
f 61/5/1 52/5/1 60/5/1
f 62/5/1 58/5/1 57/5/1
f 62/5/1 55/5/1 54/5/1
f 62/5/1 57/5/1 56/5/1
f 62/5/1 56/5/1 55/5/1
f 62/5/1 54/5/1 53/5/1
f 63/5/1 58/5/1 62/5/1
f 66/11/1 60/11/1 59/11/1
f 67/11/1 60/11/1 66/11/1
f 68/11/1 64/11/1 63/11/1
f 69/11/1 64/11/1 68/11/1
f 72/1/1 66/1/1 65/1/1
f 73/1/1 66/1/1 72/1/1
f 74/10/1 72/10/1 71/10/1
f 74/10/1 73/10/1 72/10/1
f 75/10/1 73/10/1 74/10/1
f 78/10/1 77/10/1 76/10/1
f 79/10/1 77/10/1 78/10/1
f 80/10/1 77/10/1 79/10/1
f 81/10/1 77/10/1 80/10/1
f 82/10/1 77/10/1 81/10/1
f 83/10/1 77/10/1 82/10/1
f 84/10/1 77/10/1 83/10/1
f 85/10/1 77/10/1 84/10/1
f 86/10/1 78/10/1 76/10/1
f 87/10/1 78/10/1 86/10/1
f 88/10/1 80/10/1 79/10/1
f 89/10/1 80/10/1 88/10/1
f 90/10/1 82/10/1 81/10/1
f 91/10/1 82/10/1 90/10/1
f 92/10/1 84/10/1 83/10/1
f 93/10/1 84/10/1 92/10/1
f 94/10/1 77/10/1 85/10/1
f 95/10/1 77/10/1 94/10/1
f 96/10/1 74/10/1 71/10/1
f 98/10/1 93/10/1 92/10/1
f 98/10/1 91/10/1 90/10/1
f 98/10/1 94/10/1 93/10/1
f 98/10/1 89/10/1 88/10/1
f 98/10/1 92/10/1 91/10/1
f 98/10/1 88/10/1 87/10/1
f 98/10/1 90/10/1 89/10/1
f 99/10/1 94/10/1 98/10/1
f 100/10/1 97/10/1 96/10/1
f 100/10/1 96/10/1 71/10/1
f 101/10/1 97/10/1 100/10/1
f 104/10/1 70/10/1 69/10/1
f 105/10/1 70/10/1 104/10/1
f 106/10/1 102/10/1 101/10/1
f 107/10/1 102/10/1 106/10/1
f 112/10/1 104/10/1 103/10/1
f 113/10/1 104/10/1 112/10/1
f 114/10/1 108/10/1 107/10/1
f 115/10/1 108/10/1 114/10/1
f 116/10/1 110/10/1 109/10/1
f 117/10/1 110/10/1 116/10/1
f 118/10/1 112/10/1 111/10/1
f 119/10/1 112/10/1 118/10/1
f 120/10/1 116/10/1 115/10/1
f 121/10/1 116/10/1 120/10/1
f 122/10/1 118/10/1 117/10/1
f 123/10/1 118/10/1 122/10/1
f 128/11/1 125/11/1 124/11/1
f 129/11/1 125/11/1 128/11/1
f 130/11/1 127/11/1 126/11/1
f 131/11/1 127/11/1 130/11/1
f 134/10/1 133/10/1 132/10/1
f 135/10/1 133/10/1 134/10/1
f 148/7/1 137/7/1 136/7/1
f 149/6/1 138/6/1 137/6/1
f 149/7/1 137/7/1 148/7/1
f 150/6/1 138/6/1 149/6/1
f 151/7/1 146/7/1 145/7/1
f 152/6/1 147/6/1 146/6/1
f 152/7/1 146/7/1 151/7/1
f 153/6/1 147/6/1 152/6/1
f 154/6/1 149/6/1 148/6/1
f 154/7/1 150/7/1 149/7/1
f 155/6/1 138/6/1 150/6/1
f 155/7/1 150/7/1 154/7/1
f 156/6/1 138/6/1 155/6/1
f 157/7/1 153/7/1 152/7/1
f 157/6/1 152/6/1 151/6/1
f 158/6/1 147/6/1 153/6/1
f 158/7/1 153/7/1 157/7/1
f 159/6/1 147/6/1 158/6/1
f 160/7/1 156/7/1 155/7/1
f 160/6/1 155/6/1 154/6/1
f 161/6/1 138/6/1 156/6/1
f 161/7/1 156/7/1 160/7/1
f 162/6/1 138/6/1 161/6/1
f 163/7/1 159/7/1 158/7/1
f 163/6/1 158/6/1 157/6/1
f 164/6/1 147/6/1 159/6/1
f 164/7/1 159/7/1 163/7/1
f 165/6/1 147/6/1 164/6/1
f 166/7/1 162/7/1 161/7/1
f 166/6/1 161/6/1 160/6/1
f 167/6/1 138/6/1 162/6/1
f 167/7/1 162/7/1 166/7/1
f 168/6/1 138/6/1 167/6/1
f 169/7/1 165/7/1 164/7/1
f 169/6/1 164/6/1 163/6/1
f 170/6/1 147/6/1 165/6/1
f 170/7/1 165/7/1 169/7/1
f 171/6/1 147/6/1 170/6/1
f 172/7/1 168/7/1 167/7/1
f 172/6/1 167/6/1 166/6/1
f 173/6/1 138/6/1 168/6/1
f 173/7/1 168/7/1 172/7/1
f 174/6/1 138/6/1 173/6/1
f 175/7/1 171/7/1 170/7/1
f 175/6/1 170/6/1 169/6/1
f 176/6/1 147/6/1 171/6/1
f 176/7/1 171/7/1 175/7/1
f 177/6/1 147/6/1 176/6/1
f 178/6/1 154/6/1 148/6/1
f 178/6/1 160/6/1 154/6/1
f 178/6/1 166/6/1 160/6/1
f 178/6/1 172/6/1 166/6/1
f 178/6/1 173/6/1 172/6/1
f 179/7/1 174/7/1 173/7/1
f 179/6/1 173/6/1 178/6/1
f 180/7/1 174/7/1 179/7/1
f 181/6/1 140/6/1 139/6/1
f 182/7/1 141/7/1 140/7/1
f 182/6/1 140/6/1 181/6/1
f 183/7/1 141/7/1 182/7/1
f 184/7/1 143/7/1 142/7/1
f 185/6/1 144/6/1 143/6/1
f 185/7/1 143/7/1 184/7/1
f 186/6/1 144/6/1 185/6/1
f 187/6/1 157/6/1 151/6/1
f 187/6/1 163/6/1 157/6/1
f 187/6/1 176/6/1 175/6/1
f 187/6/1 169/6/1 163/6/1
f 187/6/1 175/6/1 169/6/1
f 188/7/1 177/7/1 176/7/1
f 188/6/1 176/6/1 187/6/1
f 189/7/1 177/7/1 188/7/1
f 194/10/1 191/10/1 190/10/1
f 195/10/1 191/10/1 194/10/1
f 198/10/1 193/10/1 192/10/1
f 199/10/1 193/10/1 198/10/1
f 200/10/1 196/10/1 195/10/1
f 201/10/1 196/10/1 200/10/1
f 206/10/1 198/10/1 197/10/1
f 207/10/1 198/10/1 206/10/1
f 208/10/1 202/10/1 201/10/1
f 209/10/1 202/10/1 208/10/1
f 210/10/1 204/10/1 203/10/1
f 211/10/1 204/10/1 210/10/1
f 212/10/1 206/10/1 205/10/1
f 213/10/1 206/10/1 212/10/1
f 214/10/1 210/10/1 209/10/1
f 215/10/1 210/10/1 214/10/1
f 216/10/1 212/10/1 211/10/1
f 217/10/1 212/10/1 216/10/1
f 222/10/1 219/10/1 218/10/1
f 223/10/1 219/10/1 222/10/1
f 226/10/1 221/10/1 220/10/1
f 227/10/1 221/10/1 226/10/1
f 228/10/1 224/10/1 223/10/1
f 229/10/1 224/10/1 228/10/1
f 230/10/1 226/10/1 225/10/1
f 231/10/1 226/10/1 230/10/1
f 238/10/1 233/10/1 232/10/1
f 239/10/1 233/10/1 238/10/1
f 240/10/1 235/10/1 234/10/1
f 241/10/1 235/10/1 240/10/1
f 242/10/1 237/10/1 236/10/1
f 243/10/1 237/10/1 242/10/1
f 244/10/1 240/10/1 239/10/1
f 245/10/1 240/10/1 244/10/1
f 246/10/1 242/10/1 241/10/1
f 247/10/1 242/10/1 246/10/1
f 250/8/1 249/8/1 248/8/1
f 251/8/1 249/8/1 250/8/1
f 256/10/1 253/10/1 252/10/1
f 257/10/1 253/10/1 256/10/1
f 258/10/1 255/10/1 254/10/1
f 259/10/1 255/10/1 258/10/1
f 262/8/1 261/8/1 260/8/1
f 263/8/1 261/8/1 262/8/1
f 266/9/1 265/9/1 264/9/1
f 267/9/1 265/9/1 266/9/1
f 270/8/1 269/8/1 268/8/1
f 271/8/1 269/8/1 270/8/1
f 274/5/1 273/5/1 272/5/1
f 275/5/1 273/5/1 274/5/1
f 278/9/1 277/9/1 276/9/1
f 279/9/1 277/9/1 278/9/1
f 285/5/1 281/5/1 280/5/1
f 286/5/1 281/5/1 285/5/1
f 289/5/1 283/5/1 282/5/1
f 290/5/1 283/5/1 289/5/1
f 292/5/1 287/5/1 286/5/1
f 292/5/1 285/5/1 284/5/1
f 292/5/1 286/5/1 285/5/1
f 293/5/1 287/5/1 292/5/1
f 294/5/1 291/5/1 290/5/1
f 294/5/1 290/5/1 289/5/1
f 294/5/1 289/5/1 288/5/1
f 295/5/1 291/5/1 294/5/1
f 298/5/1 297/5/1 296/5/1
f 299/5/1 297/5/1 298/5/1
f 300/5/2 301/5/2 302/5/2
f 302/5/2 301/5/2 303/5/2
f 304/5/2 305/5/2 309/5/2
f 309/5/2 305/5/2 310/5/2
f 306/5/2 307/5/2 313/5/2
f 313/5/2 307/5/2 314/5/2
f 310/5/2 311/5/2 316/5/2
f 308/5/2 309/5/2 316/5/2
f 309/5/2 310/5/2 316/5/2
f 316/5/2 311/5/2 317/5/2
f 314/5/2 315/5/2 318/5/2
f 313/5/2 314/5/2 318/5/2
f 312/5/2 313/5/2 318/5/2
f 318/5/2 315/5/2 319/5/2
f 320/9/2 321/9/2 322/9/2
f 322/9/2 321/9/2 323/9/2
f 324/8/2 325/8/2 326/8/2
f 326/8/2 325/8/2 327/8/2
f 328/5/2 329/5/2 330/5/2
f 330/5/2 329/5/2 331/5/2
f 332/8/2 333/8/2 334/8/2
f 334/8/2 333/8/2 335/8/2
f 336/9/2 337/9/2 338/9/2
f 338/9/2 337/9/2 339/9/2
f 340/8/2 341/8/2 342/8/2
f 342/8/2 341/8/2 343/8/2
f 344/10/2 345/10/2 348/10/2
f 348/10/2 345/10/2 349/10/2
f 346/10/2 347/10/2 350/10/2
f 350/10/2 347/10/2 351/10/2
f 352/10/2 353/10/2 358/10/2
f 358/10/2 353/10/2 359/10/2
f 354/10/2 355/10/2 360/10/2
f 360/10/2 355/10/2 361/10/2
f 356/10/2 357/10/2 362/10/2
f 362/10/2 357/10/2 363/10/2
f 359/10/2 360/10/2 364/10/2
f 364/10/2 360/10/2 365/10/2
f 361/10/2 362/10/2 366/10/2
f 366/10/2 362/10/2 367/10/2
f 368/10/2 369/10/2 372/10/2
f 372/10/2 369/10/2 373/10/2
f 370/10/2 371/10/2 376/10/2
f 376/10/2 371/10/2 377/10/2
f 373/10/2 374/10/2 378/10/2
f 378/10/2 374/10/2 379/10/2
f 375/10/2 376/10/2 380/10/2
f 380/10/2 376/10/2 381/10/2
f 382/11/2 383/11/2 386/11/2
f 386/11/2 383/11/2 387/11/2
f 384/11/2 385/11/2 388/11/2
f 388/11/2 385/11/2 389/11/2
f 390/10/2 391/10/2 392/10/2
f 392/10/2 391/10/2 393/10/2
f 394/6/2 395/6/2 406/6/2
f 395/7/2 396/7/2 407/7/2
f 406/6/2 395/6/2 407/6/2
f 407/7/2 396/7/2 408/7/2
f 403/6/2 404/6/2 409/6/2
f 404/7/2 405/7/2 410/7/2
f 409/6/2 404/6/2 410/6/2
f 410/7/2 405/7/2 411/7/2
f 394/6/2 406/6/2 412/6/2
f 406/7/2 407/7/2 413/7/2
f 412/6/2 406/6/2 413/6/2
f 407/6/2 408/6/2 414/6/2
f 413/7/2 407/7/2 414/7/2
f 403/6/2 409/6/2 415/6/2
f 409/7/2 410/7/2 416/7/2
f 415/6/2 409/6/2 416/6/2
f 410/6/2 411/6/2 417/6/2
f 416/7/2 410/7/2 417/7/2
f 394/6/2 412/6/2 418/6/2
f 412/7/2 413/7/2 419/7/2
f 418/6/2 412/6/2 419/6/2
f 413/6/2 414/6/2 420/6/2
f 419/7/2 413/7/2 420/7/2
f 403/6/2 415/6/2 421/6/2
f 415/7/2 416/7/2 422/7/2
f 421/6/2 415/6/2 422/6/2
f 416/6/2 417/6/2 423/6/2
f 422/7/2 416/7/2 423/7/2
f 394/6/2 418/6/2 424/6/2
f 418/7/2 419/7/2 425/7/2
f 424/6/2 418/6/2 425/6/2
f 419/6/2 420/6/2 426/6/2
f 425/7/2 419/7/2 426/7/2
f 403/6/2 421/6/2 427/6/2
f 421/7/2 422/7/2 428/7/2
f 427/6/2 421/6/2 428/6/2
f 422/6/2 423/6/2 429/6/2
f 428/7/2 422/7/2 429/7/2
f 394/6/2 424/6/2 430/6/2
f 424/7/2 425/7/2 431/7/2
f 430/6/2 424/6/2 431/6/2
f 425/6/2 426/6/2 432/6/2
f 431/7/2 425/7/2 432/7/2
f 403/6/2 427/6/2 433/6/2
f 427/7/2 428/7/2 434/7/2
f 433/6/2 427/6/2 434/6/2
f 428/6/2 429/6/2 435/6/2
f 434/7/2 428/7/2 435/7/2
f 430/7/2 431/7/2 436/7/2
f 431/6/2 432/6/2 437/6/2
f 436/7/2 431/7/2 437/7/2
f 414/6/2 408/6/2 438/6/2
f 437/6/2 432/6/2 438/6/2
f 420/6/2 414/6/2 438/6/2
f 426/6/2 420/6/2 438/6/2
f 432/6/2 426/6/2 438/6/2
f 397/6/2 398/6/2 439/6/2
f 398/7/2 399/7/2 440/7/2
f 439/6/2 398/6/2 440/6/2
f 440/7/2 399/7/2 441/7/2
f 400/7/2 401/7/2 442/7/2
f 401/6/2 402/6/2 443/6/2
f 442/7/2 401/7/2 443/7/2
f 443/6/2 402/6/2 444/6/2
f 433/7/2 434/7/2 445/7/2
f 434/6/2 435/6/2 446/6/2
f 445/7/2 434/7/2 446/7/2
f 423/6/2 417/6/2 447/6/2
f 446/6/2 435/6/2 447/6/2
f 417/6/2 411/6/2 447/6/2
f 429/6/2 423/6/2 447/6/2
f 435/6/2 429/6/2 447/6/2
f 448/10/2 449/10/2 452/10/2
f 452/10/2 449/10/2 453/10/2
f 450/10/2 451/10/2 456/10/2
f 456/10/2 451/10/2 457/10/2
f 453/10/2 454/10/2 458/10/2
f 458/10/2 454/10/2 459/10/2
f 455/10/2 456/10/2 464/10/2
f 464/10/2 456/10/2 465/10/2
f 459/10/2 460/10/2 466/10/2
f 466/10/2 460/10/2 467/10/2
f 461/10/2 462/10/2 468/10/2
f 468/10/2 462/10/2 469/10/2
f 463/10/2 464/10/2 470/10/2
f 470/10/2 464/10/2 471/10/2
f 467/10/2 468/10/2 472/10/2
f 472/10/2 468/10/2 473/10/2
f 469/10/2 470/10/2 474/10/2
f 474/10/2 470/10/2 475/10/2
f 476/5/2 477/5/2 480/5/2
f 480/5/2 477/5/2 481/5/2
f 478/5/2 479/5/2 482/5/2
f 482/5/2 479/5/2 483/5/2
f 476/5/2 480/5/2 485/5/2
f 480/2/2 481/2/2 486/2/2
f 485/5/2 480/5/2 486/5/2
f 481/5/2 477/5/2 487/5/2
f 486/2/2 481/2/2 487/2/2
f 487/5/2 477/5/2 488/5/2
f 478/5/2 482/5/2 491/5/2
f 482/2/2 483/2/2 492/2/2
f 491/5/2 482/5/2 492/5/2
f 483/5/2 479/5/2 493/5/2
f 492/2/2 483/2/2 493/2/2
f 493/5/2 479/5/2 494/5/2
f 485/5/2 486/5/2 497/5/2
f 484/5/2 485/5/2 497/5/2
f 488/5/2 489/5/2 497/5/2
f 486/5/2 487/5/2 497/5/2
f 487/5/2 488/5/2 497/5/2
f 497/5/2 489/5/2 498/5/2
f 494/5/2 495/5/2 499/5/2
f 491/5/2 492/5/2 499/5/2
f 493/5/2 494/5/2 499/5/2
f 492/5/2 493/5/2 499/5/2
f 490/5/2 491/5/2 499/5/2
f 499/5/2 495/5/2 500/5/2
f 496/11/2 497/11/2 503/11/2
f 503/11/2 497/11/2 504/11/2
f 500/11/2 501/11/2 505/11/2
f 505/11/2 501/11/2 506/11/2
f 502/1/2 503/1/2 509/1/2
f 509/1/2 503/1/2 510/1/2
f 508/10/2 509/10/2 511/10/2
f 509/10/2 510/10/2 511/10/2
f 511/10/2 510/10/2 512/10/2
f 513/10/2 514/10/2 515/10/2
f 515/10/2 514/10/2 516/10/2
f 516/10/2 514/10/2 517/10/2
f 517/10/2 514/10/2 518/10/2
f 518/10/2 514/10/2 519/10/2
f 519/10/2 514/10/2 520/10/2
f 520/10/2 514/10/2 521/10/2
f 521/10/2 514/10/2 522/10/2
f 513/10/2 515/10/2 523/10/2
f 523/10/2 515/10/2 524/10/2
f 516/10/2 517/10/2 525/10/2
f 525/10/2 517/10/2 526/10/2
f 518/10/2 519/10/2 527/10/2
f 527/10/2 519/10/2 528/10/2
f 520/10/2 521/10/2 529/10/2
f 529/10/2 521/10/2 530/10/2
f 522/10/2 514/10/2 531/10/2
f 531/10/2 514/10/2 532/10/2
f 508/10/2 511/10/2 533/10/2
f 529/10/2 530/10/2 535/10/2
f 527/10/2 528/10/2 535/10/2
f 530/10/2 531/10/2 535/10/2
f 525/10/2 526/10/2 535/10/2
f 528/10/2 529/10/2 535/10/2
f 524/10/2 525/10/2 535/10/2
f 526/10/2 527/10/2 535/10/2
f 535/10/2 531/10/2 536/10/2
f 533/10/2 534/10/2 537/10/2
f 508/10/2 533/10/2 537/10/2
f 537/10/2 534/10/2 538/10/2
f 506/10/2 507/10/2 541/10/2
f 541/10/2 507/10/2 542/10/2
f 538/10/2 539/10/2 543/10/2
f 543/10/2 539/10/2 544/10/2
f 540/10/2 541/10/2 549/10/2
f 549/10/2 541/10/2 550/10/2
f 544/10/2 545/10/2 551/10/2
f 551/10/2 545/10/2 552/10/2
f 546/10/2 547/10/2 553/10/2
f 553/10/2 547/10/2 554/10/2
f 548/10/2 549/10/2 555/10/2
f 555/10/2 549/10/2 556/10/2
f 552/10/2 553/10/2 557/10/2
f 557/10/2 553/10/2 558/10/2
f 554/10/2 555/10/2 559/10/2
f 559/10/2 555/10/2 560/10/2
f 561/11/2 562/11/2 564/11/2
f 564/11/2 562/11/2 565/11/2
f 563/10/2 564/10/2 567/10/2
f 565/10/2 566/10/2 567/10/2
f 564/10/2 565/10/2 567/10/2
f 567/10/2 566/10/2 568/10/2
f 563/10/2 567/10/2 569/10/2
f 567/9/2 568/9/2 569/9/2
f 568/10/2 566/10/2 570/10/2
f 569/9/2 568/9/2 570/9/2
f 563/10/2 569/10/2 572/10/2
f 569/10/2 570/10/2 572/10/2
f 572/10/2 570/10/2 573/10/2
f 570/10/2 566/10/2 574/10/2
f 573/10/2 570/10/2 574/10/2
f 572/10/2 573/10/2 575/10/2
f 571/10/2 572/10/2 575/10/2
f 573/9/2 574/9/2 575/9/2
f 574/10/2 566/10/2 576/10/2
f 575/9/2 574/9/2 576/9/2
f 571/10/2 575/10/2 577/10/2
f 576/10/2 566/10/2 580/10/2
f 577/10/2 578/10/2 581/10/2
f 571/10/2 577/10/2 581/10/2
f 581/10/2 578/10/2 582/10/2
f 582/10/2 578/10/2 583/10/2
f 579/10/2 580/10/2 584/10/2
f 582/10/2 583/10/2 585/10/2
f 583/10/2 584/10/2 585/10/2
f 585/10/2 584/10/2 586/10/2
f 584/10/2 580/10/2 587/10/2
f 586/10/2 584/10/2 587/10/2
f 580/10/2 566/10/2 587/10/2
f 587/10/2 566/10/2 588/10/2
f 586/10/2 587/10/2 589/10/2
f 589/10/2 587/10/2 590/10/2
f 590/10/2 587/10/2 591/10/2
f 591/10/2 587/10/2 592/10/2
f 592/10/2 587/10/2 593/10/2
f 593/10/2 587/10/2 594/10/2
f 590/10/2 591/10/2 595/10/2
f 595/10/2 591/10/2 596/10/2
f 592/10/2 593/10/2 597/10/2
f 597/10/2 593/10/2 598/10/2
f 602/10/3 600/10/3 599/10/3
f 603/10/3 600/10/3 602/10/3
f 604/10/3 600/10/3 603/10/3
f 605/10/3 600/10/3 604/10/3
f 606/10/3 600/10/3 605/10/3
f 608/3/3 604/3/3 603/3/3
f 609/3/3 604/3/3 608/3/3
f 610/5/3 606/5/3 605/5/3
f 611/5/3 606/5/3 610/5/3
f 612/10/3 602/10/3 601/10/3
f 612/10/3 603/10/3 602/10/3
f 613/10/3 603/10/3 612/10/3
f 614/3/3 608/3/3 603/3/3
f 614/4/3 609/4/3 608/4/3
f 615/3/3 604/3/3 609/3/3
f 615/4/3 609/4/3 614/4/3
f 616/3/3 614/3/3 603/3/3
f 616/10/3 603/10/3 613/10/3
f 616/3/3 615/3/3 614/3/3
f 617/10/3 605/10/3 604/10/3
f 617/3/3 615/3/3 616/3/3
f 617/3/3 604/3/3 615/3/3
f 618/10/3 616/10/3 613/10/3
f 618/10/3 617/10/3 616/10/3
f 619/10/3 617/10/3 618/10/3
f 620/10/3 617/10/3 619/10/3
f 621/10/3 605/10/3 617/10/3
f 621/10/3 617/10/3 620/10/3
f 622/5/3 610/5/3 605/5/3
f 623/5/3 606/5/3 611/5/3
f 624/5/3 622/5/3 605/5/3
f 624/5/3 623/5/3 622/5/3
f 625/5/3 606/5/3 623/5/3
f 625/5/3 623/5/3 624/5/3
f 626/10/3 618/10/3 613/10/3
f 626/9/3 619/9/3 618/9/3
f 627/10/3 620/10/3 619/10/3
f 627/9/3 619/9/3 626/9/3
f 628/9/3 621/9/3 620/9/3
f 628/10/3 620/10/3 627/10/3
f 629/10/3 605/10/3 621/10/3
f 629/9/3 621/9/3 628/9/3
f 630/10/3 628/10/3 627/10/3
f 630/10/3 626/10/3 613/10/3
f 630/10/3 629/10/3 628/10/3
f 630/10/3 627/10/3 626/10/3
f 631/10/3 605/10/3 629/10/3
f 631/10/3 629/10/3 630/10/3
f 632/9/3 613/9/3 612/9/3
f 632/10/3 612/10/3 601/10/3
f 633/10/3 630/10/3 613/10/3
f 633/9/3 613/9/3 632/9/3
f 634/3/3 631/3/3 630/3/3
f 635/3/3 631/3/3 634/3/3
f 636/3/3 634/3/3 630/3/3
f 636/4/3 635/4/3 634/4/3
f 637/3/3 631/3/3 635/3/3
f 637/4/3 635/4/3 636/4/3
f 638/5/3 624/5/3 605/5/3
f 639/5/3 606/5/3 625/5/3
f 640/10/3 632/10/3 601/10/3
f 640/10/3 633/10/3 632/10/3
f 641/10/3 633/10/3 640/10/3
f 642/10/3 630/10/3 633/10/3
f 642/10/3 633/10/3 641/10/3
f 642/3/3 636/3/3 630/3/3
f 642/3/3 637/3/3 636/3/3
f 643/3/3 631/3/3 637/3/3
f 643/3/3 637/3/3 642/3/3
f 643/10/3 605/10/3 631/10/3
f 644/5/3 639/5/3 638/5/3
f 644/10/3 605/10/3 643/10/3
f 644/5/3 638/5/3 605/5/3
f 645/10/3 607/10/3 606/10/3
f 645/5/3 639/5/3 644/5/3
f 645/5/3 606/5/3 639/5/3
f 646/10/3 607/10/3 645/10/3
f 647/10/3 642/10/3 641/10/3
f 647/10/3 643/10/3 642/10/3
f 647/10/3 645/10/3 644/10/3
f 647/10/3 644/10/3 643/10/3
f 648/10/3 645/10/3 647/10/3
f 653/10/3 650/10/3 649/10/3
f 654/10/3 650/10/3 653/10/3
f 656/1/3 652/1/3 651/1/3
f 657/1/3 652/1/3 656/1/3
f 658/1/3 652/1/3 657/1/3
f 663/11/3 656/11/3 655/11/3
f 663/1/3 657/1/3 656/1/3
f 664/1/3 657/1/3 663/1/3
f 665/6/3 660/6/3 659/6/3
f 666/6/3 660/6/3 665/6/3
f 667/7/3 666/7/3 665/7/3
f 668/7/3 666/7/3 667/7/3
f 671/10/3 664/10/3 663/10/3
f 671/11/3 663/11/3 655/11/3
f 672/10/3 664/10/3 671/10/3
f 673/7/3 670/7/3 669/7/3
f 674/7/3 670/7/3 673/7/3
f 675/6/3 674/6/3 673/6/3
f 676/6/3 674/6/3 675/6/3
f 677/10/3 662/10/3 661/10/3
f 678/10/3 662/10/3 677/10/3
f 679/11/3 671/11/3 655/11/3
f 680/1/3 672/1/3 671/1/3
f 680/11/3 671/11/3 679/11/3
f 681/1/3 672/1/3 680/1/3
f 683/1/3 682/1/3 681/1/3
f 683/1/3 681/1/3 680/1/3
f 684/1/3 682/1/3 683/1/3
f 687/10/3 686/10/3 685/10/3
f 688/10/3 686/10/3 687/10/3
f 694/10/3 690/10/3 689/10/3
f 695/10/3 690/10/3 694/10/3
f 696/10/3 690/10/3 695/10/3
f 697/10/3 692/10/3 691/10/3
f 698/10/3 692/10/3 697/10/3
f 700/11/3 694/11/3 693/11/3
f 701/11/3 694/11/3 700/11/3
f 702/10/3 699/10/3 698/10/3
f 703/10/3 699/10/3 702/10/3
f 705/10/3 704/10/3 703/10/3
f 706/10/3 704/10/3 705/10/3
f 708/10/3 707/10/3 706/10/3
f 710/10/3 708/10/3 706/10/3
f 710/10/3 709/10/3 708/10/3
f 711/10/3 709/10/3 710/10/3
f 713/10/3 710/10/3 706/10/3
f 714/10/3 710/10/3 713/10/3
f 718/10/3 713/10/3 712/10/3
f 719/10/3 713/10/3 718/10/3
f 720/11/3 716/11/3 715/11/3
f 721/11/3 716/11/3 720/11/3
f 725/10/3 718/10/3 717/10/3
f 726/10/3 718/10/3 725/10/3
f 727/10/3 723/10/3 722/10/3
f 727/10/3 722/10/3 721/10/3
f 728/10/3 723/10/3 727/10/3
f 729/10/3 725/10/3 724/10/3
f 730/10/3 725/10/3 729/10/3
f 736/11/3 732/11/3 731/11/3
f 737/11/3 732/11/3 736/11/3
f 738/10/3 734/10/3 733/10/3
f 739/10/3 734/10/3 738/10/3
f 741/10/3 740/10/3 739/10/3
f 742/10/3 740/10/3 741/10/3
f 744/10/3 743/10/3 742/10/3
f 745/10/3 743/10/3 744/10/3
f 746/5/3 736/5/3 735/5/3
f 747/5/3 736/5/3 746/5/3
f 750/10/3 749/10/3 748/10/3
f 751/10/3 749/10/3 750/10/3
f 756/10/3 753/10/3 752/10/3
f 757/10/3 753/10/3 756/10/3
f 761/10/3 759/10/3 758/10/3
f 762/10/3 759/10/3 761/10/3
f 763/5/3 755/5/3 754/5/3
f 764/5/3 755/5/3 763/5/3
f 767/10/3 761/10/3 760/10/3
f 768/10/3 761/10/3 767/10/3
f 769/11/3 765/11/3 764/11/3
f 770/11/3 765/11/3 769/11/3
f 771/10/3 767/10/3 766/10/3
f 772/10/3 767/10/3 771/10/3
f 775/5/3 774/5/3 773/5/3
f 776/5/3 774/5/3 775/5/3
f 779/5/3 778/5/3 777/5/3
f 780/5/3 778/5/3 779/5/3
f 783/10/3 782/10/3 781/10/3
f 784/10/3 782/10/3 783/10/3
f 786/10/3 785/10/3 784/10/3
f 787/10/3 785/10/3 786/10/3
f 789/10/3 788/10/3 787/10/3
f 790/10/3 788/10/3 789/10/3
f 793/10/3 791/10/3 790/10/3
f 794/10/3 791/10/3 793/10/3
f 796/10/3 793/10/3 792/10/3
f 797/10/3 793/10/3 796/10/3
f 799/10/3 796/10/3 795/10/3
f 800/10/3 796/10/3 799/10/3
f 801/10/3 799/10/3 798/10/3
f 802/10/3 799/10/3 801/10/3
f 805/10/3 804/10/3 803/10/3
f 806/10/3 804/10/3 805/10/3
f 807/10/3 804/10/3 806/10/3
f 811/10/3 809/10/3 808/10/3
f 811/10/3 810/10/3 809/10/3
f 812/10/3 810/10/3 811/10/3
f 815/10/3 814/10/3 813/10/3
f 816/10/3 814/10/3 815/10/3
f 819/10/3 818/10/3 817/10/3
f 820/10/3 818/10/3 819/10/3
f 823/10/3 822/10/3 821/10/3
f 824/10/3 822/10/3 823/10/3
f 827/10/3 826/10/3 825/10/3
f 828/10/3 826/10/3 827/10/3
f 831/5/3 830/5/3 829/5/3
f 832/5/3 830/5/3 831/5/3
f 835/5/3 834/5/3 833/5/3
f 836/5/3 834/5/3 835/5/3
f 841/10/3 838/10/3 837/10/3
f 842/10/3 838/10/3 841/10/3
f 844/10/3 843/10/3 842/10/3
f 845/10/3 843/10/3 844/10/3
f 847/5/3 840/5/3 839/5/3
f 848/5/3 840/5/3 847/5/3
f 849/10/3 846/10/3 845/10/3
f 850/10/3 846/10/3 849/10/3
f 852/10/3 851/10/3 850/10/3
f 853/10/3 851/10/3 852/10/3
f 856/10/3 855/10/3 854/10/3
f 857/10/3 855/10/3 856/10/3
f 863/10/3 859/10/3 858/10/3
f 864/10/3 859/10/3 863/10/3
f 866/10/3 863/10/3 862/10/3
f 867/10/3 863/10/3 866/10/3
f 868/5/3 861/5/3 860/5/3
f 869/5/3 861/5/3 868/5/3
f 871/10/3 866/10/3 865/10/3
f 872/10/3 866/10/3 871/10/3
f 873/10/3 871/10/3 870/10/3
f 874/10/3 871/10/3 873/10/3
f 878/10/3 876/10/3 875/10/3
f 879/10/3 876/10/3 878/10/3
f 880/10/3 878/10/3 877/10/3
f 881/10/3 878/10/3 880/10/3
f 882/10/3 878/10/3 881/10/3
f 886/10/3 884/10/3 883/10/3
f 886/10/3 885/10/3 884/10/3
f 887/10/3 885/10/3 886/10/3
f 889/10/3 888/10/3 887/10/3
f 890/10/3 888/10/3 889/10/3
f 893/10/3 892/10/3 891/10/3
f 894/10/3 892/10/3 893/10/3
f 897/10/3 896/10/3 895/10/3
f 898/10/3 896/10/3 897/10/3
f 899/10/4 900/10/4 901/10/4
f 901/10/4 900/10/4 902/10/4
f 903/10/4 904/10/4 905/10/4
f 905/10/4 904/10/4 906/10/4
f 907/10/4 908/10/4 910/10/4
f 910/10/4 908/10/4 911/10/4
f 909/10/4 910/10/4 912/10/4
f 912/10/4 910/10/4 913/10/4
f 913/10/4 910/10/4 914/10/4
f 915/10/4 916/10/4 918/10/4
f 916/10/4 917/10/4 918/10/4
f 918/10/4 917/10/4 919/10/4
f 919/10/4 920/10/4 921/10/4
f 921/10/4 920/10/4 922/10/4
f 923/10/4 924/10/4 927/10/4
f 927/10/4 924/10/4 928/10/4
f 928/10/4 929/10/4 930/10/4
f 930/10/4 929/10/4 931/10/4
f 925/5/4 926/5/4 933/5/4
f 933/5/4 926/5/4 934/5/4
f 931/10/4 932/10/4 935/10/4
f 935/10/4 932/10/4 936/10/4
f 936/10/4 937/10/4 938/10/4
f 938/10/4 937/10/4 939/10/4
f 940/10/4 941/10/4 942/10/4
f 942/10/4 941/10/4 943/10/4
f 944/10/4 945/10/4 949/10/4
f 949/10/4 945/10/4 950/10/4
f 948/10/4 949/10/4 952/10/4
f 952/10/4 949/10/4 953/10/4
f 946/5/4 947/5/4 954/5/4
f 954/5/4 947/5/4 955/5/4
f 951/10/4 952/10/4 957/10/4
f 957/10/4 952/10/4 958/10/4
f 956/10/4 957/10/4 959/10/4
f 959/10/4 957/10/4 960/10/4
f 961/5/4 962/5/4 963/5/4
f 963/5/4 962/5/4 964/5/4
f 965/5/4 966/5/4 967/5/4
f 967/5/4 966/5/4 968/5/4
f 969/10/4 970/10/4 971/10/4
f 971/10/4 970/10/4 972/10/4
f 973/10/4 974/10/4 975/10/4
f 975/10/4 974/10/4 976/10/4
f 977/10/4 978/10/4 979/10/4
f 979/10/4 978/10/4 980/10/4
f 981/10/4 982/10/4 983/10/4
f 983/10/4 982/10/4 984/10/4
f 985/10/4 986/10/4 987/10/4
f 987/10/4 986/10/4 988/10/4
f 988/10/4 986/10/4 989/10/4
f 990/10/4 991/10/4 993/10/4
f 991/10/4 992/10/4 993/10/4
f 993/10/4 992/10/4 994/10/4
f 995/10/4 996/10/4 997/10/4
f 997/10/4 996/10/4 998/10/4
f 998/10/4 999/10/4 1000/10/4
f 1000/10/4 999/10/4 1001/10/4
f 1001/10/4 1002/10/4 1003/10/4
f 1003/10/4 1002/10/4 1004/10/4
f 1004/10/4 1005/10/4 1007/10/4
f 1007/10/4 1005/10/4 1008/10/4
f 1006/10/4 1007/10/4 1010/10/4
f 1010/10/4 1007/10/4 1011/10/4
f 1009/10/4 1010/10/4 1013/10/4
f 1013/10/4 1010/10/4 1014/10/4
f 1012/10/4 1013/10/4 1015/10/4
f 1015/10/4 1013/10/4 1016/10/4
f 1017/5/4 1018/5/4 1019/5/4
f 1019/5/4 1018/5/4 1020/5/4
f 1021/5/4 1022/5/4 1023/5/4
f 1023/5/4 1022/5/4 1024/5/4
f 1025/11/4 1026/11/4 1030/11/4
f 1030/11/4 1026/11/4 1031/11/4
f 1027/10/4 1028/10/4 1032/10/4
f 1032/10/4 1028/10/4 1033/10/4
f 1033/10/4 1034/10/4 1035/10/4
f 1035/10/4 1034/10/4 1036/10/4
f 1036/10/4 1037/10/4 1038/10/4
f 1038/10/4 1037/10/4 1039/10/4
f 1029/5/4 1030/5/4 1040/5/4
f 1040/5/4 1030/5/4 1041/5/4
f 1042/10/4 1043/10/4 1044/10/4
f 1044/10/4 1043/10/4 1045/10/4
f 1046/10/4 1047/10/4 1050/10/4
f 1050/10/4 1047/10/4 1051/10/4
f 1052/10/4 1053/10/4 1055/10/4
f 1055/10/4 1053/10/4 1056/10/4
f 1048/5/4 1049/5/4 1057/5/4
f 1057/5/4 1049/5/4 1058/5/4
f 1054/10/4 1055/10/4 1061/10/4
f 1061/10/4 1055/10/4 1062/10/4
f 1058/11/4 1059/11/4 1063/11/4
f 1063/11/4 1059/11/4 1064/11/4
f 1060/10/4 1061/10/4 1065/10/4
f 1065/10/4 1061/10/4 1066/10/4
f 1067/10/4 1068/10/4 1070/10/4
f 1070/10/4 1068/10/4 1071/10/4
f 1069/11/4 1070/11/4 1073/11/4
f 1073/11/4 1070/11/4 1074/11/4
f 1071/10/4 1072/10/4 1075/10/4
f 1075/10/4 1072/10/4 1076/10/4
f 1076/10/4 1077/10/4 1078/10/4
f 1078/10/4 1077/10/4 1079/10/4
f 1079/10/4 1080/10/4 1081/10/4
f 1079/10/4 1081/10/4 1083/10/4
f 1081/10/4 1082/10/4 1083/10/4
f 1083/10/4 1082/10/4 1084/10/4
f 1079/10/4 1083/10/4 1086/10/4
f 1086/10/4 1083/10/4 1087/10/4
f 1085/10/4 1086/10/4 1091/10/4
f 1091/10/4 1086/10/4 1092/10/4
f 1088/11/4 1089/11/4 1093/11/4
f 1093/11/4 1089/11/4 1094/11/4
f 1090/10/4 1091/10/4 1095/10/4
f 1095/10/4 1091/10/4 1096/10/4
f 1094/10/4 1095/10/4 1097/10/4
f 1097/10/4 1095/10/4 1098/10/4
f 1099/10/4 1100/10/4 1102/10/4
f 1102/10/4 1100/10/4 1103/10/4
f 1102/10/4 1103/10/4 1105/10/4
f 1103/10/4 1104/10/4 1105/10/4
f 1101/11/4 1102/11/4 1107/11/4
f 1105/10/4 1106/10/4 1108/10/4
f 1107/11/4 1102/11/4 1108/11/4
f 1102/10/4 1105/10/4 1108/10/4
f 1108/10/4 1106/10/4 1110/10/4
f 1110/10/4 1106/10/4 1111/10/4
f 1111/10/4 1106/10/4 1112/10/4
f 1109/11/4 1110/11/4 1113/11/4
f 1110/10/4 1111/10/4 1114/10/4
f 1113/11/4 1110/11/4 1114/11/4
f 1114/10/4 1111/10/4 1115/10/4
f 1115/10/4 1111/10/4 1116/10/4
f 1114/10/4 1115/10/4 1117/10/4
f 1117/10/4 1115/10/4 1118/10/4
f 1119/8/4 1120/8/4 1121/8/4
f 1121/8/4 1120/8/4 1122/8/4
f 1123/8/4 1124/8/4 1125/8/4
f 1125/8/4 1124/8/4 1126/8/4
f 1127/8/4 1128/8/4 1129/8/4
f 1129/8/4 1128/8/4 1130/8/4
f 1131/8/4 1132/8/4 1133/8/4
f 1133/8/4 1132/8/4 1134/8/4
f 1135/8/4 1136/8/4 1137/8/4
f 1137/8/4 1136/8/4 1138/8/4
f 1143/5/5 1140/5/5 1139/5/5
f 1144/5/5 1140/5/5 1143/5/5
f 1145/5/5 1142/5/5 1141/5/5
f 1146/5/5 1142/5/5 1145/5/5
f 1151/5/5 1148/5/5 1147/5/5
f 1152/5/5 1148/5/5 1151/5/5
f 1153/5/5 1150/5/5 1149/5/5
f 1154/5/5 1150/5/5 1153/5/5
f 1159/5/5 1156/5/5 1155/5/5
f 1160/5/5 1156/5/5 1159/5/5
f 1161/5/5 1158/5/5 1157/5/5
f 1162/5/5 1158/5/5 1161/5/5
f 1167/5/5 1164/5/5 1163/5/5
f 1168/5/5 1164/5/5 1167/5/5
f 1169/5/5 1166/5/5 1165/5/5
f 1170/5/5 1166/5/5 1169/5/5
f 1175/5/5 1172/5/5 1171/5/5
f 1176/5/5 1172/5/5 1175/5/5
f 1177/5/5 1174/5/5 1173/5/5
f 1178/5/5 1174/5/5 1177/5/5
f 1183/5/5 1180/5/5 1179/5/5
f 1184/5/5 1180/5/5 1183/5/5
f 1185/5/5 1182/5/5 1181/5/5
f 1186/5/5 1182/5/5 1185/5/5
f 1190/11/5 1188/11/5 1187/11/5
f 1191/11/5 1188/11/5 1190/11/5
f 1194/11/5 1190/11/5 1189/11/5
f 1194/11/5 1192/11/5 1191/11/5
f 1194/11/5 1191/11/5 1190/11/5
f 1195/11/5 1192/11/5 1194/11/5
f 1196/11/5 1192/11/5 1195/11/5
f 1197/11/5 1192/11/5 1196/11/5
f 1199/11/5 1194/11/5 1193/11/5
f 1200/11/5 1196/11/5 1195/11/5
f 1201/11/5 1196/11/5 1200/11/5
f 1202/11/5 1198/11/5 1197/11/5
f 1203/11/5 1201/11/5 1200/11/5
f 1203/11/5 1202/11/5 1201/11/5
f 1203/11/5 1199/11/5 1193/11/5
f 1203/11/5 1200/11/5 1199/11/5
f 1204/11/5 1202/11/5 1203/11/5
f 1205/11/5 1202/11/5 1204/11/5
f 1206/11/5 1198/11/5 1202/11/5
f 1206/11/5 1202/11/5 1205/11/5
f 1207/11/5 1203/11/5 1193/11/5
f 1208/11/5 1203/11/5 1207/11/5
f 1209/11/5 1205/11/5 1204/11/5
f 1210/11/5 1205/11/5 1209/11/5
f 1211/11/5 1198/11/5 1206/11/5
f 1212/11/5 1198/11/5 1211/11/5
f 1213/11/5 1210/11/5 1209/11/5
f 1213/11/5 1211/11/5 1210/11/5
f 1213/11/5 1209/11/5 1208/11/5
f 1214/11/5 1211/11/5 1213/11/5
f 1215/11/5 1211/11/5 1214/11/5
f 1216/11/5 1211/11/5 1215/11/5
f 1217/11/5 1215/11/5 1214/11/5
f 1218/11/5 1215/11/5 1217/11/5
f 1219/11/5 1215/11/5 1218/11/5
f 1220/11/5 1215/11/5 1219/11/5
f 1221/8/5 1219/8/5 1218/8/5
f 1222/8/5 1219/8/5 1221/8/5
f 1223/8/5 1219/8/5 1222/8/5
f 1224/8/5 1219/8/5 1223/8/5
f 1225/8/5 1223/8/5 1222/8/5
f 1226/8/5 1223/8/5 1225/8/5
f 1227/8/5 1223/8/5 1226/8/5
f 1228/8/5 1223/8/5 1227/8/5
f 1229/8/5 1227/8/5 1226/8/5
f 1230/8/5 1227/8/5 1229/8/5
f 1236/1/5 1232/1/5 1231/1/5
f 1237/1/5 1232/1/5 1236/1/5
f 1238/1/5 1234/1/5 1233/1/5
f 1239/1/5 1234/1/5 1238/1/5
f 1241/10/5 1236/10/5 1235/10/5
f 1242/10/5 1236/10/5 1241/10/5
f 1243/10/5 1240/10/5 1239/10/5
f 1244/10/5 1240/10/5 1243/10/5
f 1249/10/5 1246/10/5 1245/10/5
f 1250/10/5 1246/10/5 1249/10/5
f 1253/10/5 1248/10/5 1247/10/5
f 1254/10/5 1248/10/5 1253/10/5
f 1255/10/5 1251/10/5 1250/10/5
f 1256/10/5 1251/10/5 1255/10/5
f 1257/10/5 1253/10/5 1252/10/5
f 1258/10/5 1253/10/5 1257/10/5
f 1261/10/5 1260/10/5 1259/10/5
f 1262/10/5 1260/10/5 1261/10/5
f 1263/10/5 1260/10/5 1262/10/5
f 1264/10/5 1260/10/5 1263/10/5
f 1269/10/5 1266/10/5 1265/10/5
f 1270/10/5 1266/10/5 1269/10/5
f 1271/10/5 1268/10/5 1267/10/5
f 1272/10/5 1268/10/5 1271/10/5
f 1277/10/5 1274/10/5 1273/10/5
f 1278/10/5 1274/10/5 1277/10/5
f 1279/10/5 1276/10/5 1275/10/5
f 1280/10/5 1276/10/5 1279/10/5
f 1285/10/5 1282/10/5 1281/10/5
f 1286/10/5 1282/10/5 1285/10/5
f 1289/10/5 1284/10/5 1283/10/5
f 1290/10/5 1284/10/5 1289/10/5
f 1291/10/5 1289/10/5 1288/10/5
f 1292/10/5 1287/10/5 1286/10/5
f 1293/10/5 1292/10/5 1286/10/5
f 1294/10/5 1292/10/5 1293/10/5
f 1295/10/5 1289/10/5 1291/10/5
f 1296/10/5 1289/10/5 1295/10/5
f 1301/10/5 1298/10/5 1297/10/5
f 1302/10/5 1300/10/5 1299/10/5
f 1303/10/5 1301/10/5 1297/10/5
f 1304/10/5 1301/10/5 1303/10/5
f 1305/10/5 1300/10/5 1302/10/5
f 1306/10/5 1300/10/5 1305/10/5
f 1311/10/5 1308/10/5 1307/10/5
f 1312/10/5 1310/10/5 1309/10/5
f 1313/10/5 1311/10/5 1307/10/5
f 1314/10/5 1311/10/5 1313/10/5
f 1315/10/5 1310/10/5 1312/10/5
f 1316/10/5 1310/10/5 1315/10/5
f 1321/10/5 1320/10/5 1319/10/5
f 1322/10/5 1318/10/5 1317/10/5
f 1324/10/5 1322/10/5 1317/10/5
f 1325/10/5 1322/10/5 1324/10/5
f 1326/10/5 1320/10/5 1321/10/5
f 1327/10/5 1320/10/5 1326/10/5
f 1329/10/5 1324/10/5 1323/10/5
f 1330/10/5 1324/10/5 1329/10/5
f 1331/10/5 1328/10/5 1327/10/5
f 1332/10/5 1328/10/5 1331/10/5
f 1337/5/5 1334/5/5 1333/5/5
f 1338/5/5 1334/5/5 1337/5/5
f 1339/5/5 1334/5/5 1338/5/5
f 1340/5/5 1336/5/5 1335/5/5
f 1341/5/5 1336/5/5 1340/5/5
f 1342/5/5 1336/5/5 1341/5/5
f 1347/10/5 1344/10/5 1343/10/5
f 1348/10/5 1344/10/5 1347/10/5
f 1349/10/5 1346/10/5 1345/10/5
f 1350/10/5 1346/10/5 1349/10/5
f 1351/8/6 1352/8/6 1353/8/6
f 1353/8/6 1352/8/6 1354/8/6
f 1354/8/6 1352/8/6 1355/8/6
f 1355/8/6 1352/8/6 1356/8/6
f 1354/8/6 1355/8/6 1357/8/6
f 1357/8/6 1355/8/6 1358/8/6
f 1358/8/6 1355/8/6 1359/8/6
f 1359/8/6 1355/8/6 1360/8/6
f 1358/8/6 1359/8/6 1361/8/6
f 1361/8/6 1359/8/6 1362/8/6
f 1363/9/6 1364/9/6 1367/9/6
f 1367/9/6 1364/9/6 1368/9/6
f 1365/9/6 1366/9/6 1369/9/6
f 1369/9/6 1366/9/6 1370/9/6
f 1371/10/6 1372/10/6 1375/10/6
f 1373/10/6 1374/10/6 1376/10/6
f 1371/10/6 1375/10/6 1377/10/6
f 1377/10/6 1375/10/6 1378/10/6
f 1376/10/6 1374/10/6 1379/10/6
f 1379/10/6 1374/10/6 1380/10/6
f 1381/10/6 1382/10/6 1385/10/6
f 1383/10/6 1384/10/6 1386/10/6
f 1381/10/6 1385/10/6 1387/10/6
f 1387/10/6 1385/10/6 1388/10/6
f 1386/10/6 1384/10/6 1389/10/6
f 1389/10/6 1384/10/6 1390/10/6
f 1391/10/6 1392/10/6 1395/10/6
f 1393/10/6 1394/10/6 1396/10/6
f 1391/10/6 1395/10/6 1397/10/6
f 1397/10/6 1395/10/6 1398/10/6
f 1396/10/6 1394/10/6 1399/10/6
f 1399/10/6 1394/10/6 1400/10/6
f 1401/10/6 1402/10/6 1405/10/6
f 1403/10/6 1404/10/6 1406/10/6
f 1401/10/6 1405/10/6 1407/10/6
f 1407/10/6 1405/10/6 1408/10/6
f 1406/10/6 1404/10/6 1409/10/6
f 1409/10/6 1404/10/6 1410/10/6
f 1411/5/6 1412/5/6 1415/5/6
f 1415/5/6 1412/5/6 1416/5/6
f 1416/5/6 1412/5/6 1417/5/6
f 1413/5/6 1414/5/6 1418/5/6
f 1418/5/6 1414/5/6 1419/5/6
f 1419/5/6 1414/5/6 1420/5/6
f 1421/10/6 1422/10/6 1425/10/6
f 1425/10/6 1422/10/6 1426/10/6
f 1423/10/6 1424/10/6 1427/10/6
f 1427/10/6 1424/10/6 1428/10/6
f 1429/10/6 1430/10/6 1434/10/6
f 1434/10/6 1430/10/6 1435/10/6
f 1431/10/6 1432/10/6 1436/10/6
f 1436/10/6 1432/10/6 1437/10/6
f 1433/10/6 1434/10/6 1439/10/6
f 1439/10/6 1434/10/6 1440/10/6
f 1437/10/6 1438/10/6 1441/10/6
f 1441/10/6 1438/10/6 1442/10/6
f 1443/10/6 1444/10/6 1447/10/6
f 1447/10/6 1444/10/6 1448/10/6
f 1445/10/6 1446/10/6 1451/10/6
f 1451/10/6 1446/10/6 1452/10/6
f 1448/10/6 1449/10/6 1453/10/6
f 1453/10/6 1449/10/6 1454/10/6
f 1450/10/6 1451/10/6 1455/10/6
f 1455/10/6 1451/10/6 1456/10/6
f 1457/10/6 1458/10/6 1459/10/6
f 1459/10/6 1458/10/6 1460/10/6
f 1457/10/6 1459/10/6 1462/10/6
f 1462/10/6 1459/10/6 1463/10/6
f 1460/10/6 1458/10/6 1464/10/6
f 1464/10/6 1458/10/6 1465/10/6
f 1461/10/6 1462/10/6 1468/10/6
f 1468/10/6 1462/10/6 1469/10/6
f 1465/10/6 1466/10/6 1470/10/6
f 1470/10/6 1466/10/6 1471/10/6
f 1467/10/6 1468/10/6 1473/10/6
f 1473/10/6 1468/10/6 1474/10/6
f 1471/10/6 1472/10/6 1475/10/6
f 1475/10/6 1472/10/6 1476/10/6
f 1477/10/6 1478/10/6 1481/10/6
f 1481/10/6 1478/10/6 1482/10/6
f 1479/10/6 1480/10/6 1483/10/6
f 1483/10/6 1480/10/6 1484/10/6
f 1485/10/6 1486/10/6 1489/10/6
f 1489/10/6 1486/10/6 1490/10/6
f 1487/10/6 1488/10/6 1493/10/6
f 1493/10/6 1488/10/6 1494/10/6
f 1490/10/6 1491/10/6 1495/10/6
f 1495/10/6 1491/10/6 1496/10/6
f 1492/10/6 1493/10/6 1499/10/6
f 1499/10/6 1493/10/6 1500/10/6
f 1496/10/6 1497/10/6 1501/10/6
f 1501/10/6 1497/10/6 1502/10/6
f 1498/10/6 1499/10/6 1503/10/6
f 1503/10/6 1499/10/6 1504/10/6
f 1505/10/6 1506/10/6 1508/10/6
f 1508/10/6 1506/10/6 1509/10/6
f 1507/10/6 1508/10/6 1512/10/6
f 1512/10/6 1508/10/6 1513/10/6
f 1509/10/6 1510/10/6 1514/10/6
f 1514/10/6 1510/10/6 1515/10/6
f 1511/10/6 1512/10/6 1518/10/6
f 1518/10/6 1512/10/6 1519/10/6
f 1515/10/6 1516/10/6 1520/10/6
f 1520/10/6 1516/10/6 1521/10/6
f 1517/10/6 1518/10/6 1523/10/6
f 1523/10/6 1518/10/6 1524/10/6
f 1521/10/6 1522/10/6 1527/10/6
f 1527/10/6 1522/10/6 1528/10/6
f 1524/10/6 1525/10/6 1530/10/6
f 1530/10/6 1525/10/6 1531/10/6
f 1526/10/6 1527/10/6 1532/10/6
f 1532/10/6 1527/10/6 1533/10/6
f 1529/10/6 1530/10/6 1535/10/6
f 1535/10/6 1530/10/6 1536/10/6
f 1533/10/6 1534/10/6 1539/10/6
f 1539/10/6 1534/10/6 1540/10/6
f 1536/10/6 1537/10/6 1541/10/6
f 1541/10/6 1537/10/6 1542/10/6
f 1538/10/6 1539/10/6 1545/10/6
f 1545/10/6 1539/10/6 1546/10/6
f 1542/10/6 1543/10/6 1547/10/6
f 1547/10/6 1543/10/6 1548/10/6
f 1544/10/6 1545/10/6 1549/10/6
f 1549/10/6 1545/10/6 1550/10/6
f 1548/10/6 1549/10/6 1551/10/6
f 1551/10/6 1549/10/6 1552/10/6
f 1553/10/6 1554/10/6 1558/10/6
f 1558/10/6 1554/10/6 1559/10/6
f 1559/10/6 1554/10/6 1560/10/6
f 1555/10/6 1556/10/6 1561/10/6
f 1561/10/6 1556/10/6 1562/10/6
f 1562/10/6 1556/10/6 1563/10/6
f 1557/10/6 1558/10/6 1566/10/6
f 1558/10/6 1559/10/6 1566/10/6
f 1566/10/6 1559/10/6 1567/10/6
f 1563/10/6 1564/10/6 1568/10/6
f 1562/10/6 1563/10/6 1568/10/6
f 1568/10/6 1564/10/6 1569/10/6
f 1565/10/6 1566/10/6 1571/10/6
f 1571/10/6 1566/10/6 1572/10/6
f 1569/10/6 1570/10/6 1575/10/6
f 1575/10/6 1570/10/6 1576/10/6
f 1572/10/6 1573/10/6 1578/10/6
f 1578/10/6 1573/10/6 1579/10/6
f 1574/10/6 1575/10/6 1580/10/6
f 1580/10/6 1575/10/6 1581/10/6
f 1577/10/6 1578/10/6 1583/10/6
f 1583/10/6 1578/10/6 1584/10/6
f 1581/10/6 1582/10/6 1587/10/6
f 1587/10/6 1582/10/6 1588/10/6
f 1584/10/6 1585/10/6 1589/10/6
f 1589/10/6 1585/10/6 1590/10/6
f 1590/10/6 1585/10/6 1591/10/6
f 1586/10/6 1587/10/6 1594/10/6
f 1594/10/6 1587/10/6 1595/10/6
f 1595/10/6 1587/10/6 1596/10/6
f 1591/10/6 1592/10/6 1597/10/6
f 1590/10/6 1591/10/6 1597/10/6
f 1597/10/6 1592/10/6 1598/10/6
f 1594/10/6 1595/10/6 1599/10/6
f 1593/10/6 1594/10/6 1599/10/6
f 1599/10/6 1595/10/6 1600/10/6
f 1601/10/6 1602/10/6 1604/10/6
f 1604/10/6 1602/10/6 1605/10/6
f 1603/10/6 1604/10/6 1608/10/6
f 1605/10/6 1606/10/6 1608/10/6
f 1604/10/6 1605/10/6 1608/10/6
f 1608/10/6 1606/10/6 1609/10/6
f 1607/10/6 1608/10/6 1611/10/6
f 1611/10/6 1608/10/6 1612/10/6
f 1609/10/6 1610/10/6 1617/10/6
f 1617/10/6 1610/10/6 1618/10/6
f 1612/10/6 1613/10/6 1620/10/6
f 1620/10/6 1613/10/6 1621/10/6
f 1614/10/6 1615/10/6 1622/10/6
f 1622/10/6 1615/10/6 1623/10/6
f 1616/10/6 1617/10/6 1624/10/6
f 1624/10/6 1617/10/6 1625/10/6
f 1619/10/6 1620/10/6 1627/10/6
f 1627/10/6 1620/10/6 1628/10/6
f 1625/10/6 1626/10/6 1629/10/6
f 1629/10/6 1626/10/6 1630/10/6
f 1628/10/6 1629/10/6 1631/10/6
f 1631/10/6 1629/10/6 1632/10/6
f 1632/10/6 1629/10/6 1633/10/6
f 1633/10/6 1629/10/6 1634/10/6
f 1632/10/6 1633/10/6 1635/10/6
f 1635/10/6 1633/10/6 1636/10/6
f 1637/10/6 1638/10/6 1639/10/6
f 1639/10/6 1638/10/6 1640/10/6
f 1640/10/6 1638/10/6 1641/10/6
f 1641/10/6 1638/10/6 1642/10/6
f 1642/10/6 1638/10/6 1643/10/6
f 1643/10/6 1638/10/6 1644/10/6
f 1640/9/6 1641/9/6 1646/9/6
f 1646/9/6 1641/9/6 1647/9/6
f 1642/9/6 1643/9/6 1648/9/6
f 1648/9/6 1643/9/6 1649/9/6
f 1646/10/6 1647/10/6 1651/10/6
f 1649/10/6 1650/10/6 1651/10/6
f 1648/10/6 1649/10/6 1651/10/6
f 1647/10/6 1648/10/6 1651/10/6
f 1645/10/6 1646/10/6 1651/10/6
f 1651/10/6 1650/10/6 1652/10/6
PNG

   IHDR         1Ypw  iCCPkCGColorSpaceGenericRGB  8U]hU>+$5lRem,lAi&3i)>A['!j-P(G	3k~s,[%,-:t}}-+*& gPG8"e ]A	b	;l  W2_E,(#Zs<5)"E6N#EkO0}*rUt.iei	# ]r
>cU{t7+gxu<D1_
u~R *-z#Mi*Wh6f}-gi:9fA,V>WB_-%=^t0uvW9%/VBW'_tMP\>@y0`D i|[`
hh) Tj0B#hU#~yhu	fp#1I/I"0! 'Sdd:J5"sdy#R7wAgdJ7kn^:}nWFVst$gj-tr__7Z~V54V
}o[G=Nd>-UlaY5V }xg[?k&>srq].r_r_qsGjy4k
iQBZ-<(d=dKO	a/zv7]od}sn?TF'|3Nn#I?"mzv~K=sl<b|_|4>?pQrib
2*(h {28oIyes8';Z9h6g >xRx'b8WO[xn% |^z} %xc   8eXIfMM *    i                              f   UIDAT8cg0Y 9g eQ@h@%p~{{@~D*|.a mQp    IENDB`#version 100

precision mediump float;

// Input vertex attributes (from vertex shader)
varying vec2 fragTexCoord;
varying vec4 fragColor;

// Input uniform values
uniform sampler2D texture0;
uniform vec4 colDiffuse;

// NOTE: Add here your custom variables

void main()
{
    // Texel color fetching from texture sampler
    vec4 texelColor = texture2D(texture0, fragTexCoord);

    // NOTE: Implement here your fragment shader code

    gl_FragColor = texelColor*colDiffuse;
}#version 100

// Input vertex attributes
attribute vec3 vertexPosition;
attribute vec2 vertexTexCoord;
attribute vec3 vertexNormal;
attribute vec4 vertexColor;

// Input uniform values
uniform mat4 mvp;

// Output vertex attributes (to fragment shader)
varying vec2 fragTexCoord;
varying vec4 fragColor;

// NOTE: Add here your custom variables

void main()
{
    // Send vertex attributes to fragment shader
    fragTexCoord = vertexTexCoord;
    fragColor = vertexColor;

    // Calculate final vertex position
    gl_Position = mvp*vec4(vertexPosition, 1.0);
}#version 100

precision mediump float;

// Input vertex attributes (from vertex shader)
varying vec2 fragTexCoord;
varying vec4 fragColor;

// Input uniform values
uniform sampler2D texture0;
uniform vec4 colDiffuse;

// NOTE: Add here your custom variables

const vec2 size = vec2(800, 450);   // render size
const float samples = 5.0;          // pixels per axis; higher = bigger glow, worse performance
const float quality = 2.5;             // lower = smaller glow, better quality

void main()
{
    vec4 sum = vec4(0);
    vec2 sizeFactor = vec2(1)/size*quality;

    // Texel color fetching from texture sampler
    vec4 source = texture2D(texture0, fragTexCoord);

    const int range = 2;            // should be = (samples - 1)/2;

    for (int x = -range; x <= range; x++)
    {
        for (int y = -range; y <= range; y++)
        {
            sum += texture2D(texture0, fragTexCoord + vec2(x, y)*sizeFactor);
        }
    }

    // Calculate final fragment color
    gl_FragColor = ((sum/(samples*samples)) + source)*colDiffuse;
}#version 100

precision mediump float;

// Input vertex attributes (from vertex shader)
varying vec2 fragTexCoord;
varying vec4 fragColor;

// Input uniform values
uniform sampler2D texture0;
uniform vec4 colDiffuse;

// NOTE: Add here your custom variables

// NOTE: Render size values must be passed from code
const float renderWidth = 800.0;
const float renderHeight = 450.0;

vec3 offset = vec3(0.0, 1.3846153846, 3.2307692308);
vec3 weight = vec3(0.2270270270, 0.3162162162, 0.0702702703);

void main()
{
    // Texel color fetching from texture sampler
    vec3 tc = texture2D(texture0, fragTexCoord).rgb*weight.x;

    tc += texture2D(texture0, fragTexCoord + vec2(offset.y)/renderWidth, 0.0).rgb*weight.y;
    tc += texture2D(texture0, fragTexCoord - vec2(offset.y)/renderWidth, 0.0).rgb*weight.y;

    tc += texture2D(texture0, fragTexCoord + vec2(offset.z)/renderWidth, 0.0).rgb*weight.z;
    tc += texture2D(texture0, fragTexCoord - vec2(offset.z)/renderWidth, 0.0).rgb*weight.z;

    gl_FragColor = vec4(tc, 1.0);
}#version 100

precision mediump float;

// Input vertex attributes (from vertex shader)
varying vec2 fragTexCoord;
varying vec4 fragColor;

// Input uniform values
uniform sampler2D texture0;
uniform sampler2D texture1;
uniform vec4 colDiffuse;

uniform float divider;

void main()
{
    // Texel color fetching from texture sampler
    vec4 texelColor0 = texture2D(texture0, fragTexCoord);
    vec4 texelColor1 = texture2D(texture1, fragTexCoord);

    float x = fract(fragTexCoord.s);
    float final = smoothstep(divider - 0.1, divider + 0.1, x);

    gl_FragColor = mix(texelColor0, texelColor1, final);
}
# version 100

precision mediump float;

// Input vertex attributes (from vertex shader)
varying vec2 fragTexCoord;
varying vec4 fragColor;

// Input uniform values
uniform sampler2D texture0;
uniform vec4 colDiffuse;

// NOTE: Add here your custom variables

float hatchOffsetY = 5.0;
float lumThreshold01 = 0.9;
float lumThreshold02 = 0.7;
float lumThreshold03 = 0.5;
float lumThreshold04 = 0.3;

void main()
{
    vec3 tc = vec3(1.0, 1.0, 1.0);
    float lum = length(texture2D(texture0, fragTexCoord).rgb);

    if (lum < lumThreshold01)
    {
        if (mod(gl_FragCoord.x + gl_FragCoord.y, 10.0) == 0.0) tc = vec3(0.0, 0.0, 0.0);
    }

    if (lum < lumThreshold02)
    {
        if (mod(gl_FragCoord .x - gl_FragCoord .y, 10.0) == 0.0) tc = vec3(0.0, 0.0, 0.0);
    }

    if (lum < lumThreshold03)
    {
        if (mod(gl_FragCoord .x + gl_FragCoord .y - hatchOffsetY, 10.0) == 0.0) tc = vec3(0.0, 0.0, 0.0);
    }

    if (lum < lumThreshold04)
    {
        if (mod(gl_FragCoord .x - gl_FragCoord .y - hatchOffsetY, 10.0) == 0.0) tc = vec3(0.0, 0.0, 0.0);
    }

    gl_FragColor = vec4(tc, 1.0);
}# version 100

precision mediump float;

// Input vertex attributes (from vertex shader)
varying vec2 fragTexCoord;
varying vec4 fragColor;

// Input uniform values
uniform sampler2D texture0;
uniform vec4 colDiffuse;

// NOTE: Add here your custom variables

// NOTE: Render size values must be passed from code
const float renderWidth = 800.0;
const float renderHeight = 450.0;

float stitchingSize = 6.0;
int invert = 0;

vec4 PostFX(sampler2D tex, vec2 uv)
{
    vec4 c = vec4(0.0);
    float size = stitchingSize;
    vec2 cPos = uv * vec2(renderWidth, renderHeight);
    vec2 tlPos = floor(cPos / vec2(size, size));
    tlPos *= size;

    int remX = int(mod(cPos.x, size));
    int remY = int(mod(cPos.y, size));

    if (remX == 0 && remY == 0) tlPos = cPos;

    vec2 blPos = tlPos;
    blPos.y += (size - 1.0);

    if ((remX == remY) || (((int(cPos.x) - int(blPos.x)) == (int(blPos.y) - int(cPos.y)))))
    {
        if (invert == 1) c = vec4(0.2, 0.15, 0.05, 1.0);
        else c = texture2D(tex, tlPos * vec2(1.0/renderWidth, 1.0/renderHeight)) * 1.4;
    }
    else
    {
        if (invert == 1) c = texture2D(tex, tlPos * vec2(1.0/renderWidth, 1.0/renderHeight)) * 1.4;
        else c = vec4(0.0, 0.0, 0.0, 1.0);
    }

    return c;
}

void main()
{
    vec3 tc = PostFX(texture0, fragTexCoord).rgb;

    gl_FragColor = vec4(tc, 1.0);
}#version 100

precision mediump float;

// Input vertex attributes (from vertex shader)
varying vec2 fragTexCoord;
varying vec4 fragColor;

// Custom variables
const float PI = 3.14159265358979323846;
uniform float uTime;

float divisions = 5.0;
float angle = 0.0;

vec2 VectorRotateTime(vec2 v, float speed)
{
    float time = uTime*speed;
    float localTime = fract(time);  // The time domain this works on is 1 sec.

    if ((localTime >= 0.0) && (localTime < 0.25)) angle = 0.0;
    else if ((localTime >= 0.25) && (localTime < 0.50)) angle = PI/4.0*sin(2.0*PI*localTime - PI/2.0);
    else if ((localTime >= 0.50) && (localTime < 0.75)) angle = PI*0.25;
    else if ((localTime >= 0.75) && (localTime < 1.00)) angle = PI/4.0*sin(2.0*PI*localTime);

    // Rotate vector by angle
    v -= 0.5;
    v =  mat2(cos(angle), -sin(angle), sin(angle), cos(angle))*v;
    v += 0.5;

    return v;
}

float Rectangle(in vec2 st, in float size, in float fill)
{
  float roundSize = 0.5 - size/2.0;
  float left = step(roundSize, st.x);
  float top = step(roundSize, st.y);
  float bottom = step(roundSize, 1.0 - st.y);
  float right = step(roundSize, 1.0 - st.x);

  return (left*bottom*right*top)*fill;
}

void main()
{
    vec2 fragPos = fragTexCoord;
    fragPos.xy += uTime/9.0;

    fragPos *= divisions;
    vec2 ipos = floor(fragPos);  // Get the integer coords
    vec2 fpos = fract(fragPos);  // Get the fractional coords

    fpos = VectorRotateTime(fpos, 0.2);

    float alpha = Rectangle(fpos, 0.216, 1.0);
    vec3 color = vec3(0.3, 0.3, 0.3);

    gl_FragColor = vec4(color, alpha);
}#version 100

precision mediump float;

// Input vertex attributes (from vertex shader)
varying vec2 fragTexCoord;
varying vec4 fragColor;

// Input uniform values
uniform sampler2D texture0;     // Depth texture
uniform vec4 colDiffuse;

// NOTE: Add here your custom variables

void main()
{
    float zNear = 0.01; // camera z near
    float zFar = 10.0;  // camera z far
    float z = texture2D(texture0, fragTexCoord).x;

    // Linearize depth value
    float depth = (2.0*zNear)/(zFar + zNear - z*(zFar - zNear));

    // Calculate final fragment color
    gl_FragColor = vec4(depth, depth, depth, 1.0f);
}#version 100

precision mediump float;

// Input vertex attributes (from vertex shader)
varying vec2 fragTexCoord;

// Input uniform values
uniform sampler2D texture0;

// NOTE: Default parameters for Oculus Rift DK2 device
const vec2 LeftLensCenter = vec2(0.2863248, 0.5);
const vec2 RightLensCenter = vec2(0.7136753, 0.5);
const vec2 LeftScreenCenter = vec2(0.25, 0.5);
const vec2 RightScreenCenter = vec2(0.75, 0.5);
const vec2 Scale = vec2(0.25, 0.45);
const vec2 ScaleIn = vec2(4.0, 2.5);
const vec4 HmdWarpParam = vec4(1.0, 0.22, 0.24, 0.0);
const vec4 ChromaAbParam = vec4(0.996, -0.004, 1.014, 0.0);

void main()
{
    // The following two variables need to be set per eye
    vec2 LensCenter = fragTexCoord.x < 0.5 ? LeftLensCenter : RightLensCenter;
    vec2 ScreenCenter = fragTexCoord.x < 0.5 ? LeftScreenCenter : RightScreenCenter;

    // Scales input texture coordinates for distortion: vec2 HmdWarp(vec2 fragTexCoord, vec2 LensCenter)
    vec2 theta = (fragTexCoord - LensCenter)*ScaleIn;   // Scales to [-1, 1]
    float rSq = theta.x*theta.x + theta.y*theta.y;
    vec2 theta1 = theta*(HmdWarpParam.x + HmdWarpParam.y*rSq + HmdWarpParam.z*rSq*rSq + HmdWarpParam.w*rSq*rSq*rSq);
    //vec2 tc = LensCenter + Scale*theta1;

    // Detect whether blue texture coordinates are out of range since these will scaled out the furthest
    vec2 thetaBlue = theta1*(ChromaAbParam.z + ChromaAbParam.w*rSq);
    vec2 tcBlue = LensCenter + Scale*thetaBlue;

    if (any(bvec2(clamp(tcBlue, ScreenCenter - vec2(0.25, 0.5), ScreenCenter + vec2(0.25, 0.5)) - tcBlue))) gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
    else
    {
        // Do blue texture lookup
        float blue = texture2D(texture0, tcBlue).b;

        // Do green lookup (no scaling)
        vec2 tcGreen = LensCenter + Scale*theta1;
        float green = texture2D(texture0, tcGreen).g;

        // Do red scale and lookup
        vec2 thetaRed = theta1*(ChromaAbParam.x + ChromaAbParam.y*rSq);
        vec2 tcRed = LensCenter + Scale*thetaRed;
        float red = texture2D(texture0, tcRed).r;

        gl_FragColor = vec4(red, green, blue, 1.0);
    }
}
#version 100

precision mediump float;

// Input vertex attributes (from vertex shader)
varying vec2 fragTexCoord;
varying vec4 fragColor;

// Input uniform values
uniform sampler2D texture0;
uniform vec4 colDiffuse;

// NOTE: Add here your custom variables

void main()
{
    vec4 color = texture2D(texture0, fragTexCoord);

    color += texture2D(texture0, fragTexCoord + 0.001);
    color += texture2D(texture0, fragTexCoord + 0.003);
    color += texture2D(texture0, fragTexCoord + 0.005);
    color += texture2D(texture0, fragTexCoord + 0.007);
    color += texture2D(texture0, fragTexCoord + 0.009);
    color += texture2D(texture0, fragTexCoord + 0.011);

    color += texture2D(texture0, fragTexCoord - 0.001);
    color += texture2D(texture0, fragTexCoord - 0.003);
    color += texture2D(texture0, fragTexCoord - 0.005);
    color += texture2D(texture0, fragTexCoord - 0.007);
    color += texture2D(texture0, fragTexCoord - 0.009);
    color += texture2D(texture0, fragTexCoord - 0.011);

    color.rgb = vec3((color.r + color.g + color.b)/3.0);
    color = color/9.5;

    gl_FragColor = color;
}            #version 100

precision mediump float;

/*************************************************************************************

  The Sieve of Eratosthenes -- a simple shader by ProfJski
  An early prime number sieve: https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes

  The screen is divided into a square grid of boxes, each representing an integer value.
  Each integer is tested to see if it is a prime number.  Primes are colored white.
  Non-primes are colored with a color that indicates the smallest factor which evenly divdes our integer.

  You can change the scale variable to make a larger or smaller grid.
  Total number of integers displayed = scale squared, so scale = 100 tests the first 10,000 integers.

  WARNING: If you make scale too large, your GPU may bog down!

***************************************************************************************/

// Input vertex attributes (from vertex shader)
varying vec2 fragTexCoord;
varying vec4 fragColor;

// Make a nice spectrum of colors based on counter and maxSize
vec4 Colorizer(float counter, float maxSize)
{
    float red = 0.0, green = 0.0, blue = 0.0;
    float normsize = counter/maxSize;

    red = smoothstep(0.3, 0.7, normsize);
    green = sin(3.14159*normsize);
    blue = 1.0 - smoothstep(0.0, 0.4, normsize);

    return vec4(0.8*red, 0.8*green, 0.8*blue, 1.0);
}

void main()
{
    vec4 color = vec4(1.0);
    float scale = 1000.0; // Makes 100x100 square grid. Change this variable to make a smaller or larger grid.
    float value = scale*floor(fragTexCoord.y*scale) + floor(fragTexCoord.x*scale);  // Group pixels into boxes representing integer values
    int valuei = int(value);

    //if ((valuei == 0) || (valuei == 1) || (valuei == 2)) gl_FragColor = vec4(1.0);
    //else
    {
        //for (int i = 2; (i < int(max(2.0, sqrt(value) + 1.0))); i++)
        // NOTE: On GLSL 100 for loops are restricted and loop condition must be a constant
        // Tested on RPI, it seems loops are limited around 60 iteractions
        for (int i = 2; i < 48; i++)
        {
            if ((value - float(i)*floor(value/float(i))) <= 0.0)
            {
                gl_FragColor = Colorizer(float(i), scale);
                //break;    // Uncomment to color by the largest factor instead
            }
        }
    }
}
#version 100

precision mediump float;

// Input vertex attributes (from vertex shader)
varying vec2 fragTexCoord;
varying vec4 fragColor;

// Input uniform values
uniform sampler2D texture0;
uniform vec4 colDiffuse;

// NOTE: Add here your custom variables

const float PI = 3.1415926535;

void main()
{
    float aperture = 178.0;
    float apertureHalf = 0.5 * aperture * (PI / 180.0);
    float maxFactor = sin(apertureHalf);

    vec2 uv = vec2(0.0);
    vec2 xy = 2.0 * fragTexCoord.xy - 1.0;
    float d = length(xy);

    if (d < (2.0 - maxFactor))
    {
        d = length(xy * maxFactor);
        float z = sqrt(1.0 - d * d);
        float r = atan(d, z) / PI;
        float phi = atan(xy.y, xy.x);

        uv.x = r * cos(phi) + 0.5;
        uv.y = r * sin(phi) + 0.5;
    }
    else
    {
        uv = fragTexCoord.xy;
    }

    gl_FragColor = texture2D(texture0, uv);
}#version 100

precision mediump float;

// Input vertex attributes (from vertex shader)
varying vec3 fragPosition;
varying vec2 fragTexCoord;
varying vec4 fragColor;
varying vec3 fragNormal;

// Input uniform values
uniform sampler2D texture0;
uniform vec4 colDiffuse;

// NOTE: Add here your custom variables

#define     MAX_LIGHTS              4
#define     LIGHT_DIRECTIONAL       0
#define     LIGHT_POINT             1

struct MaterialProperty {
    vec3 color;
    int useSampler;
    sampler2D sampler;
};

struct Light {
    int enabled;
    int type;
    vec3 position;
    vec3 target;
    vec4 color;
};

// Input lighting values
uniform Light lights[MAX_LIGHTS];
uniform vec4 ambient;
uniform vec3 viewPos;
uniform float fogDensity;

void main()
{
    // Texel color fetching from texture sampler
    vec4 texelColor = texture2D(texture0, fragTexCoord);
    vec3 lightDot = vec3(0.0);
    vec3 normal = normalize(fragNormal);
    vec3 viewD = normalize(viewPos - fragPosition);
    vec3 specular = vec3(0.0);

    // NOTE: Implement here your fragment shader code

    for (int i = 0; i < MAX_LIGHTS; i++)
    {
        if (lights[i].enabled == 1)
        {
            vec3 light = vec3(0.0);

            if (lights[i].type == LIGHT_DIRECTIONAL) light = -normalize(lights[i].target - lights[i].position);
            if (lights[i].type == LIGHT_POINT) light = normalize(lights[i].position - fragPosition);

            float NdotL = max(dot(normal, light), 0.0);
            lightDot += lights[i].color.rgb*NdotL;

            float specCo = 0.0;
            if (NdotL > 0.0) specCo = pow(max(0.0, dot(viewD, reflect(-(light), normal))), 16.0); // Shine: 16.0
            specular += specCo;
        }
    }

    vec4 finalColor = (texelColor*((colDiffuse + vec4(specular,1))*vec4(lightDot, 1.0)));
    finalColor += texelColor*(ambient/10.0);

    // Gamma correction
    finalColor = pow(finalColor, vec4(1.0/2.2));

    // Fog calculation
    float dist = length(viewPos - fragPosition);

    // these could be parameters...
    const vec4 fogColor = vec4(0.5, 0.5, 0.5, 1.0);
    //const float fogDensity = 0.16;

    // Exponential fog
    float fogFactor = 1.0/exp((dist*fogDensity)*(dist*fogDensity));

    // Linear fog (less nice)
    //const float fogStart = 2.0;
    //const float fogEnd = 10.0;
    //float fogFactor = (fogEnd - dist)/(fogEnd - fogStart);

    fogFactor = clamp(fogFactor, 0.0, 1.0);

    gl_FragColor = mix(fogColor, finalColor, fogFactor);
}
#version 100

precision mediump float;

// Input vertex attributes (from vertex shader)
varying vec2 fragTexCoord;
varying vec4 fragColor;

// Input uniform values
uniform sampler2D texture0;
uniform vec4 colDiffuse;

// NOTE: Add here your custom variables

void main()
{
    // Texel color fetching from texture sampler
    vec4 texelColor = texture2D(texture0, fragTexCoord)*colDiffuse*fragColor;

    // Convert texel color to grayscale using NTSC conversion weights
    float gray = dot(texelColor.rgb, vec3(0.299, 0.587, 0.114));

    // Calculate final fragment color
    gl_FragColor = vec4(gray, gray, gray, texelColor.a);
}#version 100             
#extension GL_EXT_frag_depth : enable   // Extension required for writing depth         
precision mediump float;                // Precision required for OpenGL ES2 (WebGL)

varying vec2 fragTexCoord;
varying vec4 fragColor;

uniform sampler2D texture0;
uniform vec4 colDiffuse;

void main()
{
    vec4 texelColor = texture2D(texture0, fragTexCoord);
    gl_FragColor = texelColor*colDiffuse*fragColor;
	gl_FragDepthEXT = gl_FragCoord.z;
}#version 100             
#extension GL_EXT_frag_depth : enable           //Extension required for writing depth
#extension GL_OES_standard_derivatives : enable //Extension used for fwidth()
precision mediump float;                // Precision required for OpenGL ES2 (WebGL)


// Input vertex attributes (from vertex shader)
varying vec2 fragTexCoord;
varying vec4 fragColor;

// Input uniform values
uniform sampler2D texture0;
uniform vec4 colDiffuse;

// Custom Input Uniform
uniform vec3 camPos;
uniform vec3 camDir;
uniform vec2 screenCenter;

#define ZERO 0

// https://learnopengl.com/Advanced-OpenGL/Depth-testing
float CalcDepth(in vec3 rd, in float Idist){
    float local_z = dot(normalize(camDir),rd)*Idist;
    return (1.0/(local_z) - 1.0/0.01)/(1.0/1000.0 -1.0/0.01);
}

// https://iquilezles.org/articles/distfunctions/
float sdHorseshoe( in vec3 p, in vec2 c, in float r, in float le, vec2 w )
{
    p.x = abs(p.x);
    float l = length(p.xy);
    p.xy = mat2(-c.x, c.y, 
              c.y, c.x)*p.xy;
    p.xy = vec2((p.y>0.0 || p.x>0.0)?p.x:l*sign(-c.x),
                (p.x>0.0)?p.y:l );
    p.xy = vec2(p.x,abs(p.y-r))-vec2(le,0.0);
    
    vec2 q = vec2(length(max(p.xy,0.0)) + min(0.0,max(p.x,p.y)),p.z);
    vec2 d = abs(q) - w;
    return min(max(d.x,d.y),0.0) + length(max(d,0.0));
}

// r = sphere's radius
// h = cutting's plane's position
// t = thickness
float sdSixWayCutHollowSphere( vec3 p, float r, float h, float t )
{
    // Six way symetry Transformation
    vec3 ap = abs(p);
    if(ap.x < max(ap.y, ap.z)){
        if(ap.y < ap.z) ap.xz = ap.zx;
        else ap.xy = ap.yx;
    }

    vec2 q = vec2( length(ap.yz), ap.x );
    
    float w = sqrt(r*r-h*h);
    
    return ((h*q.x<w*q.y) ? length(q-vec2(w,h)) : 
                            abs(length(q)-r) ) - t;
}

// https://iquilezles.org/articles/boxfunctions
vec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) 
{
    vec3 m = 1.0/rd;
    vec3 n = m*ro;
    vec3 k = abs(m)*rad;
    vec3 t1 = -n - k;
    vec3 t2 = -n + k;
	return vec2( max( max( t1.x, t1.y ), t1.z ),
	             min( min( t2.x, t2.y ), t2.z ) );
}

vec2 opU( vec2 d1, vec2 d2 )
{
	return (d1.x<d2.x) ? d1 : d2;
}

vec2 map( in vec3 pos ){
    vec2 res = vec2( sdHorseshoe(  pos-vec3(-1.0,0.08, 1.0), vec2(cos(1.3),sin(1.3)), 0.2, 0.3, vec2(0.03,0.5) ), 11.5 ) ;
    res = opU(res, vec2( sdSixWayCutHollowSphere(  pos-vec3(0.0, 1.0, 0.0), 4.0, 3.5, 0.5 ), 4.5 )) ;
    return res;
}

// https://www.shadertoy.com/view/Xds3zN
vec2 raycast( in vec3 ro, in vec3 rd ){
    vec2 res = vec2(-1.0,-1.0);

    float tmin = 1.0;
    float tmax = 20.0;

    // raytrace floor plane
    float tp1 = (-ro.y)/rd.y;
    if( tp1>0.0 )
    {
        tmax = min( tmax, tp1 );
        res = vec2( tp1, 1.0 );
    }

    float t = tmin;
    for( int i=0; i<70 ; i++ )
    {
        if(t>tmax) break;
        vec2 h = map( ro+rd*t );
        if( abs(h.x)<(0.0001*t) )
        { 
            res = vec2(t,h.y); 
            break;
        }
        t += h.x;
    }

    return res;
}


// https://iquilezles.org/articles/rmshadows
float calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )
{
    // bounding volume
    float tp = (0.8-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );

    float res = 1.0;
    float t = mint;
    for( int i=ZERO; i<24; i++ )
    {
		float h = map( ro + rd*t ).x;
        float s = clamp(8.0*h/t,0.0,1.0);
        res = min( res, s );
        t += clamp( h, 0.01, 0.2 );
        if( res<0.004 || t>tmax ) break;
    }
    res = clamp( res, 0.0, 1.0 );
    return res*res*(3.0-2.0*res);
}


// https://iquilezles.org/articles/normalsSDF
vec3 calcNormal( in vec3 pos )
{
    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;
    return normalize( e.xyy*map( pos + e.xyy ).x + 
					  e.yyx*map( pos + e.yyx ).x + 
					  e.yxy*map( pos + e.yxy ).x + 
					  e.xxx*map( pos + e.xxx ).x );
}

// https://iquilezles.org/articles/nvscene2008/rwwtt.pdf
float calcAO( in vec3 pos, in vec3 nor )
{
	float occ = 0.0;
    float sca = 1.0;
    for( int i=ZERO; i<5; i++ )
    {
        float h = 0.01 + 0.12*float(i)/4.0;
        float d = map( pos + h*nor ).x;
        occ += (h-d)*sca;
        sca *= 0.95;
        if( occ>0.35 ) break;
    }
    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);
}

// https://iquilezles.org/articles/checkerfiltering
float checkersGradBox( in vec2 p )
{
    // filter kernel
    vec2 w = fwidth(p) + 0.001;
    // analytical integral (box filter)
    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;
    // xor pattern
    return 0.5 - 0.5*i.x*i.y;                  
}

// https://www.shadertoy.com/view/tdS3DG
vec4 render( in vec3 ro, in vec3 rd)
{ 
    // background
    vec3 col = vec3(0.7, 0.7, 0.9) - max(rd.y,0.0)*0.3;
    
    // raycast scene
    vec2 res = raycast(ro,rd);
    float t = res.x;
	float m = res.y;
    if( m>-0.5 )
    {
        vec3 pos = ro + t*rd;
        vec3 nor = (m<1.5) ? vec3(0.0,1.0,0.0) : calcNormal( pos );
        vec3 ref = reflect( rd, nor );
        
        // material        
        col = 0.2 + 0.2*sin( m*2.0 + vec3(0.0,1.0,2.0) );
        float ks = 1.0;
        
        if( m<1.5 )
        {
            float f = checkersGradBox( 3.0*pos.xz);
            col = 0.15 + f*vec3(0.05);
            ks = 0.4;
        }

        // lighting
        float occ = calcAO( pos, nor );
        
		vec3 lin = vec3(0.0);

        // sun
        {
            vec3  lig = normalize( vec3(-0.5, 0.4, -0.6) );
            vec3  hal = normalize( lig-rd );
            float dif = clamp( dot( nor, lig ), 0.0, 1.0 );
          //if( dif>0.0001 )
        	      dif *= calcSoftshadow( pos, lig, 0.02, 2.5 );
			float spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0);
                  spe *= dif;
                  spe *= 0.04+0.96*pow(clamp(1.0-dot(hal,lig),0.0,1.0),5.0);
                //spe *= 0.04+0.96*pow(clamp(1.0-sqrt(0.5*(1.0-dot(rd,lig))),0.0,1.0),5.0);
            lin += col*2.20*dif*vec3(1.30,1.00,0.70);
            lin +=     5.00*spe*vec3(1.30,1.00,0.70)*ks;
        }
        // sky
        {
            float dif = sqrt(clamp( 0.5+0.5*nor.y, 0.0, 1.0 ));
                  dif *= occ;
            float spe = smoothstep( -0.2, 0.2, ref.y );
                  spe *= dif;
                  spe *= 0.04+0.96*pow(clamp(1.0+dot(nor,rd),0.0,1.0), 5.0 );
          //if( spe>0.001 )
                  spe *= calcSoftshadow( pos, ref, 0.02, 2.5 );
            lin += col*0.60*dif*vec3(0.40,0.60,1.15);
            lin +=     2.00*spe*vec3(0.40,0.60,1.30)*ks;
        }
        // back
        {
        	float dif = clamp( dot( nor, normalize(vec3(0.5,0.0,0.6))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);
                  dif *= occ;
        	lin += col*0.55*dif*vec3(0.25,0.25,0.25);
        }
        // sss
        {
            float dif = pow(clamp(1.0+dot(nor,rd),0.0,1.0),2.0);
                  dif *= occ;
        	lin += col*0.25*dif*vec3(1.00,1.00,1.00);
        }
        
		col = lin;

        col = mix( col, vec3(0.7,0.7,0.9), 1.0-exp( -0.0001*t*t*t ) );
    }

	return vec4(vec3( clamp(col,0.0,1.0) ),t);
}

vec3 CalcRayDir(vec2 nCoord){
    vec3 horizontal = normalize(cross(camDir,vec3(.0 , 1.0, .0)));
    vec3 vertical   = normalize(cross(horizontal,camDir));
    return normalize(camDir + horizontal*nCoord.x + vertical*nCoord.y);
}

mat3 setCamera()
{
	vec3 cw = normalize(camDir);
	vec3 cp = vec3(0.0, 1.0 ,0.0);
	vec3 cu = normalize( cross(cw,cp) );
	vec3 cv =          ( cross(cu,cw) );
    return mat3( cu, cv, cw );
}

void main()
{
    vec2 nCoord = (gl_FragCoord.xy - screenCenter.xy)/screenCenter.y;
    mat3 ca = setCamera();

    // focal length
    float fl = length(camDir);
    vec3 rd = ca * normalize( vec3(nCoord,fl) );
    vec3 color = vec3(nCoord/2.0 + 0.5, 0.0);
    float depth = gl_FragCoord.z;
    {
        vec4 res = render( camPos - vec3(0.0, 0.0, 0.0) , rd );
        color = res.xyz;
        depth = CalcDepth(rd,res.w);
    }
    gl_FragColor = vec4(color , 1.0);
	gl_FragDepthEXT = depth;
}#version 100

precision mediump float;

// Input vertex attributes (from vertex shader)
varying vec2 fragTexCoord;
varying vec4 fragColor;

uniform vec2 c;                 // c.x = real, c.y = imaginary component. Equation done is z^2 + c
uniform vec2 offset;            // Offset of the scale.
uniform float zoom;             // Zoom of the scale.

// NOTE: Maximum number of shader for-loop iterations depend on GPU,
// for example, on RasperryPi for this examply only supports up to 60
const int maxIterations = 48;     // Max iterations to do.
const float colorCycles = 1.0f;   // Number of times the color palette repeats.

// Square a complex number
vec2 ComplexSquare(vec2 z)
{
    return vec2(
        z.x*z.x - z.y*z.y,
        z.x*z.y*2.0f
    );
}

// Convert Hue Saturation Value (HSV) color into RGB
vec3 Hsv2rgb(vec3 c)
{
    vec4 K = vec4(1.0f, 2.0f/3.0f, 1.0f/3.0f, 3.0f);
    vec3 p = abs(fract(c.xxx + K.xyz)*6.0f - K.www);
    return c.z*mix(K.xxx, clamp(p - K.xxx, 0.0f, 1.0f), c.y);
}

void main()
{
    /**********************************************************************************************
      Julia sets use a function z^2 + c, where c is a constant.
      This function is iterated until the nature of the point is determined.

      If the magnitude of the number becomes greater than 2, then from that point onward
      the number will get bigger and bigger, and will never get smaller (tends towards infinity).
      2^2 = 4, 4^2 = 8 and so on.
      So at 2 we stop iterating.

      If the number is below 2, we keep iterating.
      But when do we stop iterating if the number is always below 2 (it converges)?
      That is what maxIterations is for.
      Then we can divide the iterations by the maxIterations value to get a normalized value that we can
      then map to a color.

      We use dot product (z.x * z.x + z.y * z.y) to determine the magnitude (length) squared.
      And once the magnitude squared is > 4, then magnitude > 2 is also true (saves computational power).
    *************************************************************************************************/

    // The pixel coordinates are scaled so they are on the mandelbrot scale
    // NOTE: fragTexCoord already comes as normalized screen coordinates but offset must be normalized before scaling and zoom
    vec2 z = vec2((fragTexCoord.x - 0.5f)*2.5f, (fragTexCoord.y - 0.5f)*1.5f)/zoom;
    z.x += offset.x;
    z.y += offset.y;

    int iter = 0;
    for (int iterations = 0; iterations < 60; iterations++)
    {
        z = ComplexSquare(z) + c;  // Iterate function
        if (dot(z, z) > 4.0f) break;

        iter = iterations;
    }

    // Another few iterations decreases errors in the smoothing calculation.
    // See http://linas.org/art-gallery/escape/escape.html for more information.
    z = ComplexSquare(z) + c;
    z = ComplexSquare(z) + c;

    // This last part smooths the color (again see link above).
    float smoothVal = float(iter) + 1.0f - (log(log(length(z)))/log(2.0f));

    // Normalize the value so it is between 0 and 1.
    float norm = smoothVal/float(maxIterations);

    // If in set, color black. 0.999 allows for some float accuracy error.
    if (norm > 0.999f) gl_FragColor = vec4(0.0f, 0.0f, 0.0f, 1.0f);
    else gl_FragColor = vec4(Hsv2rgb(vec3(norm*colorCycles, 1.0f, 1.0f)), 1.0f);
}
#version 100

precision mediump float;

// Input vertex attributes (from vertex shader)
varying vec3 fragPosition;
varying vec2 fragTexCoord;
varying vec4 fragColor;
varying vec3 fragNormal;

// Input uniform values
uniform sampler2D texture0;
uniform vec4 colDiffuse;

// NOTE: Add here your custom variables

#define     MAX_LIGHTS              4
#define     LIGHT_DIRECTIONAL       0
#define     LIGHT_POINT             1

struct Light {
    int enabled;
    int type;
    vec3 position;
    vec3 target;
    vec4 color;
};

// Input lighting values
uniform Light lights[MAX_LIGHTS];
uniform vec4 ambient;
uniform vec3 viewPos;

void main()
{
    // Texel color fetching from texture sampler
    vec4 texelColor = texture2D(texture0, fragTexCoord);
    vec3 lightDot = vec3(0.0);
    vec3 normal = normalize(fragNormal);
    vec3 viewD = normalize(viewPos - fragPosition);
    vec3 specular = vec3(0.0);

    vec4 tint = colDiffuse * fragColor;

    // NOTE: Implement here your fragment shader code

    for (int i = 0; i < MAX_LIGHTS; i++)
    {
        if (lights[i].enabled == 1)
        {
            vec3 light = vec3(0.0);

            if (lights[i].type == LIGHT_DIRECTIONAL)
            {
                light = -normalize(lights[i].target - lights[i].position);
            }

            if (lights[i].type == LIGHT_POINT)
            {
                light = normalize(lights[i].position - fragPosition);
            }

            float NdotL = max(dot(normal, light), 0.0);
            lightDot += lights[i].color.rgb*NdotL;

            float specCo = 0.0;
            if (NdotL > 0.0) specCo = pow(max(0.0, dot(viewD, reflect(-(light), normal))), 16.0); // 16 refers to shine
            specular += specCo;
        }
    }

    vec4 finalColor = (texelColor*((tint + vec4(specular, 1.0))*vec4(lightDot, 1.0)));
    finalColor += texelColor*(ambient/10.0);

    // Gamma correction
    gl_FragColor = pow(finalColor, vec4(1.0/2.2));
}
#version 100

// Input vertex attributes
attribute vec3 vertexPosition;
attribute vec2 vertexTexCoord;
attribute vec3 vertexNormal;
attribute vec4 vertexColor;

// Input uniform values
uniform mat4 mvp;
uniform mat4 matModel;

// Output vertex attributes (to fragment shader)
varying vec3 fragPosition;
varying vec2 fragTexCoord;
varying vec4 fragColor;
varying vec3 fragNormal;

// NOTE: Add here your custom variables

// https://github.com/glslify/glsl-inverse
mat3 inverse(mat3 m)
{
  float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2];
  float a10 = m[1][0], a11 = m[1][1], a12 = m[1][2];
  float a20 = m[2][0], a21 = m[2][1], a22 = m[2][2];

  float b01 = a22*a11 - a12*a21;
  float b11 = -a22*a10 + a12*a20;
  float b21 = a21*a10 - a11*a20;

  float det = a00*b01 + a01*b11 + a02*b21;

  return mat3(b01, (-a22*a01 + a02*a21), (a12*a01 - a02*a11),
              b11, (a22*a00 - a02*a20), (-a12*a00 + a02*a10),
              b21, (-a21*a00 + a01*a20), (a11*a00 - a01*a10))/det;
}

// https://github.com/glslify/glsl-transpose
mat3 transpose(mat3 m)
{
  return mat3(m[0][0], m[1][0], m[2][0],
              m[0][1], m[1][1], m[2][1],
              m[0][2], m[1][2], m[2][2]);
}

void main()
{
    // Send vertex attributes to fragment shader
    fragPosition = vec3(matModel*vec4(vertexPosition, 1.0));
    fragTexCoord = vertexTexCoord;
    fragColor = vertexColor;

    mat3 normalMatrix = transpose(inverse(mat3(matModel)));
    fragNormal = normalize(normalMatrix*vertexNormal);

    // Calculate final vertex position
    gl_Position = mvp*vec4(vertexPosition, 1.0);
}
#version 100

// Input vertex attributes
attribute vec3 vertexPosition;
attribute vec2 vertexTexCoord;
attribute vec3 vertexNormal;
attribute vec4 vertexColor;

attribute mat4 instanceTransform;

// Input uniform values
uniform mat4 mvp;
uniform mat4 matNormal;

// Output vertex attributes (to fragment shader)
varying vec3 fragPosition;
varying vec2 fragTexCoord;
varying vec4 fragColor;
varying vec3 fragNormal;

// NOTE: Add here your custom variables

void main()
{
    // Compute MVP for current instance
    mat4 mvpi = mvp*instanceTransform;

    // Send vertex attributes to fragment shader
    fragPosition = vec3(mvpi*vec4(vertexPosition, 1.0));
    fragTexCoord = vertexTexCoord;
    fragColor = vertexColor;
    fragNormal = normalize(vec3(matNormal*vec4(vertexNormal, 1.0)));

    // Calculate final vertex position
    gl_Position = mvpi*vec4(vertexPosition, 1.0);
}
#version 100

precision mediump float;

// Input vertex attributes (from vertex shader)
varying vec2 fragTexCoord;
varying vec2 fragTexCoord2;
varying vec3 fragPosition;
varying vec4 fragColor;

// Input uniform values
uniform sampler2D texture0;
uniform sampler2D texture1;

void main()
{
    // Texel color fetching from texture sampler
    vec4 texelColor = texture2D(texture0, fragTexCoord);
    vec4 texelColor2 = texture2D(texture1, fragTexCoord2);

    gl_FragColor = texelColor * texelColor2;
}
#version 100

// Input vertex attributes
attribute vec3 vertexPosition;
attribute vec2 vertexTexCoord;
attribute vec2 vertexTexCoord2;
attribute vec4 vertexColor;

// Input uniform values
uniform mat4 mvp;
uniform mat4 matModel;

// Output vertex attributes (to fragment shader)
varying vec3 fragPosition;
varying vec2 fragTexCoord;
varying vec2 fragTexCoord2;
varying vec4 fragColor;

// NOTE: Add here your custom variables

void main()
{
    // Send vertex attributes to fragment shader
    fragPosition = vec3(matModel*vec4(vertexPosition, 1.0));
    fragTexCoord = vertexTexCoord;
    fragTexCoord2 = vertexTexCoord2;
    fragColor = vertexColor;

    // Calculate final vertex position
    gl_Position = mvp*vec4(vertexPosition, 1.0);
}
#version 100

precision mediump float;

// Input vertex attributes (from vertex shader)
varying vec2 fragTexCoord;
varying vec4 fragColor;

// Input uniform values
uniform sampler2D texture0;
uniform sampler2D mask;
uniform vec4 colDiffuse;
uniform int frame;

// NOTE: Add here your custom variables

void main()
{
    vec4 maskColour = texture2D(mask, fragTexCoord + vec2(sin(-float(frame)/150.0)/10.0, cos(-float(frame)/170.0)/10.0));
    if (maskColour.r < 0.25) discard;
    vec4 texelColor = texture2D(texture0, fragTexCoord + vec2(sin(float(frame)/90.0)/8.0, cos(float(frame)/60.0)/8.0));

    gl_FragColor = texelColor*maskColour;
}
#version 100

precision mediump float;

// Input vertex attributes (from vertex shader)
varying vec2 fragTexCoord;
varying vec4 fragColor;

// Input uniform values
uniform sampler2D texture0;
uniform vec4 colDiffuse;

uniform vec2 textureSize;
uniform float outlineSize;
uniform vec4 outlineColor;

void main()
{
    vec4 texel = texture2D(texture0, fragTexCoord);   // Get texel color
    vec2 texelScale = vec2(0.0);
    texelScale.x = outlineSize/textureSize.x;
    texelScale.y = outlineSize/textureSize.y;

    // We sample four corner texels, but only for the alpha channel (this is for the outline)
    vec4 corners = vec4(0.0);
    corners.x = texture2D(texture0, fragTexCoord + vec2(texelScale.x, texelScale.y)).a;
    corners.y = texture2D(texture0, fragTexCoord + vec2(texelScale.x, -texelScale.y)).a;
    corners.z = texture2D(texture0, fragTexCoord + vec2(-texelScale.x, texelScale.y)).a;
    corners.w = texture2D(texture0, fragTexCoord + vec2(-texelScale.x, -texelScale.y)).a;

    float outline = min(dot(corners, vec4(1.0)), 1.0);
    vec4 color = mix(vec4(0.0), outlineColor, outline);
    gl_FragColor = mix(color, texel, texel.a);
}#version 100

precision mediump float;

const int MAX_INDEXED_COLORS = 8;

// Input vertex attributes (from vertex shader)
varying vec2 fragTexCoord;
varying vec4 fragColor;

// Input uniform values
uniform sampler2D texture0;
uniform ivec3 palette[MAX_INDEXED_COLORS];
//uniform sampler2D palette; // Alternative to ivec3, palette provided as a 256x1 texture

void main()
{
    // Texel color fetching from texture sampler
    vec4 texelColor = texture2D(texture0, fragTexCoord)*fragColor;

    // Convert the (normalized) texel color RED component (GB would work, too)
    // to the palette index by scaling up from [0..1] to [0..255]
    int index = int(texelColor.r*255.0);
    
    ivec3 color = ivec3(0);

    // NOTE: On GLSL 100 we are not allowed to index a uniform array by a variable value,
    // a constant must be used, so this logic...
    if (index == 0) color = palette[0];
    else if (index == 1) color = palette[1];
    else if (index == 2) color = palette[2];
    else if (index == 3) color = palette[3];
    else if (index == 4) color = palette[4];
    else if (index == 5) color = palette[5];
    else if (index == 6) color = palette[6];
    else if (index == 7) color = palette[7];
    
    //gl_FragColor = texture2D(palette, texelColor.xy); // Alternative to ivec3

    // Calculate final fragment color. Note that the palette color components
    // are defined in the range [0..255] and need to be normalized to [0..1]
    gl_FragColor = vec4(float(color.x)/255.0, float(color.y)/255.0, float(color.z)/255.0, texelColor.a);
}
#version 100

precision highp float;

#define MAX_LIGHTS              4
#define LIGHT_DIRECTIONAL       0
#define LIGHT_POINT             1
#define PI 3.14159265358979323846

struct Light {
    int enabled;
    int type;
    vec3 position;
    vec3 target;
    vec4 color;
    float intensity;
};

// Input vertex attributes (from vertex shader)
varying vec3 fragPosition;
varying vec2 fragTexCoord;
varying vec4 fragColor;
varying vec3 fragNormal;
varying vec4 shadowPos;
varying mat3 TBN;

// Input uniform values
uniform int numOfLights;
uniform sampler2D albedoMap;
uniform sampler2D mraMap;
uniform sampler2D normalMap;
uniform sampler2D emissiveMap; // r: Hight g:emissive

uniform vec2 tiling;
uniform vec2 offset;

uniform int useTexAlbedo;
uniform int useTexNormal;
uniform int useTexMRA;
uniform int useTexEmissive;

uniform vec4  albedoColor;
uniform vec4  emissiveColor;
uniform float normalValue;
uniform float metallicValue;
uniform float roughnessValue;
uniform float aoValue;
uniform float emissivePower;

// Input lighting values
uniform Light lights[MAX_LIGHTS];
uniform vec3 viewPos;

uniform vec3 ambientColor;
uniform float ambient;

// refl in range  0 to 1
// returns base reflectivity to 1
// incrase reflectivity when surface view at larger angle
vec3 schlickFresnel(float hDotV,vec3 refl)
{
        return refl + (1.0 - refl) * pow(1.0 - hDotV,5.0);
}

float ggxDistribution(float nDotH,float roughness)
{
        float a = roughness * roughness * roughness * roughness;
        float d = nDotH * nDotH * (a - 1.0) + 1.0;
        d = PI * d * d;
        return a / max(d,0.0000001);
}

float geomSmith(float nDotV,float nDotL,float roughness)
{
        float r = roughness + 1.0;
        float k = r * r / 8.0;
        float ik = 1.0 - k;
        float ggx1 = nDotV / (nDotV * ik + k);
        float ggx2 = nDotL / (nDotL * ik + k);
        return ggx1 * ggx2;
}

vec3 pbr(){
        vec3 albedo = texture2D(albedoMap,vec2(fragTexCoord.x*tiling.x+offset.x,fragTexCoord.y*tiling.y+offset.y)).rgb;
        albedo = vec3(albedoColor.x*albedo.x,albedoColor.y*albedo.y,albedoColor.z*albedo.z);
        float metallic = clamp(metallicValue,0.0,1.0);
        float roughness = clamp(roughnessValue,0.0,1.0);
        float ao = clamp(aoValue,0.0,1.0);
        if(useTexMRA == 1) {
            vec4 mra = texture2D(mraMap, vec2(fragTexCoord.x * tiling.x + offset.x, fragTexCoord.y * tiling.y + offset.y));
            metallic = clamp(mra.r+metallicValue,0.04,1.0);
            roughness = clamp(mra.g+roughnessValue,0.04,1.0);
            ao = (mra.b+aoValue)*0.5;
        }



        vec3 N = normalize(fragNormal);
        if(useTexNormal == 1) {
            N = texture2D(normalMap, vec2(fragTexCoord.x * tiling.x + offset.y, fragTexCoord.y * tiling.y + offset.y)).rgb;
            N = normalize(N * 2.0 - 1.0);
            N = normalize(N * TBN);
        }
        
        vec3 V = normalize(viewPos - fragPosition);
        
        vec3 e = vec3(0);
        e = (texture2D(emissiveMap, vec2(fragTexCoord.x*tiling.x+offset.x, fragTexCoord.y*tiling.y+offset.y)).rgb).g * emissiveColor.rgb*emissivePower * float(useTexEmissive);
        
        //return N;//vec3(metallic,metallic,metallic);
        //if  dia-electric use base reflectivity of 0.04 otherwise ut is a metal use albedo as base reflectivity
        vec3 baseRefl = mix(vec3(0.04),albedo.rgb,metallic);
        vec3 Lo = vec3(0.0);  // acumulate lighting lum

        for(int i=0;i<4;++i){

            vec3 L = normalize(lights[i].position - fragPosition);  // calc light vector
            vec3 H = normalize(V + L);                              // calc halfway bisecting vector
            float dist = length(lights[i].position - fragPosition); // calc distance to light
            float attenuation = 1.0 / (dist * dist * 0.23);                // calc attenuation
            vec3 radiance = lights[i].color.rgb * lights[i].intensity * attenuation;         // calc input radiance,light energy comming in

            //Cook-Torrance BRDF distribution function
            float nDotV = max(dot(N,V),0.0000001);
            float nDotL = max(dot(N,L),0.0000001);
            float hDotV = max(dot(H,V),0.0);
            float nDotH = max(dot(N,H),0.0);
            float D = ggxDistribution(nDotH,roughness); // larger the more micro-facets aligned to H
            float G = geomSmith(nDotV,nDotL,roughness); // smaller the more micro-facets shadow
            vec3 F = schlickFresnel(hDotV, baseRefl);  // fresnel proportion of specular reflectance

            vec3 spec = (D * G * F) / (4.0 * nDotV * nDotL);
            // difuse and spec light can't be above 1.0
            // kD = 1.0 - kS  diffuse component is equal 1.0 - spec comonent
            vec3 kD = vec3(1.0) - F;
            //mult kD by the inverse of metallnes , only non-metals should have diffuse light
            kD *= 1.0 - metallic;
            Lo += ((kD * albedo.rgb / PI + spec) * radiance * nDotL)*float(lights[i].enabled); // angle of light has impact on result
        }
        vec3 ambient_final = (ambientColor + albedo)* ambient * 0.5;
        return ambient_final+Lo*ao+e;
}

void main()
{
       vec3 color = pbr();
        
        //HDR tonemapping
        color = pow(color,color + vec3(1.0));
        //gamma correction
        color = pow(color,vec3(1.0/2.2));

        gl_FragColor = vec4(color,1.0);
        
}
#version 100

// Input vertex attributes
attribute vec3 vertexPosition;
attribute vec2 vertexTexCoord;
attribute vec3 vertexNormal;
attribute vec3 vertexTangent;
attribute vec4 vertexColor;

// Input uniform values
uniform mat4 mvp;
uniform mat4 matModel;
uniform mat4 matNormal;
uniform vec3 lightPos;
uniform vec4 difColor;

// Output vertex attributes (to fragment shader)
varying vec3 fragPosition;
varying vec2 fragTexCoord;
varying vec4 fragColor;
varying vec3 fragNormal;
varying mat3 TBN;

const float normalOffset = 0.1;

// https://github.com/glslify/glsl-inverse
mat3 inverse(mat3 m)
{
  float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2];
  float a10 = m[1][0], a11 = m[1][1], a12 = m[1][2];
  float a20 = m[2][0], a21 = m[2][1], a22 = m[2][2];

  float b01 = a22*a11 - a12*a21;
  float b11 = -a22*a10 + a12*a20;
  float b21 = a21*a10 - a11*a20;

  float det = a00*b01 + a01*b11 + a02*b21;

  return mat3(b01, (-a22*a01 + a02*a21), (a12*a01 - a02*a11),
              b11, (a22*a00 - a02*a20), (-a12*a00 + a02*a10),
              b21, (-a21*a00 + a01*a20), (a11*a00 - a01*a10))/det;
}

// https://github.com/glslify/glsl-transpose
mat3 transpose(mat3 m)
{
  return mat3(m[0][0], m[1][0], m[2][0],
              m[0][1], m[1][1], m[2][1],
              m[0][2], m[1][2], m[2][2]);
}

void main()
{

    // calc binormal from vertex normal and tangent
    vec3 vertexBinormal = cross(vertexNormal, vertexTangent);
    // calc fragment normal based on normal transformations
    mat3 normalMatrix = transpose(inverse(mat3(matModel)));
    // calc fragment position based on model transformations

    fragPosition = vec3(matModel*vec4(vertexPosition, 1.0));

    fragTexCoord = vertexTexCoord*2.0;

    fragNormal = normalize(normalMatrix*vertexNormal);
    vec3 fragTangent = normalize(normalMatrix*vertexTangent);
    fragTangent = normalize(fragTangent - dot(fragTangent, fragNormal)*fragNormal);
    vec3 fragBinormal = normalize(normalMatrix*vertexBinormal);
    fragBinormal = cross(fragNormal, fragTangent);

    TBN = transpose(mat3(fragTangent, fragBinormal, fragNormal));

    // Calculate final vertex position
    gl_Position = mvp * vec4(vertexPosition, 1.0);
}
#version 100

precision mediump float;

// Input vertex attributes (from vertex shader)
varying vec2 fragTexCoord;
varying vec4 fragColor;

// Input uniform values
uniform sampler2D texture0;
uniform vec4 colDiffuse;

// NOTE: Add here your custom variables

// NOTE: Render size values must be passed from code
const float renderWidth = 800.0;
const float renderHeight = 450.0;

float pixelWidth = 5.0;
float pixelHeight = 5.0;

void main()
{
    float dx = pixelWidth*(1.0/renderWidth);
    float dy = pixelHeight*(1.0/renderHeight);

    vec2 coord = vec2(dx*floor(fragTexCoord.x/dx), dy*floor(fragTexCoord.y/dy));

    vec3 tc = texture2D(texture0, coord).rgb;

    gl_FragColor = vec4(tc, 1.0);
}#version 100

precision mediump float;

// Input vertex attributes (from vertex shader)
varying vec2 fragTexCoord;
varying vec4 fragColor;

// Input uniform values
uniform sampler2D texture0;
uniform vec4 colDiffuse;

// NOTE: Add here your custom variables

float gamma = 0.6;
float numColors = 8.0;

void main()
{
    vec3 color = texture2D(texture0, fragTexCoord.xy).rgb;

    color = pow(color, vec3(gamma, gamma, gamma));
    color = color*numColors;
    color = floor(color);
    color = color/numColors;
    color = pow(color, vec3(1.0/gamma));

    gl_FragColor = vec4(color, 1.0);
}#version 100

precision mediump float;

// Input vertex attributes (from vertex shader)
varying vec2 fragTexCoord;
varying vec4 fragColor;

// Input uniform values
uniform sampler2D texture0;
uniform vec4 colDiffuse;

// NOTE: Add here your custom variables

void main()
{
    vec3 color = texture2D(texture0, fragTexCoord).rgb;
    vec3 colors[3];
    colors[0] = vec3(0.0, 0.0, 1.0);
    colors[1] = vec3(1.0, 1.0, 0.0);
    colors[2] = vec3(1.0, 0.0, 0.0);

    float lum = (color.r + color.g + color.b)/3.0;

    vec3 tc = vec3(0.0, 0.0, 0.0);

    if (lum < 0.5) tc = mix(colors[0], colors[1], lum/0.5);
    else tc = mix(colors[1], colors[2], (lum - 0.5)/0.5);

    gl_FragColor = vec4(tc, 1.0);
}#version 100

precision mediump float;

#extension GL_OES_standard_derivatives : enable

// Input vertex attributes (from vertex shader)
varying vec2 fragTexCoord;
varying vec4 fragColor;

uniform vec3 viewEye;
uniform vec3 viewCenter;
uniform float runTime;
uniform vec2 resolution;

// The MIT License
// Copyright  2013 Inigo Quilez
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

// A list of useful distance function to simple primitives, and an example on how to
// do some interesting boolean operations, repetition and displacement.
//
// More info here: http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm

#define AA 1   // make this 1 if your machine is too slow

//------------------------------------------------------------------

float sdPlane( vec3 p )
{
    return p.y;
}

float sdSphere( vec3 p, float s )
{
    return length(p)-s;
}

float sdBox( vec3 p, vec3 b )
{
    vec3 d = abs(p) - b;
    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));
}

float sdEllipsoid( in vec3 p, in vec3 r )
{
    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);
}

float udRoundBox( vec3 p, vec3 b, float r )
{
    return length(max(abs(p)-b,0.0))-r;
}

float sdTorus( vec3 p, vec2 t )
{
    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;
}

float sdHexPrism( vec3 p, vec2 h )
{
    vec3 q = abs(p);
#if 0
    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);
#else
    float d1 = q.z-h.y;
    float d2 = max((q.x*0.866025+q.y*0.5),q.y)-h.x;
    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);
#endif
}

float sdCapsule( vec3 p, vec3 a, vec3 b, float r )
{
    vec3 pa = p-a, ba = b-a;
    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );
    return length( pa - ba*h ) - r;
}

float sdEquilateralTriangle(  in vec2 p )
{
    const float k = sqrt(3.0);
    p.x = abs(p.x) - 1.0;
    p.y = p.y + 1.0/k;
    if( p.x + k*p.y > 0.0 ) p = vec2( p.x - k*p.y, -k*p.x - p.y )/2.0;
    p.x += 2.0 - 2.0*clamp( (p.x+2.0)/2.0, 0.0, 1.0 );
    return -length(p)*sign(p.y);
}

float sdTriPrism( vec3 p, vec2 h )
{
    vec3 q = abs(p);
    float d1 = q.z-h.y;
#if 1
    // distance bound
    float d2 = max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5;
#else
    // correct distance
    h.x *= 0.866025;
    float d2 = sdEquilateralTriangle(p.xy/h.x)*h.x;
#endif
    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);
}

float sdCylinder( vec3 p, vec2 h )
{
  vec2 d = abs(vec2(length(p.xz),p.y)) - h;
  return min(max(d.x,d.y),0.0) + length(max(d,0.0));
}

float sdCone( in vec3 p, in vec3 c )
{
    vec2 q = vec2( length(p.xz), p.y );
    float d1 = -q.y-c.z;
    float d2 = max( dot(q,c.xy), q.y);
    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);
}

float sdConeSection( in vec3 p, in float h, in float r1, in float r2 )
{
    float d1 = -p.y - h;
    float q = p.y - h;
    float si = 0.5*(r1-r2)/h;
    float d2 = max( sqrt( dot(p.xz,p.xz)*(1.0-si*si)) + q*si - r2, q );
    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);
}

float sdPryamid4(vec3 p, vec3 h ) // h = { cos a, sin a, height }
{
    // Tetrahedron = Octahedron - Cube
    float box = sdBox( p - vec3(0,-2.0*h.z,0), vec3(2.0*h.z) );

    float d = 0.0;
    d = max( d, abs( dot(p, vec3( -h.x, h.y, 0 )) ));
    d = max( d, abs( dot(p, vec3(  h.x, h.y, 0 )) ));
    d = max( d, abs( dot(p, vec3(  0, h.y, h.x )) ));
    d = max( d, abs( dot(p, vec3(  0, h.y,-h.x )) ));
    float octa = d - h.z;
    return max(-box,octa); // Subtraction
 }

float length2( vec2 p )
{
    return sqrt( p.x*p.x + p.y*p.y );
}

float length6( vec2 p )
{
    p = p*p*p; p = p*p;
    return pow( p.x + p.y, 1.0/6.0 );
}

float length8( vec2 p )
{
    p = p*p; p = p*p; p = p*p;
    return pow( p.x + p.y, 1.0/8.0 );
}

float sdTorus82( vec3 p, vec2 t )
{
    vec2 q = vec2(length2(p.xz)-t.x,p.y);
    return length8(q)-t.y;
}

float sdTorus88( vec3 p, vec2 t )
{
    vec2 q = vec2(length8(p.xz)-t.x,p.y);
    return length8(q)-t.y;
}

float sdCylinder6( vec3 p, vec2 h )
{
    return max( length6(p.xz)-h.x, abs(p.y)-h.y );
}

//------------------------------------------------------------------

float opS( float d1, float d2 )
{
    return max(-d2,d1);
}

vec2 opU( vec2 d1, vec2 d2 )
{
    return (d1.x<d2.x) ? d1 : d2;
}

vec3 opRep( vec3 p, vec3 c )
{
    return mod(p,c)-0.5*c;
}

vec3 opTwist( vec3 p )
{
    float  c = cos(10.0*p.y+10.0);
    float  s = sin(10.0*p.y+10.0);
    mat2   m = mat2(c,-s,s,c);
    return vec3(m*p.xz,p.y);
}

//------------------------------------------------------------------

vec2 map( in vec3 pos )
{
    vec2 res = opU( vec2( sdPlane(     pos), 1.0 ),
                    vec2( sdSphere(    pos-vec3( 0.0,0.25, 0.0), 0.25 ), 46.9 ) );
    res = opU( res, vec2( sdBox(       pos-vec3( 1.0,0.25, 0.0), vec3(0.25) ), 3.0 ) );
    res = opU( res, vec2( udRoundBox(  pos-vec3( 1.0,0.25, 1.0), vec3(0.15), 0.1 ), 41.0 ) );
    res = opU( res, vec2( sdTorus(     pos-vec3( 0.0,0.25, 1.0), vec2(0.20,0.05) ), 25.0 ) );
    res = opU( res, vec2( sdCapsule(   pos,vec3(-1.3,0.10,-0.1), vec3(-0.8,0.50,0.2), 0.1  ), 31.9 ) );
    res = opU( res, vec2( sdTriPrism(  pos-vec3(-1.0,0.25,-1.0), vec2(0.25,0.05) ),43.5 ) );
    res = opU( res, vec2( sdCylinder(  pos-vec3( 1.0,0.30,-1.0), vec2(0.1,0.2) ), 8.0 ) );
    res = opU( res, vec2( sdCone(      pos-vec3( 0.0,0.50,-1.0), vec3(0.8,0.6,0.3) ), 55.0 ) );
    res = opU( res, vec2( sdTorus82(   pos-vec3( 0.0,0.25, 2.0), vec2(0.20,0.05) ),50.0 ) );
    res = opU( res, vec2( sdTorus88(   pos-vec3(-1.0,0.25, 2.0), vec2(0.20,0.05) ),43.0 ) );
    res = opU( res, vec2( sdCylinder6( pos-vec3( 1.0,0.30, 2.0), vec2(0.1,0.2) ), 12.0 ) );
    res = opU( res, vec2( sdHexPrism(  pos-vec3(-1.0,0.20, 1.0), vec2(0.25,0.05) ),17.0 ) );
    res = opU( res, vec2( sdPryamid4(  pos-vec3(-1.0,0.15,-2.0), vec3(0.8,0.6,0.25) ),37.0 ) );
    res = opU( res, vec2( opS( udRoundBox(  pos-vec3(-2.0,0.2, 1.0), vec3(0.15),0.05),
                               sdSphere(    pos-vec3(-2.0,0.2, 1.0), 0.25)), 13.0 ) );
    res = opU( res, vec2( opS( sdTorus82(  pos-vec3(-2.0,0.2, 0.0), vec2(0.20,0.1)),
                               sdCylinder(  opRep( vec3(atan(pos.x+2.0,pos.z)/6.2831, pos.y, 0.02+0.5*length(pos-vec3(-2.0,0.2, 0.0))), vec3(0.05,1.0,0.05)), vec2(0.02,0.6))), 51.0 ) );
    res = opU( res, vec2( 0.5*sdSphere(    pos-vec3(-2.0,0.25,-1.0), 0.2 ) + 0.03*sin(50.0*pos.x)*sin(50.0*pos.y)*sin(50.0*pos.z), 65.0 ) );
    res = opU( res, vec2( 0.5*sdTorus( opTwist(pos-vec3(-2.0,0.25, 2.0)),vec2(0.20,0.05)), 46.7 ) );
    res = opU( res, vec2( sdConeSection( pos-vec3( 0.0,0.35,-2.0), 0.15, 0.2, 0.1 ), 13.67 ) );
    res = opU( res, vec2( sdEllipsoid( pos-vec3( 1.0,0.35,-2.0), vec3(0.15, 0.2, 0.05) ), 43.17 ) );

    return res;
}

vec2 castRay( in vec3 ro, in vec3 rd )
{
    float tmin = 0.2;
    float tmax = 30.0;

#if 1
    // bounding volume
    float tp1 = (0.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );
    float tp2 = (1.6-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>1.6 ) tmin = max( tmin, tp2 );
                                                 else           tmax = min( tmax, tp2 ); }
#endif

    float t = tmin;
    float m = -1.0;
    for( int i=0; i<64; i++ )
    {
        float precis = 0.0005*t;
        vec2 res = map( ro+rd*t );
        if( res.x<precis || t>tmax ) break;
        t += res.x;
        m = res.y;
    }

    if( t>tmax ) m=-1.0;
    return vec2( t, m );
}


float calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )
{
    float res = 1.0;
    float t = mint;
    for( int i=0; i<16; i++ )
    {
        float h = map( ro + rd*t ).x;
        res = min( res, 8.0*h/t );
        t += clamp( h, 0.02, 0.10 );
        if( h<0.001 || t>tmax ) break;
    }
    return clamp( res, 0.0, 1.0 );
}

vec3 calcNormal( in vec3 pos )
{
    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;
    return normalize( e.xyy*map( pos + e.xyy ).x +
                      e.yyx*map( pos + e.yyx ).x +
                      e.yxy*map( pos + e.yxy ).x +
                      e.xxx*map( pos + e.xxx ).x );
    /*
    vec3 eps = vec3( 0.0005, 0.0, 0.0 );
    vec3 nor = vec3(
        map(pos+eps.xyy).x - map(pos-eps.xyy).x,
        map(pos+eps.yxy).x - map(pos-eps.yxy).x,
        map(pos+eps.yyx).x - map(pos-eps.yyx).x );
    return normalize(nor);
    */
}

float calcAO( in vec3 pos, in vec3 nor )
{
    float occ = 0.0;
    float sca = 1.0;
    for( int i=0; i<5; i++ )
    {
        float hr = 0.01 + 0.12*float(i)/4.0;
        vec3 aopos =  nor * hr + pos;
        float dd = map( aopos ).x;
        occ += -(dd-hr)*sca;
        sca *= 0.95;
    }
    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );
}

// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm
float checkersGradBox( in vec2 p )
{
    // filter kernel
    vec2 w = fwidth(p) + 0.001;
    // analytical integral (box filter)
    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;
    // xor pattern
    return 0.5 - 0.5*i.x*i.y;
}

vec3 render( in vec3 ro, in vec3 rd )
{
    vec3 col = vec3(0.7, 0.9, 1.0) +rd.y*0.8;
    vec2 res = castRay(ro,rd);
    float t = res.x;
    float m = res.y;
    if( m>-0.5 )
    {
        vec3 pos = ro + t*rd;
        vec3 nor = calcNormal( pos );
        vec3 ref = reflect( rd, nor );

        // material
        col = 0.45 + 0.35*sin( vec3(0.05,0.08,0.10)*(m-1.0) );
        if( m<1.5 )
        {

            float f = checkersGradBox( 5.0*pos.xz );
            col = 0.3 + f*vec3(0.1);
        }

        // lighting
        float occ = calcAO( pos, nor );
        vec3  lig = normalize( vec3(cos(-0.4 * runTime), sin(0.7 * runTime), -0.6) );
        vec3  hal = normalize( lig-rd );
        float amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );
        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );
        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);
        float dom = smoothstep( -0.1, 0.1, ref.y );
        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );

        dif *= calcSoftshadow( pos, lig, 0.02, 2.5 );
        dom *= calcSoftshadow( pos, ref, 0.02, 2.5 );

        float spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0)*
                    dif *
                    (0.04 + 0.96*pow( clamp(1.0+dot(hal,rd),0.0,1.0), 5.0 ));

        vec3 lin = vec3(0.0);
        lin += 1.30*dif*vec3(1.00,0.80,0.55);
        lin += 0.40*amb*vec3(0.40,0.60,1.00)*occ;
        lin += 0.50*dom*vec3(0.40,0.60,1.00)*occ;
        lin += 0.50*bac*vec3(0.25,0.25,0.25)*occ;
        lin += 0.25*fre*vec3(1.00,1.00,1.00)*occ;
        col = col*lin;
        col += 10.00*spe*vec3(1.00,0.90,0.70);

        col = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.0002*t*t*t ) );
    }

    return vec3( clamp(col,0.0,1.0) );
}

mat3 setCamera( in vec3 ro, in vec3 ta, float cr )
{
    vec3 cw = normalize(ta-ro);
    vec3 cp = vec3(sin(cr), cos(cr),0.0);
    vec3 cu = normalize( cross(cw,cp) );
    vec3 cv = normalize( cross(cu,cw) );
    return mat3( cu, cv, cw );
}

void main()
{
    vec3 tot = vec3(0.0);
#if AA>1
    for( int m=0; m<AA; m++ )
    for( int n=0; n<AA; n++ )
    {
        // pixel coordinates
        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;
        vec2 p = (-resolution.xy + 2.0*(gl_FragCoord.xy+o))/resolution.y;
#else
        vec2 p = (-resolution.xy + 2.0*gl_FragCoord.xy)/resolution.y;
#endif

        // RAY: Camera is provided from raylib
        //vec3 ro = vec3( -0.5+3.5*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, 0.5 + 4.0*sin(0.1*time + 6.0*mo.x) );

        vec3 ro = viewEye;
        vec3 ta = viewCenter;

        // camera-to-world transformation
        mat3 ca = setCamera( ro, ta, 0.0 );
        // ray direction
        vec3 rd = ca * normalize( vec3(p.xy,2.0) );

        // render
        vec3 col = render( ro, rd );

        // gamma
        col = pow( col, vec3(0.4545) );

        tot += col;
#if AA>1
    }
    tot /= float(AA*AA);
#endif

    gl_FragColor = vec4( tot, 1.0 );
}
#version 100

precision mediump float;

// Input vertex attributes (from vertex shader)
varying vec2 fragTexCoord;           // Texture coordinates (sampler2D)
varying vec4 fragColor;              // Tint color

// Uniform inputs
uniform vec2 resolution;        // Viewport resolution (in pixels)
uniform vec2 mouse;             // Mouse pixel xy coordinates
uniform float time;             // Total run time (in secods)

// Draw circle
vec4 DrawCircle(vec2 fragCoord, vec2 position, float radius, vec3 color)
{
    float d = length(position - fragCoord) - radius;
    float t = clamp(d, 0.0, 1.0);
    return vec4(color, 1.0 - t);
}

void main()
{
    vec2 fragCoord = gl_FragCoord.xy;
    vec2 position = vec2(mouse.x, resolution.y - mouse.y);
    float radius = 40.0;

    // Draw background layer
    vec4 colorA = vec4(0.2,0.2,0.8, 1.0);
    vec4 colorB = vec4(1.0,0.7,0.2, 1.0);
    vec4 layer1 = mix(colorA, colorB, abs(sin(time*0.1)));

    // Draw circle layer
    vec3 color = vec3(0.9, 0.16, 0.21);
    vec4 layer2 = DrawCircle(fragCoord, position, radius, color);

    // Blend the two layers
    gl_FragColor = mix(layer1, layer2, layer2.a);
}
#version 100

precision mediump float;

// Input vertex attributes (from vertex shader)
varying vec2 fragTexCoord;
varying vec4 fragColor;

// Input uniform values
uniform sampler2D texture0;
uniform vec4 colDiffuse;

// NOTE: Add here your custom variables

float offset = 0.0;
float frequency = 450.0/3.0;

uniform float time;

void main()
{
/*
    // Scanlines method 1
    float tval = 0; //time
    vec2 uv = 0.5 + (fragTexCoord - 0.5)*(0.9 + 0.01*sin(0.5*tval));

    vec4 color = texture2D(texture0, fragTexCoord);

    color = clamp(color*0.5 + 0.5*color*color*1.2, 0.0, 1.0);
    color *= 0.5 + 0.5*16.0*uv.x*uv.y*(1.0 - uv.x)*(1.0 - uv.y);
    color *= vec4(0.8, 1.0, 0.7, 1);
    color *= 0.9 + 0.1*sin(10.0*tval + uv.y*1000.0);
    color *= 0.97 + 0.03*sin(110.0*tval);

    fragColor = color;
*/
    // Scanlines method 2
    float globalPos = (fragTexCoord.y + offset) * frequency;
    float wavePos = cos((fract(globalPos) - 0.5)*3.14);

    vec4 color = texture2D(texture0, fragTexCoord);

    gl_FragColor = mix(vec4(0.0, 0.3, 0.0, 0.0), color, wavePos);
}#version 100

precision mediump float;

// Input vertex attributes (from vertex shader)
varying vec2 fragTexCoord;
varying vec4 fragColor;

// Input uniform values
uniform sampler2D texture0;
uniform vec4 colDiffuse;

// NOTE: Add here your custom variables
vec2 resolution = vec2(800.0, 450.0);

void main()
{
    float x = 1.0/resolution.x;
    float y = 1.0/resolution.y;

    vec4 horizEdge = vec4(0.0);
    horizEdge -= texture2D(texture0, vec2(fragTexCoord.x - x, fragTexCoord.y - y))*1.0;
    horizEdge -= texture2D(texture0, vec2(fragTexCoord.x - x, fragTexCoord.y    ))*2.0;
    horizEdge -= texture2D(texture0, vec2(fragTexCoord.x - x, fragTexCoord.y + y))*1.0;
    horizEdge += texture2D(texture0, vec2(fragTexCoord.x + x, fragTexCoord.y - y))*1.0;
    horizEdge += texture2D(texture0, vec2(fragTexCoord.x + x, fragTexCoord.y    ))*2.0;
    horizEdge += texture2D(texture0, vec2(fragTexCoord.x + x, fragTexCoord.y + y))*1.0;

    vec4 vertEdge = vec4(0.0);
    vertEdge -= texture2D(texture0, vec2(fragTexCoord.x - x, fragTexCoord.y - y))*1.0;
    vertEdge -= texture2D(texture0, vec2(fragTexCoord.x    , fragTexCoord.y - y))*2.0;
    vertEdge -= texture2D(texture0, vec2(fragTexCoord.x + x, fragTexCoord.y - y))*1.0;
    vertEdge += texture2D(texture0, vec2(fragTexCoord.x - x, fragTexCoord.y + y))*1.0;
    vertEdge += texture2D(texture0, vec2(fragTexCoord.x    , fragTexCoord.y + y))*2.0;
    vertEdge += texture2D(texture0, vec2(fragTexCoord.x + x, fragTexCoord.y + y))*1.0;

    vec3 edge = sqrt((horizEdge.rgb*horizEdge.rgb) + (vertEdge.rgb*vertEdge.rgb));

    gl_FragColor = vec4(edge, texture2D(texture0, fragTexCoord).a);
}#version 100

precision mediump float;

#define MAX_SPOTS   3

struct Spot {
    vec2 pos;        // window coords of spot
    float inner;    // inner fully transparent centre radius
    float radius;    // alpha fades out to this radius
};

uniform Spot spots[MAX_SPOTS];  // Spotlight positions array
uniform float screenWidth;      // Width of the screen

void main()
{
    float alpha = 1.0;

    // Get the position of the current fragment (screen coordinates!)
    vec2 pos = vec2(gl_FragCoord.x, gl_FragCoord.y);

    // Find out which spotlight is nearest
    float d = 65000.0;  // some high value
    int fi = -1;        // found index

    for (int i = 0; i < MAX_SPOTS; i++)
    {
        for (int j = 0; j < MAX_SPOTS; j++)
        {
            float dj = distance(pos, spots[j].pos) - spots[j].radius + spots[i].radius;

            if (d > dj)
            {
                d = dj;
                fi = i;
            }
        }
    }

    // d now equals distance to nearest spot...
    // allowing for the different radii of all spotlights
    if (fi == 0)
    {
        if (d > spots[0].radius) alpha = 1.0;
        else
        {
            if (d < spots[0].inner) alpha = 0.0;
            else alpha = (d - spots[0].inner)/(spots[0].radius - spots[0].inner);
        }
    }
    else if (fi == 1)
    {
        if (d > spots[1].radius) alpha = 1.0;
        else
        {
            if (d < spots[1].inner) alpha = 0.0;
            else alpha = (d - spots[1].inner)/(spots[1].radius - spots[1].inner);
        }
    }
    else if (fi == 2)
    {
        if (d > spots[2].radius) alpha = 1.0;
        else
        {
            if (d < spots[2].inner) alpha = 0.0;
            else alpha = (d - spots[2].inner)/(spots[2].radius - spots[2].inner);
        }
    }

    // Right hand side of screen is dimly lit,
    // could make the threshold value user definable
    if ((pos.x > screenWidth/2.0) && (alpha > 0.9)) alpha = 0.9;

    // could make the black out colour user definable...
    gl_FragColor = vec4(0, 0, 0, alpha);
}
#version 100

precision mediump float;

// Input vertex attributes (from vertex shader)
varying vec2 fragTexCoord;
varying vec4 fragColor;

// Input uniform values
uniform sampler2D texture0;
uniform vec4 colDiffuse;

// NOTE: Add here your custom variables

// NOTE: Render size values should be passed from code
const float renderWidth = 800.0;
const float renderHeight = 450.0;

float radius = 250.0;
float angle = 0.8;

uniform vec2 center;

void main()
{
    vec2 texSize = vec2(renderWidth, renderHeight);
    vec2 tc = fragTexCoord*texSize;
    tc -= center;

    float dist = length(tc);

    if (dist < radius)
    {
        float percent = (radius - dist)/radius;
        float theta = percent*percent*angle*8.0;
        float s = sin(theta);
        float c = cos(theta);

        tc = vec2(dot(tc, vec2(c, -s)), dot(tc, vec2(s, c)));
    }

    tc += center;
    vec4 color = texture2D(texture0, tc/texSize)*colDiffuse*fragColor;;

    gl_FragColor = vec4(color.rgb, 1.0);
}
#version 100

precision mediump float;

// Input vertex attributes (from vertex shader)
varying vec2 fragTexCoord;
varying vec4 fragColor;

// Input uniform values
uniform sampler2D diffuseMap;
uniform vec4 tiling;

// NOTE: Add here your custom variables

void main()
{
    vec2 texCoord = fragTexCoord*tiling;
    fragColor = texture2D(diffuseMap, texCoord);
    
    gl_FragColor = fragColor;
}
#version 100

precision mediump float;

// Input vertex attributes (from fragment shader)
varying vec2 fragTexCoord;
varying float height;


void main()
{
    vec4 darkblue = vec4(0.0, 0.13, 0.18, 1.0);
    vec4 lightblue = vec4(1.0, 1.0, 1.0, 1.0);
    // Interpolate between two colors based on height
    vec4 finalColor = mix(darkblue, lightblue, height);

    gl_FragColor = finalColor;
}#version 100

precision mediump float;

attribute vec3 vertexPosition;
attribute vec2 vertexTexCoord;
attribute vec3 vertexNormal;
attribute vec4 vertexColor;

uniform mat4 mvp;
uniform mat4 matModel;
uniform mat4 matNormal;

uniform float time;

uniform sampler2D perlinNoiseMap;

varying vec3 fragPosition;
varying vec2 fragTexCoord;
varying vec3 fragNormal;
varying float height;

void main()
{
    // Calculate animated texture coordinates based on time and vertex position
    vec2 animatedTexCoord = sin(vertexTexCoord + vec2(sin(time + vertexPosition.x * 0.1), cos(time + vertexPosition.z * 0.1)) * 0.3);

    // Normalize animated texture coordinates to range [0, 1]
    animatedTexCoord = animatedTexCoord * 0.5 + 0.5;

    // Fetch displacement from the perlin noise map
    float displacement = texture2D(perlinNoiseMap, animatedTexCoord).r * 7.0; // Amplified displacement

    // Displace vertex position
    vec3 displacedPosition = vertexPosition + vec3(0.0, displacement, 0.0);

    // Send vertex attributes to fragment shader
    fragPosition = vec3(matModel * vec4(displacedPosition, 1.0));
    fragTexCoord = vertexTexCoord;
    fragNormal = normalize(vec3(matNormal * vec4(vertexNormal, 1.0)));
    height = displacedPosition.y * 0.2; // send height to fragment shader for coloring

    // Calculate final vertex position
    gl_Position = mvp * vec4(displacedPosition, 1.0);
}
#version 100

precision mediump float;

// Input vertex attributes (from vertex shader)
varying vec2 fragTexCoord;
varying vec4 fragColor;

// Input uniform values
uniform sampler2D texture0;
uniform vec4 colDiffuse;

uniform float seconds;

uniform vec2 size;

uniform float freqX;
uniform float freqY;
uniform float ampX;
uniform float ampY;
uniform float speedX;
uniform float speedY;

void main() {
    float pixelWidth = 1.0 / size.x;
    float pixelHeight = 1.0 / size.y;
    float aspect = pixelHeight / pixelWidth;
    float boxLeft = 0.0;
    float boxTop = 0.0;

    vec2 p = fragTexCoord;
    p.x += cos((fragTexCoord.y - boxTop) * freqX / ( pixelWidth * 750.0) + (seconds * speedX)) * ampX * pixelWidth;
    p.y += sin((fragTexCoord.x - boxLeft) * freqY * aspect / ( pixelHeight * 750.0) + (seconds * speedY)) * ampY * pixelHeight;

    gl_FragColor = texture2D(texture0, p)*colDiffuse*fragColor;
}
#version 100             
#extension GL_EXT_frag_depth : enable          
precision mediump float;                // Precision required for OpenGL ES2 (WebGL)

varying vec2 fragTexCoord;
varying vec4 fragColor;

uniform sampler2D texture0;
uniform vec4 colDiffuse;

void main()
{
    vec4 texelColor = texture2D(texture0, fragTexCoord);
    
    gl_FragColor = texelColor*colDiffuse*fragColor;
    gl_FragDepthEXT = 1.0 - gl_FragCoord.z;
}#version 120

// Input vertex attributes (from vertex shader)
varying vec2 fragTexCoord;
varying vec4 fragColor;

// Input uniform values
uniform sampler2D texture0;
uniform vec4 colDiffuse;

// NOTE: Add here your custom variables
uniform vec2 resolution = vec2(800, 450);

void main()
{
    // Texel color fetching from texture sampler
    vec4 texelColor = texture2D(texture0, fragTexCoord);

    // NOTE: Implement here your fragment shader code

    gl_FragColor = texelColor*colDiffuse;
}#version 120

// Input vertex attributes
attribute vec3 vertexPosition;
attribute vec2 vertexTexCoord;
attribute vec3 vertexNormal;
attribute vec4 vertexColor;

// Input uniform values
uniform mat4 mvp;

// Output vertex attributes (to fragment shader)
varying vec2 fragTexCoord;
varying vec4 fragColor;

// NOTE: Add here your custom variables

void main()
{
    // Send vertex attributes to fragment shader
    fragTexCoord = vertexTexCoord;
    fragColor = vertexColor;

    // Calculate final vertex position
    gl_Position = mvp*vec4(vertexPosition, 1.0);
}#version 120

// Input vertex attributes (from vertex shader)
varying vec2 fragTexCoord;
varying vec4 fragColor;

// Input uniform values
uniform sampler2D texture0;
uniform vec4 colDiffuse;

// NOTE: Add here your custom variables

const vec2 size = vec2(800, 450);   // Framebuffer size
const float samples = 5.0;          // Pixels per axis; higher = bigger glow, worse performance
const float quality = 2.5;          // Defines size factor: Lower = smaller glow, better quality

void main()
{
    vec4 sum = vec4(0);
    vec2 sizeFactor = vec2(1)/size*quality;

    // Texel color fetching from texture sampler
    vec4 source = texture2D(texture0, fragTexCoord);

    const int range = 2;            // should be = (samples - 1)/2;

    for (int x = -range; x <= range; x++)
    {
        for (int y = -range; y <= range; y++)
        {
            sum += texture2D(texture0, fragTexCoord + vec2(x, y)*sizeFactor);
        }
    }

    // Calculate final fragment color
    gl_FragColor = ((sum/(samples*samples)) + source)*colDiffuse;
}#version 120

// Input vertex attributes (from vertex shader)
varying vec2 fragTexCoord;
varying vec4 fragColor;

// Input uniform values
uniform sampler2D texture0;
uniform vec4 colDiffuse;

// NOTE: Add here your custom variables

// NOTE: Render size values must be passed from code
const float renderWidth = 800.0;
const float renderHeight = 450.0;

vec3 offset = vec3(0.0, 1.3846153846, 3.2307692308);
vec3 weight = vec3(0.2270270270, 0.3162162162, 0.0702702703);

void main()
{
    // Texel color fetching from texture sampler
    vec3 tc = texture2D(texture0, fragTexCoord).rgb*weight.x;

    tc += texture2D(texture0, fragTexCoord + vec2(offset.y)/renderWidth, 0.0).rgb*weight.y;
    tc += texture2D(texture0, fragTexCoord - vec2(offset.y)/renderWidth, 0.0).rgb*weight.y;

    tc += texture2D(texture0, fragTexCoord + vec2(offset.z)/renderWidth, 0.0).rgb*weight.z;
    tc += texture2D(texture0, fragTexCoord - vec2(offset.z)/renderWidth, 0.0).rgb*weight.z;

    gl_FragColor = vec4(tc, 1.0);
}# version 120

// Input vertex attributes (from vertex shader)
varying vec2 fragTexCoord;
varying vec4 fragColor;

// Input uniform values
uniform sampler2D texture0;
uniform vec4 colDiffuse;

// NOTE: Add here your custom variables

float hatchOffsetY = 5.0;
float lumThreshold01 = 0.9;
float lumThreshold02 = 0.7;
float lumThreshold03 = 0.5;
float lumThreshold04 = 0.3;

void main()
{
    vec3 tc = vec3(1.0, 1.0, 1.0);
    float lum = length(texture2D(texture0, fragTexCoord).rgb);

    if (lum < lumThreshold01)
    {
        if (mod(gl_FragCoord.x + gl_FragCoord.y, 10.0) == 0.0) tc = vec3(0.0, 0.0, 0.0);
    }

    if (lum < lumThreshold02)
    {
        if (mod(gl_FragCoord .x - gl_FragCoord .y, 10.0) == 0.0) tc = vec3(0.0, 0.0, 0.0);
    }

    if (lum < lumThreshold03)
    {
        if (mod(gl_FragCoord .x + gl_FragCoord .y - hatchOffsetY, 10.0) == 0.0) tc = vec3(0.0, 0.0, 0.0);
    }

    if (lum < lumThreshold04)
    {
        if (mod(gl_FragCoord .x - gl_FragCoord .y - hatchOffsetY, 10.0) == 0.0) tc = vec3(0.0, 0.0, 0.0);
    }

    gl_FragColor = vec4(tc, 1.0);
}# version 120

// Input vertex attributes (from vertex shader)
varying vec2 fragTexCoord;
varying vec4 fragColor;

// Input uniform values
uniform sampler2D texture0;
uniform vec4 colDiffuse;

// NOTE: Add here your custom variables

// NOTE: Render size values must be passed from code
const float renderWidth = 800.0;
const float renderHeight = 450.0;

float stitchingSize = 6.0;
int invert = 0;

vec4 PostFX(sampler2D tex, vec2 uv)
{
    vec4 c = vec4(0.0);
    float size = stitchingSize;
    vec2 cPos = uv * vec2(renderWidth, renderHeight);
    vec2 tlPos = floor(cPos / vec2(size, size));
    tlPos *= size;

    int remX = int(mod(cPos.x, size));
    int remY = int(mod(cPos.y, size));

    if (remX == 0 && remY == 0) tlPos = cPos;

    vec2 blPos = tlPos;
    blPos.y += (size - 1.0);

    if ((remX == remY) || (((int(cPos.x) - int(blPos.x)) == (int(blPos.y) - int(cPos.y)))))
    {
        if (invert == 1) c = vec4(0.2, 0.15, 0.05, 1.0);
        else c = texture2D(tex, tlPos * vec2(1.0/renderWidth, 1.0/renderHeight)) * 1.4;
    }
    else
    {
        if (invert == 1) c = texture2D(tex, tlPos * vec2(1.0/renderWidth, 1.0/renderHeight)) * 1.4;
        else c = vec4(0.0, 0.0, 0.0, 1.0);
    }

    return c;
}

void main()
{
    vec3 tc = PostFX(texture0, fragTexCoord).rgb;

    gl_FragColor = vec4(tc, 1.0);
}#version 120

// Input vertex attributes (from vertex shader)
varying vec2 fragTexCoord;

// Input uniform values
uniform sampler2D texture0;

// NOTE: Default parameters for Oculus Rift DK2 device
const vec2 LeftLensCenter = vec2(0.2863248, 0.5);
const vec2 RightLensCenter = vec2(0.7136753, 0.5);
const vec2 LeftScreenCenter = vec2(0.25, 0.5);
const vec2 RightScreenCenter = vec2(0.75, 0.5);
const vec2 Scale = vec2(0.25, 0.45);
const vec2 ScaleIn = vec2(4.0, 2.5);
const vec4 HmdWarpParam = vec4(1.0, 0.22, 0.24, 0.0);
const vec4 ChromaAbParam = vec4(0.996, -0.004, 1.014, 0.0);

void main()
{
    // The following two variables need to be set per eye
    vec2 LensCenter = fragTexCoord.x < 0.5 ? LeftLensCenter : RightLensCenter;
    vec2 ScreenCenter = fragTexCoord.x < 0.5 ? LeftScreenCenter : RightScreenCenter;

    // Scales input texture coordinates for distortion: vec2 HmdWarp(vec2 fragTexCoord, vec2 LensCenter)
    vec2 theta = (fragTexCoord - LensCenter)*ScaleIn;   // Scales to [-1, 1]
    float rSq = theta.x*theta.x + theta.y*theta.y;
    vec2 theta1 = theta*(HmdWarpParam.x + HmdWarpParam.y*rSq + HmdWarpParam.z*rSq*rSq + HmdWarpParam.w*rSq*rSq*rSq);
    //vec2 tc = LensCenter + Scale*theta1;

    // Detect whether blue texture coordinates are out of range since these will scaled out the furthest
    vec2 thetaBlue = theta1*(ChromaAbParam.z + ChromaAbParam.w*rSq);
    vec2 tcBlue = LensCenter + Scale*thetaBlue;

    if (any(bvec2(clamp(tcBlue, ScreenCenter - vec2(0.25, 0.5), ScreenCenter + vec2(0.25, 0.5)) - tcBlue))) gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
    else
    {
        // Do blue texture lookup
        float blue = texture2D(texture0, tcBlue).b;

        // Do green lookup (no scaling)
        vec2 tcGreen = LensCenter + Scale*theta1;
        float green = texture2D(texture0, tcGreen).g;

        // Do red scale and lookup
        vec2 thetaRed = theta1*(ChromaAbParam.x + ChromaAbParam.y*rSq);
        vec2 tcRed = LensCenter + Scale*thetaRed;
        float red = texture2D(texture0, tcRed).r;

        gl_FragColor = vec4(red, green, blue, 1.0);
    }
}
#version 120

// Input vertex attributes (from vertex shader)
varying vec2 fragTexCoord;
varying vec4 fragColor;

// Input uniform values
uniform sampler2D texture0;
uniform vec4 colDiffuse;

// NOTE: Add here your custom variables

void main()
{
    vec4 color = texture2D(texture0, fragTexCoord);

    color += texture2D(texture0, fragTexCoord + 0.001);
    color += texture2D(texture0, fragTexCoord + 0.003);
    color += texture2D(texture0, fragTexCoord + 0.005);
    color += texture2D(texture0, fragTexCoord + 0.007);
    color += texture2D(texture0, fragTexCoord + 0.009);
    color += texture2D(texture0, fragTexCoord + 0.011);

    color += texture2D(texture0, fragTexCoord - 0.001);
    color += texture2D(texture0, fragTexCoord - 0.003);
    color += texture2D(texture0, fragTexCoord - 0.005);
    color += texture2D(texture0, fragTexCoord - 0.007);
    color += texture2D(texture0, fragTexCoord - 0.009);
    color += texture2D(texture0, fragTexCoord - 0.011);

    color.rgb = vec3((color.r + color.g + color.b)/3.0);
    color = color/9.5;

    gl_FragColor = color;
}            #version 120

// Input vertex attributes (from vertex shader)
varying vec2 fragTexCoord;
varying vec4 fragColor;

// Input uniform values
uniform sampler2D texture0;
uniform vec4 colDiffuse;

// NOTE: Add here your custom variables

const float PI = 3.1415926535;

void main()
{
    float aperture = 178.0;
    float apertureHalf = 0.5 * aperture * (PI / 180.0);
    float maxFactor = sin(apertureHalf);

    vec2 uv = vec2(0.0);
    vec2 xy = 2.0 * fragTexCoord.xy - 1.0;
    float d = length(xy);

    if (d < (2.0 - maxFactor))
    {
        d = length(xy * maxFactor);
        float z = sqrt(1.0 - d * d);
        float r = atan(d, z) / PI;
        float phi = atan(xy.y, xy.x);

        uv.x = r * cos(phi) + 0.5;
        uv.y = r * sin(phi) + 0.5;
    }
    else
    {
        uv = fragTexCoord.xy;
    }

    gl_FragColor = texture2D(texture0, uv);
}#version 120

// Input vertex attributes (from vertex shader)
varying vec3 fragPosition;
varying vec2 fragTexCoord;
varying vec4 fragColor;
varying vec3 fragNormal;

// Input uniform values
uniform sampler2D texture0;
uniform vec4 colDiffuse;

// NOTE: Add here your custom variables

#define     MAX_LIGHTS              4
#define     LIGHT_DIRECTIONAL       0
#define     LIGHT_POINT             1

struct MaterialProperty {
    vec3 color;
    int useSampler;
    sampler2D sampler;
};

struct Light {
    int enabled;
    int type;
    vec3 position;
    vec3 target;
    vec4 color;
};

// Input lighting values
uniform Light lights[MAX_LIGHTS];
uniform vec4 ambient;
uniform vec3 viewPos;
uniform float fogDensity;

void main()
{
    // Texel color fetching from texture sampler
    vec4 texelColor = texture2D(texture0, fragTexCoord);
    vec3 lightDot = vec3(0.0);
    vec3 normal = normalize(fragNormal);
    vec3 viewD = normalize(viewPos - fragPosition);
    vec3 specular = vec3(0.0);

    // NOTE: Implement here your fragment shader code

    for (int i = 0; i < MAX_LIGHTS; i++)
    {
        if (lights[i].enabled == 1)
        {
            vec3 light = vec3(0.0);

            if (lights[i].type == LIGHT_DIRECTIONAL) light = -normalize(lights[i].target - lights[i].position);
            if (lights[i].type == LIGHT_POINT) light = normalize(lights[i].position - fragPosition);

            float NdotL = max(dot(normal, light), 0.0);
            lightDot += lights[i].color.rgb*NdotL;

            float specCo = 0.0;
            if (NdotL > 0.0) specCo = pow(max(0.0, dot(viewD, reflect(-(light), normal))), 16.0); // Shine: 16.0
            specular += specCo;
        }
    }

    vec4 finalColor = (texelColor*((colDiffuse + vec4(specular,1))*vec4(lightDot, 1.0)));
    finalColor += texelColor*(ambient/10.0);

    // Gamma correction
    finalColor = pow(finalColor, vec4(1.0/2.2));

    // Fog calculation
    float dist = length(viewPos - fragPosition);

    // these could be parameters...
    const vec4 fogColor = vec4(0.5, 0.5, 0.5, 1.0);
    //const float fogDensity = 0.16;

    // Exponential fog
    float fogFactor = 1.0/exp((dist*fogDensity)*(dist*fogDensity));

    // Linear fog (less nice)
    //const float fogStart = 2.0;
    //const float fogEnd = 10.0;
    //float fogFactor = (fogEnd - dist)/(fogEnd - fogStart);

    fogFactor = clamp(fogFactor, 0.0, 1.0);

    gl_FragColor = mix(fogColor, finalColor, fogFactor);
}
#version 120

// Input vertex attributes (from vertex shader)
varying vec2 fragTexCoord;
varying vec4 fragColor;

// Input uniform values
uniform sampler2D texture0;
uniform vec4 colDiffuse;

// NOTE: Add here your custom variables

void main()
{
    // Texel color fetching from texture sampler
    vec4 texelColor = texture2D(texture0, fragTexCoord)*colDiffuse*fragColor;

    // Convert texel color to grayscale using NTSC conversion weights
    float gray = dot(texelColor.rgb, vec3(0.299, 0.587, 0.114));

    // Calculate final fragment color
    gl_FragColor = vec4(gray, gray, gray, texelColor.a);
}#version 120

// Input vertex attributes (from vertex shader)
varying vec3 fragPosition;
varying vec2 fragTexCoord;
varying vec4 fragColor;
varying vec3 fragNormal;

// Input uniform values
uniform sampler2D texture0;
uniform vec4 colDiffuse;

// NOTE: Add here your custom variables

#define     MAX_LIGHTS              4
#define     LIGHT_DIRECTIONAL       0
#define     LIGHT_POINT             1

struct Light {
    int enabled;
    int type;
    vec3 position;
    vec3 target;
    vec4 color;
};

// Input lighting values
uniform Light lights[MAX_LIGHTS];
uniform vec4 ambient;
uniform vec3 viewPos;

void main()
{
    // Texel color fetching from texture sampler
    vec4 texelColor = texture2D(texture0, fragTexCoord);
    vec3 lightDot = vec3(0.0);
    vec3 normal = normalize(fragNormal);
    vec3 viewD = normalize(viewPos - fragPosition);
    vec3 specular = vec3(0.0);

    vec4 tint = colDiffuse * fragColor;

    // NOTE: Implement here your fragment shader code

    for (int i = 0; i < MAX_LIGHTS; i++)
    {
        if (lights[i].enabled == 1)
        {
            vec3 light = vec3(0.0);

            if (lights[i].type == LIGHT_DIRECTIONAL)
            {
                light = -normalize(lights[i].target - lights[i].position);
            }

            if (lights[i].type == LIGHT_POINT)
            {
                light = normalize(lights[i].position - fragPosition);
            }

            float NdotL = max(dot(normal, light), 0.0);
            lightDot += lights[i].color.rgb*NdotL;

            float specCo = 0.0;
            if (NdotL > 0.0) specCo = pow(max(0.0, dot(viewD, reflect(-(light), normal))), 16.0); // 16 refers to shine
            specular += specCo;
        }
    }

    vec4 finalColor = (texelColor*((tint + vec4(specular, 1.0))*vec4(lightDot, 1.0)));
    finalColor += texelColor*(ambient/10.0);

    // Gamma correction
    gl_FragColor = pow(finalColor, vec4(1.0/2.2));
}#version 120

// Input vertex attributes
attribute vec3 vertexPosition;
attribute vec2 vertexTexCoord;
attribute vec3 vertexNormal;
attribute vec4 vertexColor;

// Input uniform values
uniform mat4 mvp;
uniform mat4 matModel;

// Output vertex attributes (to fragment shader)
varying vec3 fragPosition;
varying vec2 fragTexCoord;
varying vec4 fragColor;
varying vec3 fragNormal;

// NOTE: Add here your custom variables

// https://github.com/glslify/glsl-inverse
mat3 inverse(mat3 m)
{
  float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2];
  float a10 = m[1][0], a11 = m[1][1], a12 = m[1][2];
  float a20 = m[2][0], a21 = m[2][1], a22 = m[2][2];

  float b01 = a22*a11 - a12*a21;
  float b11 = -a22*a10 + a12*a20;
  float b21 = a21*a10 - a11*a20;

  float det = a00*b01 + a01*b11 + a02*b21;

  return mat3(b01, (-a22*a01 + a02*a21), (a12*a01 - a02*a11),
              b11, (a22*a00 - a02*a20), (-a12*a00 + a02*a10),
              b21, (-a21*a00 + a01*a20), (a11*a00 - a01*a10))/det;
}

// https://github.com/glslify/glsl-transpose
mat3 transpose(mat3 m)
{
  return mat3(m[0][0], m[1][0], m[2][0],
              m[0][1], m[1][1], m[2][1],
              m[0][2], m[1][2], m[2][2]);
}

void main()
{
    // Send vertex attributes to fragment shader
    fragPosition = vec3(matModel*vec4(vertexPosition, 1.0));
    fragTexCoord = vertexTexCoord;
    fragColor = vertexColor;

    mat3 normalMatrix = transpose(inverse(mat3(matModel)));
    fragNormal = normalize(normalMatrix*vertexNormal);

    // Calculate final vertex position
    gl_Position = mvp*vec4(vertexPosition, 1.0);
}
#version 120

// Input vertex attributes (from vertex shader)
varying vec2 fragTexCoord;
varying vec2 fragTexCoord2;
varying vec3 fragPosition;
varying vec4 fragColor;

// Input uniform values
uniform sampler2D texture0;
uniform sampler2D texture1;

void main()
{
    // Texel color fetching from texture sampler
    vec4 texelColor = texture2D(texture0, fragTexCoord);
    vec4 texelColor2 = texture2D(texture1, fragTexCoord2);

    gl_FragColor = texelColor * texelColor2;
}
#version 120

// Input vertex attributes
attribute vec3 vertexPosition;
attribute vec2 vertexTexCoord;
attribute vec2 vertexTexCoord2;
attribute vec4 vertexColor;

// Input uniform values
uniform mat4 mvp;
uniform mat4 matModel;

// Output vertex attributes (to fragment shader)
varying vec3 fragPosition;
varying vec2 fragTexCoord;
varying vec2 fragTexCoord2;
varying vec4 fragColor;

// NOTE: Add here your custom variables

void main()
{
    // Send vertex attributes to fragment shader
    fragPosition = vec3(matModel*vec4(vertexPosition, 1.0));
    fragTexCoord = vertexTexCoord;
    fragTexCoord2 = vertexTexCoord2;
    fragColor = vertexColor;

    // Calculate final vertex position
    gl_Position = mvp*vec4(vertexPosition, 1.0);
}
#version 120

const int colors = 8;

// Input fragment attributes (from fragment shader)
varying vec2 fragTexCoord;
varying vec4 fragColor;

// Input uniform values
uniform sampler2D texture0;
uniform ivec3 palette[colors];

void main()
{
    // Texel color fetching from texture sampler
    vec4 texelColor = texture(texture0, fragTexCoord) * fragColor;

    // Convert the (normalized) texel color RED component (GB would work, too)
    // to the palette index by scaling up from [0, 1] to [0, 255].
    int index = int(texelColor.r * 255.0);
    ivec3 color = palette[index];

    // Calculate final fragment color. Note that the palette color components
    // are defined in the range [0, 255] and need to be normalized to [0, 1]
    // for OpenGL to work.
    gl_FragColor = vec4(color / 255.0, texelColor.a);
}
#version 120

#define MAX_LIGHTS              4
#define LIGHT_DIRECTIONAL       0
#define LIGHT_POINT             1
#define PI 3.14159265358979323846

struct Light {
    int enabled;
    int type;
    vec3 position;
    vec3 target;
    vec4 color;
    float intensity;
};

// Input vertex attributes (from vertex shader)
varying vec3 fragPosition;
varying vec2 fragTexCoord;
varying vec4 fragColor;
varying vec3 fragNormal;
varying vec4 shadowPos;
varying mat3 TBN;


// Input uniform values
uniform int numOfLights;
uniform sampler2D albedoMap;
uniform sampler2D mraMap;
uniform sampler2D normalMap;
uniform sampler2D emissiveMap; // r: Hight g:emissive

uniform vec2 tiling;
uniform vec2 offset;

uniform int useTexAlbedo;
uniform int useTexNormal;
uniform int useTexMRA;
uniform int useTexEmissive;

uniform vec4  albedoColor;
uniform vec4  emissiveColor;
uniform float normalValue;
uniform float metallicValue;
uniform float roughnessValue;
uniform float aoValue;
uniform float emissivePower;

// Input lighting values
uniform Light lights[MAX_LIGHTS];
uniform vec3 viewPos;

uniform vec3 ambientColor;
uniform float ambient;

// refl in range  0 to 1
// returns base reflectivity to 1
// incrase reflectivity when surface view at larger angle
vec3 schlickFresnel(float hDotV,vec3 refl)
{
        return refl + (1.0 - refl) * pow(1.0 - hDotV,5.0);
}

float ggxDistribution(float nDotH,float roughness)
{
        float a = roughness * roughness * roughness * roughness;
        float d = nDotH * nDotH * (a - 1.0) + 1.0;
        d = PI * d * d;
        return a / max(d,0.0000001);
}

float geomSmith(float nDotV,float nDotL,float roughness)
{
        float r = roughness + 1.0;
        float k = r * r / 8.0;
        float ik = 1.0 - k;
        float ggx1 = nDotV / (nDotV * ik + k);
        float ggx2 = nDotL / (nDotL * ik + k);
        return ggx1 * ggx2;
}

vec3 pbr(){
        vec3 albedo = texture2D(albedoMap,vec2(fragTexCoord.x*tiling.x+offset.x,fragTexCoord.y*tiling.y+offset.y)).rgb;
        albedo = vec3(albedoColor.x*albedo.x,albedoColor.y*albedo.y,albedoColor.z*albedo.z);
        float metallic = clamp(metallicValue,0.0,1.0);
        float roughness = clamp(roughnessValue,0.0,1.0);
        float ao = clamp(aoValue,0.0,1.0);
        if(useTexMRA == 1) {
            vec4 mra = texture2D(mraMap, vec2(fragTexCoord.x * tiling.x + offset.x, fragTexCoord.y * tiling.y + offset.y));
            metallic = clamp(mra.r+metallicValue,0.04,1.0);
            roughness = clamp(mra.g+roughnessValue,0.04,1.0);
            ao = (mra.b+aoValue)*0.5;
        }



        vec3 N = normalize(fragNormal);
        if(useTexNormal == 1) {
            N = texture2D(normalMap, vec2(fragTexCoord.x * tiling.x + offset.y, fragTexCoord.y * tiling.y + offset.y)).rgb;
            N = normalize(N * 2.0 - 1.0);
            N = normalize(N * TBN);
        }
        
        vec3 V = normalize(viewPos - fragPosition);
        
        vec3 e = vec3(0);
        e = (texture2D(emissiveMap, vec2(fragTexCoord.x*tiling.x+offset.x, fragTexCoord.y*tiling.y+offset.y)).rgb).g * emissiveColor.rgb*emissivePower * float(useTexEmissive);
        
        //return N;//vec3(metallic,metallic,metallic);
        //if  dia-electric use base reflectivity of 0.04 otherwise ut is a metal use albedo as base reflectivity
        vec3 baseRefl = mix(vec3(0.04),albedo.rgb,metallic);
        vec3 Lo = vec3(0.0);  // acumulate lighting lum

        for(int i=0;i<numOfLights;++i){

            vec3 L = normalize(lights[i].position - fragPosition);  // calc light vector
            vec3 H = normalize(V + L);                              // calc halfway bisecting vector
            float dist = length(lights[i].position - fragPosition); // calc distance to light
            float attenuation = 1.0 / (dist * dist * 0.23);                // calc attenuation
            vec3 radiance = lights[i].color.rgb * lights[i].intensity * attenuation;         // calc input radiance,light energy comming in

            //Cook-Torrance BRDF distribution function
            float nDotV = max(dot(N,V),0.0000001);
            float nDotL = max(dot(N,L),0.0000001);
            float hDotV = max(dot(H,V),0.0);
            float nDotH = max(dot(N,H),0.0);
            float D = ggxDistribution(nDotH,roughness); // larger the more micro-facets aligned to H
            float G = geomSmith(nDotV,nDotL,roughness); // smaller the more micro-facets shadow
            vec3 F = schlickFresnel(hDotV, baseRefl);  // fresnel proportion of specular reflectance

            vec3 spec = (D * G * F) / (4.0 * nDotV * nDotL);
            // difuse and spec light can't be above 1.0
            // kD = 1.0 - kS  diffuse component is equal 1.0 - spec comonent
            vec3 kD = vec3(1.0) - F;
            //mult kD by the inverse of metallnes , only non-metals should have diffuse light
            kD *= 1.0 - metallic;
            Lo += ((kD * albedo.rgb / PI + spec) * radiance * nDotL)*float(lights[i].enabled); // angle of light has impact on result
        }
        vec3 ambient_final = (ambientColor + albedo)* ambient * 0.5;
        return ambient_final+Lo*ao+e;
}

void main()
{
       vec3 color = pbr();
        
        //HDR tonemapping
        color = pow(color,color + vec3(1.0));
        //gamma correction
        color = pow(color,vec3(1.0/2.2));

        gl_FragColor = vec4(color,1.0);
        
}
#version 120

// Input vertex attributes
attribute  vec3 vertexPosition;
attribute  vec2 vertexTexCoord;
attribute  vec3 vertexNormal;
attribute  vec3 vertexTangent;
attribute  vec4 vertexColor;

// Input uniform values
uniform mat4 mvp;
uniform mat4 matModel;
uniform mat4 matNormal;
uniform vec3 lightPos;
uniform vec4 difColor;

// Output vertex attributes (to fragment shader)
varying vec3 fragPosition;
varying vec2 fragTexCoord;
varying vec4 fragColor;
varying vec3 fragNormal;
varying mat3 TBN;

const float normalOffset = 0.1;

// https://github.com/glslify/glsl-inverse
mat3 inverse(mat3 m)
{
  float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2];
  float a10 = m[1][0], a11 = m[1][1], a12 = m[1][2];
  float a20 = m[2][0], a21 = m[2][1], a22 = m[2][2];

  float b01 = a22*a11 - a12*a21;
  float b11 = -a22*a10 + a12*a20;
  float b21 = a21*a10 - a11*a20;

  float det = a00*b01 + a01*b11 + a02*b21;

  return mat3(b01, (-a22*a01 + a02*a21), (a12*a01 - a02*a11),
              b11, (a22*a00 - a02*a20), (-a12*a00 + a02*a10),
              b21, (-a21*a00 + a01*a20), (a11*a00 - a01*a10))/det;
}

// https://github.com/glslify/glsl-transpose
mat3 transpose(mat3 m)
{
  return mat3(m[0][0], m[1][0], m[2][0],
              m[0][1], m[1][1], m[2][1],
              m[0][2], m[1][2], m[2][2]);
}

void main()
{

    // calc binormal from vertex normal and tangent
    vec3 vertexBinormal = cross(vertexNormal, vertexTangent);
    // calc fragment normal based on normal transformations
    mat3 normalMatrix = transpose(inverse(mat3(matModel)));
    // calc fragment position based on model transformations

    fragPosition = vec3(matModel*vec4(vertexPosition, 1.0));

    fragTexCoord = vertexTexCoord*2.0;

    fragNormal = normalize(normalMatrix*vertexNormal);
    vec3 fragTangent = normalize(normalMatrix*vertexTangent);
    fragTangent = normalize(fragTangent - dot(fragTangent, fragNormal)*fragNormal);
    vec3 fragBinormal = normalize(normalMatrix*vertexBinormal);
    fragBinormal = cross(fragNormal, fragTangent);

    TBN = transpose(mat3(fragTangent, fragBinormal, fragNormal));

    // Calculate final vertex position
    gl_Position = mvp * vec4(vertexPosition, 1.0);
}#version 120

// Input vertex attributes (from vertex shader)
varying vec2 fragTexCoord;
varying vec4 fragColor;

// Input uniform values
uniform sampler2D texture0;
uniform vec4 colDiffuse;

// NOTE: Add here your custom variables

// NOTE: Render size values must be passed from code
const float renderWidth = 800.0;
const float renderHeight = 450.0;

float pixelWidth = 5.0;
float pixelHeight = 5.0;

void main()
{
    float dx = pixelWidth*(1.0/renderWidth);
    float dy = pixelHeight*(1.0/renderHeight);

    vec2 coord = vec2(dx*floor(fragTexCoord.x/dx), dy*floor(fragTexCoord.y/dy));

    vec3 tc = texture2D(texture0, coord).rgb;

    gl_FragColor = vec4(tc, 1.0);
}#version 120

// Input vertex attributes (from vertex shader)
varying vec2 fragTexCoord;
varying vec4 fragColor;

// Input uniform values
uniform sampler2D texture0;
uniform vec4 colDiffuse;

// NOTE: Add here your custom variables

float gamma = 0.6;
float numColors = 8.0;

void main()
{
    vec3 color = texture2D(texture0, fragTexCoord.xy).rgb;

    color = pow(color, vec3(gamma, gamma, gamma));
    color = color*numColors;
    color = floor(color);
    color = color/numColors;
    color = pow(color, vec3(1.0/gamma));

    gl_FragColor = vec4(color, 1.0);
}#version 120

// Input vertex attributes (from vertex shader)
varying vec2 fragTexCoord;
varying vec4 fragColor;

// Input uniform values
uniform sampler2D texture0;
uniform vec4 colDiffuse;

// NOTE: Add here your custom variables

void main()
{
    vec3 color = texture2D(texture0, fragTexCoord).rgb;
    vec3 colors[3];
    colors[0] = vec3(0.0, 0.0, 1.0);
    colors[1] = vec3(1.0, 1.0, 0.0);
    colors[2] = vec3(1.0, 0.0, 0.0);

    float lum = (color.r + color.g + color.b)/3.0;

    vec3 tc = vec3(0.0, 0.0, 0.0);

    if (lum < 0.5) tc = mix(colors[0], colors[1], lum/0.5);
    else tc = mix(colors[1], colors[2], (lum - 0.5)/0.5);

    gl_FragColor = vec4(tc, 1.0);
}#version 120

// Input vertex attributes (from vertex shader)
varying vec2 fragTexCoord;
varying vec4 fragColor;

uniform vec3 viewEye;
uniform vec3 viewCenter;
uniform float runTime;
uniform vec2 resolution;

// The MIT License
// Copyright  2013 Inigo Quilez
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

// A list of useful distance function to simple primitives, and an example on how to
// do some interesting boolean operations, repetition and displacement.
//
// More info here: http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm

#define AA 1   // make this 1 if your machine is too slow

//------------------------------------------------------------------

float sdPlane( vec3 p )
{
    return p.y;
}

float sdSphere( vec3 p, float s )
{
    return length(p)-s;
}

float sdBox( vec3 p, vec3 b )
{
    vec3 d = abs(p) - b;
    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));
}

float sdEllipsoid( in vec3 p, in vec3 r )
{
    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);
}

float udRoundBox( vec3 p, vec3 b, float r )
{
    return length(max(abs(p)-b,0.0))-r;
}

float sdTorus( vec3 p, vec2 t )
{
    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;
}

float sdHexPrism( vec3 p, vec2 h )
{
    vec3 q = abs(p);
#if 0
    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);
#else
    float d1 = q.z-h.y;
    float d2 = max((q.x*0.866025+q.y*0.5),q.y)-h.x;
    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);
#endif
}

float sdCapsule( vec3 p, vec3 a, vec3 b, float r )
{
    vec3 pa = p-a, ba = b-a;
    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );
    return length( pa - ba*h ) - r;
}

float sdEquilateralTriangle(  in vec2 p )
{
    const float k = sqrt(3.0);
    p.x = abs(p.x) - 1.0;
    p.y = p.y + 1.0/k;
    if( p.x + k*p.y > 0.0 ) p = vec2( p.x - k*p.y, -k*p.x - p.y )/2.0;
    p.x += 2.0 - 2.0*clamp( (p.x+2.0)/2.0, 0.0, 1.0 );
    return -length(p)*sign(p.y);
}

float sdTriPrism( vec3 p, vec2 h )
{
    vec3 q = abs(p);
    float d1 = q.z-h.y;
#if 1
    // distance bound
    float d2 = max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5;
#else
    // correct distance
    h.x *= 0.866025;
    float d2 = sdEquilateralTriangle(p.xy/h.x)*h.x;
#endif
    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);
}

float sdCylinder( vec3 p, vec2 h )
{
  vec2 d = abs(vec2(length(p.xz),p.y)) - h;
  return min(max(d.x,d.y),0.0) + length(max(d,0.0));
}

float sdCone( in vec3 p, in vec3 c )
{
    vec2 q = vec2( length(p.xz), p.y );
    float d1 = -q.y-c.z;
    float d2 = max( dot(q,c.xy), q.y);
    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);
}

float sdConeSection( in vec3 p, in float h, in float r1, in float r2 )
{
    float d1 = -p.y - h;
    float q = p.y - h;
    float si = 0.5*(r1-r2)/h;
    float d2 = max( sqrt( dot(p.xz,p.xz)*(1.0-si*si)) + q*si - r2, q );
    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);
}

float sdPryamid4(vec3 p, vec3 h ) // h = { cos a, sin a, height }
{
    // Tetrahedron = Octahedron - Cube
    float box = sdBox( p - vec3(0,-2.0*h.z,0), vec3(2.0*h.z) );

    float d = 0.0;
    d = max( d, abs( dot(p, vec3( -h.x, h.y, 0 )) ));
    d = max( d, abs( dot(p, vec3(  h.x, h.y, 0 )) ));
    d = max( d, abs( dot(p, vec3(  0, h.y, h.x )) ));
    d = max( d, abs( dot(p, vec3(  0, h.y,-h.x )) ));
    float octa = d - h.z;
    return max(-box,octa); // Subtraction
 }

float length2( vec2 p )
{
    return sqrt( p.x*p.x + p.y*p.y );
}

float length6( vec2 p )
{
    p = p*p*p; p = p*p;
    return pow( p.x + p.y, 1.0/6.0 );
}

float length8( vec2 p )
{
    p = p*p; p = p*p; p = p*p;
    return pow( p.x + p.y, 1.0/8.0 );
}

float sdTorus82( vec3 p, vec2 t )
{
    vec2 q = vec2(length2(p.xz)-t.x,p.y);
    return length8(q)-t.y;
}

float sdTorus88( vec3 p, vec2 t )
{
    vec2 q = vec2(length8(p.xz)-t.x,p.y);
    return length8(q)-t.y;
}

float sdCylinder6( vec3 p, vec2 h )
{
    return max( length6(p.xz)-h.x, abs(p.y)-h.y );
}

//------------------------------------------------------------------

float opS( float d1, float d2 )
{
    return max(-d2,d1);
}

vec2 opU( vec2 d1, vec2 d2 )
{
    return (d1.x<d2.x) ? d1 : d2;
}

vec3 opRep( vec3 p, vec3 c )
{
    return mod(p,c)-0.5*c;
}

vec3 opTwist( vec3 p )
{
    float  c = cos(10.0*p.y+10.0);
    float  s = sin(10.0*p.y+10.0);
    mat2   m = mat2(c,-s,s,c);
    return vec3(m*p.xz,p.y);
}

//------------------------------------------------------------------

vec2 map( in vec3 pos )
{
    vec2 res = opU( vec2( sdPlane(     pos), 1.0 ),
                    vec2( sdSphere(    pos-vec3( 0.0,0.25, 0.0), 0.25 ), 46.9 ) );
    res = opU( res, vec2( sdBox(       pos-vec3( 1.0,0.25, 0.0), vec3(0.25) ), 3.0 ) );
    res = opU( res, vec2( udRoundBox(  pos-vec3( 1.0,0.25, 1.0), vec3(0.15), 0.1 ), 41.0 ) );
    res = opU( res, vec2( sdTorus(     pos-vec3( 0.0,0.25, 1.0), vec2(0.20,0.05) ), 25.0 ) );
    res = opU( res, vec2( sdCapsule(   pos,vec3(-1.3,0.10,-0.1), vec3(-0.8,0.50,0.2), 0.1  ), 31.9 ) );
    res = opU( res, vec2( sdTriPrism(  pos-vec3(-1.0,0.25,-1.0), vec2(0.25,0.05) ),43.5 ) );
    res = opU( res, vec2( sdCylinder(  pos-vec3( 1.0,0.30,-1.0), vec2(0.1,0.2) ), 8.0 ) );
    res = opU( res, vec2( sdCone(      pos-vec3( 0.0,0.50,-1.0), vec3(0.8,0.6,0.3) ), 55.0 ) );
    res = opU( res, vec2( sdTorus82(   pos-vec3( 0.0,0.25, 2.0), vec2(0.20,0.05) ),50.0 ) );
    res = opU( res, vec2( sdTorus88(   pos-vec3(-1.0,0.25, 2.0), vec2(0.20,0.05) ),43.0 ) );
    res = opU( res, vec2( sdCylinder6( pos-vec3( 1.0,0.30, 2.0), vec2(0.1,0.2) ), 12.0 ) );
    res = opU( res, vec2( sdHexPrism(  pos-vec3(-1.0,0.20, 1.0), vec2(0.25,0.05) ),17.0 ) );
    res = opU( res, vec2( sdPryamid4(  pos-vec3(-1.0,0.15,-2.0), vec3(0.8,0.6,0.25) ),37.0 ) );
    res = opU( res, vec2( opS( udRoundBox(  pos-vec3(-2.0,0.2, 1.0), vec3(0.15),0.05),
                               sdSphere(    pos-vec3(-2.0,0.2, 1.0), 0.25)), 13.0 ) );
    res = opU( res, vec2( opS( sdTorus82(  pos-vec3(-2.0,0.2, 0.0), vec2(0.20,0.1)),
                               sdCylinder(  opRep( vec3(atan(pos.x+2.0,pos.z)/6.2831, pos.y, 0.02+0.5*length(pos-vec3(-2.0,0.2, 0.0))), vec3(0.05,1.0,0.05)), vec2(0.02,0.6))), 51.0 ) );
    res = opU( res, vec2( 0.5*sdSphere(    pos-vec3(-2.0,0.25,-1.0), 0.2 ) + 0.03*sin(50.0*pos.x)*sin(50.0*pos.y)*sin(50.0*pos.z), 65.0 ) );
    res = opU( res, vec2( 0.5*sdTorus( opTwist(pos-vec3(-2.0,0.25, 2.0)),vec2(0.20,0.05)), 46.7 ) );
    res = opU( res, vec2( sdConeSection( pos-vec3( 0.0,0.35,-2.0), 0.15, 0.2, 0.1 ), 13.67 ) );
    res = opU( res, vec2( sdEllipsoid( pos-vec3( 1.0,0.35,-2.0), vec3(0.15, 0.2, 0.05) ), 43.17 ) );

    return res;
}

vec2 castRay( in vec3 ro, in vec3 rd )
{
    float tmin = 0.2;
    float tmax = 30.0;

#if 1
    // bounding volume
    float tp1 = (0.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );
    float tp2 = (1.6-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>1.6 ) tmin = max( tmin, tp2 );
                                                 else           tmax = min( tmax, tp2 ); }
#endif

    float t = tmin;
    float m = -1.0;
    for( int i=0; i<64; i++ )
    {
        float precis = 0.0005*t;
        vec2 res = map( ro+rd*t );
        if( res.x<precis || t>tmax ) break;
        t += res.x;
        m = res.y;
    }

    if( t>tmax ) m=-1.0;
    return vec2( t, m );
}


float calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )
{
    float res = 1.0;
    float t = mint;
    for( int i=0; i<16; i++ )
    {
        float h = map( ro + rd*t ).x;
        res = min( res, 8.0*h/t );
        t += clamp( h, 0.02, 0.10 );
        if( h<0.001 || t>tmax ) break;
    }
    return clamp( res, 0.0, 1.0 );
}

vec3 calcNormal( in vec3 pos )
{
    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;
    return normalize( e.xyy*map( pos + e.xyy ).x +
                      e.yyx*map( pos + e.yyx ).x +
                      e.yxy*map( pos + e.yxy ).x +
                      e.xxx*map( pos + e.xxx ).x );
    /*
    vec3 eps = vec3( 0.0005, 0.0, 0.0 );
    vec3 nor = vec3(
        map(pos+eps.xyy).x - map(pos-eps.xyy).x,
        map(pos+eps.yxy).x - map(pos-eps.yxy).x,
        map(pos+eps.yyx).x - map(pos-eps.yyx).x );
    return normalize(nor);
    */
}

float calcAO( in vec3 pos, in vec3 nor )
{
    float occ = 0.0;
    float sca = 1.0;
    for( int i=0; i<5; i++ )
    {
        float hr = 0.01 + 0.12*float(i)/4.0;
        vec3 aopos =  nor * hr + pos;
        float dd = map( aopos ).x;
        occ += -(dd-hr)*sca;
        sca *= 0.95;
    }
    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );
}

// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm
float checkersGradBox( in vec2 p )
{
    // filter kernel
    vec2 w = fwidth(p) + 0.001;
    // analytical integral (box filter)
    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;
    // xor pattern
    return 0.5 - 0.5*i.x*i.y;
}

vec3 render( in vec3 ro, in vec3 rd )
{
    vec3 col = vec3(0.7, 0.9, 1.0) +rd.y*0.8;
    vec2 res = castRay(ro,rd);
    float t = res.x;
    float m = res.y;
    if( m>-0.5 )
    {
        vec3 pos = ro + t*rd;
        vec3 nor = calcNormal( pos );
        vec3 ref = reflect( rd, nor );

        // material
        col = 0.45 + 0.35*sin( vec3(0.05,0.08,0.10)*(m-1.0) );
        if( m<1.5 )
        {

            float f = checkersGradBox( 5.0*pos.xz );
            col = 0.3 + f*vec3(0.1);
        }

        // lighting
        float occ = calcAO( pos, nor );
        vec3  lig = normalize( vec3(cos(-0.4 * runTime), sin(0.7 * runTime), -0.6) );
        vec3  hal = normalize( lig-rd );
        float amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );
        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );
        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);
        float dom = smoothstep( -0.1, 0.1, ref.y );
        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );

        dif *= calcSoftshadow( pos, lig, 0.02, 2.5 );
        dom *= calcSoftshadow( pos, ref, 0.02, 2.5 );

        float spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0)*
                    dif *
                    (0.04 + 0.96*pow( clamp(1.0+dot(hal,rd),0.0,1.0), 5.0 ));

        vec3 lin = vec3(0.0);
        lin += 1.30*dif*vec3(1.00,0.80,0.55);
        lin += 0.40*amb*vec3(0.40,0.60,1.00)*occ;
        lin += 0.50*dom*vec3(0.40,0.60,1.00)*occ;
        lin += 0.50*bac*vec3(0.25,0.25,0.25)*occ;
        lin += 0.25*fre*vec3(1.00,1.00,1.00)*occ;
        col = col*lin;
        col += 10.00*spe*vec3(1.00,0.90,0.70);

        col = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.0002*t*t*t ) );
    }

    return vec3( clamp(col,0.0,1.0) );
}

mat3 setCamera( in vec3 ro, in vec3 ta, float cr )
{
    vec3 cw = normalize(ta-ro);
    vec3 cp = vec3(sin(cr), cos(cr),0.0);
    vec3 cu = normalize( cross(cw,cp) );
    vec3 cv = normalize( cross(cu,cw) );
    return mat3( cu, cv, cw );
}

void main()
{
    vec3 tot = vec3(0.0);
#if AA>1
    for( int m=0; m<AA; m++ )
    for( int n=0; n<AA; n++ )
    {
        // pixel coordinates
        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;
        vec2 p = (-resolution.xy + 2.0*(gl_FragCoord.xy+o))/resolution.y;
#else
        vec2 p = (-resolution.xy + 2.0*gl_FragCoord.xy)/resolution.y;
#endif

        // RAY: Camera is provided from raylib
        //vec3 ro = vec3( -0.5+3.5*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, 0.5 + 4.0*sin(0.1*time + 6.0*mo.x) );

        vec3 ro = viewEye;
        vec3 ta = viewCenter;

        // camera-to-world transformation
        mat3 ca = setCamera( ro, ta, 0.0 );
        // ray direction
        vec3 rd = ca * normalize( vec3(p.xy,2.0) );

        // render
        vec3 col = render( ro, rd );

        // gamma
        col = pow( col, vec3(0.4545) );

        tot += col;
#if AA>1
    }
    tot /= float(AA*AA);
#endif

    gl_FragColor = vec4( tot, 1.0 );
}
#version 120

// Input vertex attributes (from vertex shader)
varying vec2 fragTexCoord;
varying vec4 fragColor;

// Input uniform values
uniform sampler2D texture0;
uniform vec4 colDiffuse;

// NOTE: Add here your custom variables

float offset = 0.0;
float frequency = 450.0/3.0;

uniform float time;

void main()
{
/*
    // Scanlines method 1
    float tval = 0; //time
    vec2 uv = 0.5 + (fragTexCoord - 0.5)*(0.9 + 0.01*sin(0.5*tval));

    vec4 color = texture2D(texture0, fragTexCoord);

    color = clamp(color*0.5 + 0.5*color*color*1.2, 0.0, 1.0);
    color *= 0.5 + 0.5*16.0*uv.x*uv.y*(1.0 - uv.x)*(1.0 - uv.y);
    color *= vec4(0.8, 1.0, 0.7, 1);
    color *= 0.9 + 0.1*sin(10.0*tval + uv.y*1000.0);
    color *= 0.97 + 0.03*sin(110.0*tval);

    fragColor = color;
*/
    // Scanlines method 2
    float globalPos = (fragTexCoord.y + offset) * frequency;
    float wavePos = cos((fract(globalPos) - 0.5)*3.14);

    vec4 color = texture2D(texture0, fragTexCoord);

    gl_FragColor = mix(vec4(0.0, 0.3, 0.0, 0.0), color, wavePos);
}#version 120

// This shader is based on the basic lighting shader
// This only supports one light, which is directional, and it (of course) supports shadows

// Input vertex attributes (from vertex shader)
varying vec3 fragPosition;
varying vec2 fragTexCoord;
//varying in vec4 fragColor;
varying vec3 fragNormal;

// Input uniform values
uniform sampler2D texture0;
uniform vec4 colDiffuse;

// Input lighting values
uniform vec3 lightDir;
uniform vec4 lightColor;
uniform vec4 ambient;
uniform vec3 viewPos;

// Input shadowmapping values
uniform mat4 lightVP; // Light source view-projection matrix
uniform sampler2D shadowMap;

uniform int shadowMapResolution;

void main()
{
    // Texel color fetching from texture sampler
    vec4 texelColor = texture2D(texture0, fragTexCoord);
    vec3 lightDot = vec3(0.0);
    vec3 normal = normalize(fragNormal);
    vec3 viewD = normalize(viewPos - fragPosition);
    vec3 specular = vec3(0.0);

    vec3 l = -lightDir;

    float NdotL = max(dot(normal, l), 0.0);
    lightDot += lightColor.rgb*NdotL;

    float specCo = 0.0;
    if (NdotL > 0.0) specCo = pow(max(0.0, dot(viewD, reflect(-(l), normal))), 16.0); // 16 refers to shine
    specular += specCo;

    vec4 finalColor = (texelColor*((colDiffuse + vec4(specular, 1.0))*vec4(lightDot, 1.0)));

    // Shadow calculations
    vec4 fragPosLightSpace = lightVP * vec4(fragPosition, 1);
    fragPosLightSpace.xyz /= fragPosLightSpace.w; // Perform the perspective division
    fragPosLightSpace.xyz = (fragPosLightSpace.xyz + 1.0f) / 2.0f; // Transform from [-1, 1] range to [0, 1] range
    vec2 sampleCoords = fragPosLightSpace.xy;
    float curDepth = fragPosLightSpace.z;
    // Slope-scale depth bias: depth biasing reduces "shadow acne" artifacts, where dark stripes appear all over the scene.
    // The solution is adding a small bias to the depth
    // In this case, the bias is proportional to the slope of the surface, relative to the light
    float bias = max(0.0008 * (1.0 - dot(normal, l)), 0.00008);
    int shadowCounter = 0;
    const int numSamples = 9;
    // PCF (percentage-closer filtering) algorithm:
    // Instead of testing if just one point is closer to the current point,
    // we test the surrounding points as well.
    // This blurs shadow edges, hiding aliasing artifacts.
    vec2 texelSize = vec2(1.0f / float(shadowMapResolution));
    for (int x = -1; x <= 1; x++)
    {
        for (int y = -1; y <= 1; y++)
        {
            float sampleDepth = texture2D(shadowMap, sampleCoords + texelSize * vec2(x, y)).r;
            if (curDepth - bias > sampleDepth)
            {
                shadowCounter++;
            }
        }
    }
    finalColor = mix(finalColor, vec4(0, 0, 0, 1), float(shadowCounter) / float(numSamples));

    // Add ambient lighting whether in shadow or not
    finalColor += texelColor*(ambient/10.0)*colDiffuse;

    // Gamma correction
    finalColor = pow(finalColor, vec4(1.0/2.2));
    gl_FragColor = finalColor;
}
#version 120

// Input vertex attributes
attribute vec3 vertexPosition;
attribute vec2 vertexTexCoord;
attribute vec3 vertexNormal;
attribute vec4 vertexColor;

// Input uniform values
uniform mat4 mvp;
uniform mat4 matModel;
uniform mat4 matNormal;

// Output vertex attributes (to fragment shader)
varying vec3 fragPosition;
varying vec2 fragTexCoord;
varying vec4 fragColor;
varying vec3 fragNormal;

// NOTE: Add here your custom variables

void main()
{
    // Send vertex attributes to fragment shader
    fragPosition = vec3(matModel*vec4(vertexPosition, 1.0));
    fragTexCoord = vertexTexCoord;
    fragColor = vertexColor;
    fragNormal = normalize(vec3(matNormal*vec4(vertexNormal, 1.0)));

    // Calculate final vertex position
    gl_Position = mvp*vec4(vertexPosition, 1.0);
}
#version 120

// Input vertex attributes (from vertex shader)
varying vec2 fragTexCoord;
varying vec4 fragColor;

// Input uniform values
uniform sampler2D texture0;
uniform vec4 colDiffuse;

// NOTE: Add here your custom variables
vec2 resolution = vec2(800.0, 450.0);

void main()
{
    float x = 1.0/resolution.x;
    float y = 1.0/resolution.y;

    vec4 horizEdge = vec4(0.0);
    horizEdge -= texture2D(texture0, vec2(fragTexCoord.x - x, fragTexCoord.y - y))*1.0;
    horizEdge -= texture2D(texture0, vec2(fragTexCoord.x - x, fragTexCoord.y    ))*2.0;
    horizEdge -= texture2D(texture0, vec2(fragTexCoord.x - x, fragTexCoord.y + y))*1.0;
    horizEdge += texture2D(texture0, vec2(fragTexCoord.x + x, fragTexCoord.y - y))*1.0;
    horizEdge += texture2D(texture0, vec2(fragTexCoord.x + x, fragTexCoord.y    ))*2.0;
    horizEdge += texture2D(texture0, vec2(fragTexCoord.x + x, fragTexCoord.y + y))*1.0;

    vec4 vertEdge = vec4(0.0);
    vertEdge -= texture2D(texture0, vec2(fragTexCoord.x - x, fragTexCoord.y - y))*1.0;
    vertEdge -= texture2D(texture0, vec2(fragTexCoord.x    , fragTexCoord.y - y))*2.0;
    vertEdge -= texture2D(texture0, vec2(fragTexCoord.x + x, fragTexCoord.y - y))*1.0;
    vertEdge += texture2D(texture0, vec2(fragTexCoord.x - x, fragTexCoord.y + y))*1.0;
    vertEdge += texture2D(texture0, vec2(fragTexCoord.x    , fragTexCoord.y + y))*2.0;
    vertEdge += texture2D(texture0, vec2(fragTexCoord.x + x, fragTexCoord.y + y))*1.0;

    vec3 edge = sqrt((horizEdge.rgb*horizEdge.rgb) + (vertEdge.rgb*vertEdge.rgb));

    gl_FragColor = vec4(edge, texture2D(texture0, fragTexCoord).a);
}#version 120

// Input vertex attributes (from vertex shader)
varying vec2 fragTexCoord;
varying vec4 fragColor;

// Input uniform values
uniform sampler2D texture0;
uniform vec4 colDiffuse;

// NOTE: Add here your custom variables

// NOTE: Render size values should be passed from code
const float renderWidth = 800;
const float renderHeight = 450;

float radius = 250.0;
float angle = 0.8;

uniform vec2 center;

void main()
{
    vec2 texSize = vec2(renderWidth, renderHeight);
    vec2 tc = fragTexCoord*texSize;
    tc -= center;

    float dist = length(tc);

    if (dist < radius)
    {
        float percent = (radius - dist)/radius;
        float theta = percent*percent*angle*8.0;
        float s = sin(theta);
        float c = cos(theta);

        tc = vec2(dot(tc, vec2(c, -s)), dot(tc, vec2(s, c)));
    }

    tc += center;
    vec4 color = texture2D(texture0, tc/texSize)*colDiffuse*fragColor;;

    gl_FragColor = vec4(color.rgb, 1.0);;
}#version 330

// Input vertex attributes (from vertex shader)
in vec2 fragTexCoord;
in vec4 fragColor;

// Input uniform values
uniform sampler2D texture0;
uniform vec4 colDiffuse;

// Output fragment color
out vec4 finalColor;

// NOTE: Add here your custom variables

void main()
{
    // Texel color fetching from texture sampler
    vec4 texelColor = texture(texture0, fragTexCoord);

    // NOTE: Implement here your fragment shader code

    // final color is the color from the texture 
    //    times the tint color (colDiffuse)
    //    times the fragment color (interpolated vertex color)
    finalColor = texelColor*colDiffuse*fragColor;
}

#version 330

// Input vertex attributes
in vec3 vertexPosition;
in vec2 vertexTexCoord;
in vec3 vertexNormal;
in vec4 vertexColor;

// Input uniform values
uniform mat4 mvp;

// Output vertex attributes (to fragment shader)
out vec2 fragTexCoord;
out vec4 fragColor;

// NOTE: Add here your custom variables

void main()
{
    // Send vertex attributes to fragment shader
    fragTexCoord = vertexTexCoord;
    fragColor = vertexColor;

    // Calculate final vertex position
    gl_Position = mvp*vec4(vertexPosition, 1.0);
}#version 330

// Input vertex attributes (from vertex shader)
in vec2 fragTexCoord;
in vec4 fragColor;

// Input uniform values
uniform sampler2D texture0;
uniform vec4 colDiffuse;

// Output fragment color
out vec4 finalColor;

// NOTE: Add here your custom variables

const vec2 size = vec2(800, 450);   // Framebuffer size
const float samples = 5.0;          // Pixels per axis; higher = bigger glow, worse performance
const float quality = 2.5;          // Defines size factor: Lower = smaller glow, better quality

void main()
{
    vec4 sum = vec4(0);
    vec2 sizeFactor = vec2(1)/size*quality;

    // Texel color fetching from texture sampler
    vec4 source = texture(texture0, fragTexCoord);

    const int range = 2;            // should be = (samples - 1)/2;

    for (int x = -range; x <= range; x++)
    {
        for (int y = -range; y <= range; y++)
        {
            sum += texture(texture0, fragTexCoord + vec2(x, y)*sizeFactor);
        }
    }

    // Calculate final fragment color
    finalColor = ((sum/(samples*samples)) + source)*colDiffuse;
}#version 330

// Input vertex attributes (from vertex shader)
in vec2 fragTexCoord;
in vec4 fragColor;

// Input uniform values
uniform sampler2D texture0;
uniform vec4 colDiffuse;

// Output fragment color
out vec4 finalColor;

// NOTE: Add here your custom variables

// NOTE: Render size values must be passed from code
const float renderWidth = 800;
const float renderHeight = 450;

float offset[3] = float[](0.0, 1.3846153846, 3.2307692308);
float weight[3] = float[](0.2270270270, 0.3162162162, 0.0702702703);

void main()
{
    // Texel color fetching from texture sampler
    vec3 texelColor = texture(texture0, fragTexCoord).rgb*weight[0];

    for (int i = 1; i < 3; i++)
    {
        texelColor += texture(texture0, fragTexCoord + vec2(offset[i])/renderWidth, 0.0).rgb*weight[i];
        texelColor += texture(texture0, fragTexCoord - vec2(offset[i])/renderWidth, 0.0).rgb*weight[i];
    }

    finalColor = vec4(texelColor, 1.0);
}#version 330

// Input vertex attributes (from vertex shader)
in vec3 vertexPos;
in vec2 fragTexCoord;
in vec4 fragColor;

// Input uniform values
uniform sampler2D texture0;
uniform sampler2D texture1;
uniform vec4 colDiffuse;

uniform float divider = 0.5;

out vec4 finalColor;

void main()
{
    // Texel color fetching from texture sampler
    vec4 texelColor0 = texture(texture0, fragTexCoord);
    vec4 texelColor1 = texture(texture1, fragTexCoord);

    float x = fract(fragTexCoord.s);
    float final = smoothstep(divider - 0.1, divider + 0.1, x);

    finalColor = mix(texelColor0, texelColor1, final);
}#version 330

// Input vertex attributes (from vertex shader)
in vec2 fragTexCoord;
in vec4 fragColor;

// Input uniform values
uniform sampler2D texture0;
uniform vec4 colDiffuse;

// Output fragment color
out vec4 finalColor;

// NOTE: Add here your custom variables

float hatchOffsetY = 5.0;
float lumThreshold01 = 0.9;
float lumThreshold02 = 0.7;
float lumThreshold03 = 0.5;
float lumThreshold04 = 0.3;

void main()
{
    vec3 tc = vec3(1.0, 1.0, 1.0);
    float lum = length(texture(texture0, fragTexCoord).rgb);

    if (lum < lumThreshold01)
    {
        if (mod(gl_FragCoord.x + gl_FragCoord.y, 10.0) == 0.0) tc = vec3(0.0, 0.0, 0.0);
    }

    if (lum < lumThreshold02)
    {
        if (mod(gl_FragCoord.x - gl_FragCoord.y, 10.0) == 0.0) tc = vec3(0.0, 0.0, 0.0);
    }

    if (lum < lumThreshold03)
    {
        if (mod(gl_FragCoord.x + gl_FragCoord.y - hatchOffsetY, 10.0) == 0.0) tc = vec3(0.0, 0.0, 0.0);
    }

    if (lum < lumThreshold04)
    {
        if (mod(gl_FragCoord.x - gl_FragCoord.y - hatchOffsetY, 10.0) == 0.0) tc = vec3(0.0, 0.0, 0.0);
    }

    finalColor = vec4(tc, 1.0);
}#version 330

// Input vertex attributes (from vertex shader)
in vec2 fragTexCoord;
in vec4 fragColor;

// Input uniform values
uniform sampler2D texture0;
uniform vec4 colDiffuse;

// Output fragment color
out vec4 finalColor;

// NOTE: Add here your custom variables

// NOTE: Render size values must be passed from code
const float renderWidth = 800.0;
const float renderHeight = 450.0;

float stitchingSize = 6.0;

uniform int invert = 0;

vec4 PostFX(sampler2D tex, vec2 uv)
{
    vec4 c = vec4(0.0);
    float size = stitchingSize;
    vec2 cPos = uv * vec2(renderWidth, renderHeight);
    vec2 tlPos = floor(cPos / vec2(size, size));
    tlPos *= size;

    int remX = int(mod(cPos.x, size));
    int remY = int(mod(cPos.y, size));

    if (remX == 0 && remY == 0) tlPos = cPos;

    vec2 blPos = tlPos;
    blPos.y += (size - 1.0);

    if ((remX == remY) || (((int(cPos.x) - int(blPos.x)) == (int(blPos.y) - int(cPos.y)))))
    {
        if (invert == 1) c = vec4(0.2, 0.15, 0.05, 1.0);
        else c = texture(tex, tlPos * vec2(1.0/renderWidth, 1.0/renderHeight)) * 1.4;
    }
    else
    {
        if (invert == 1) c = texture(tex, tlPos * vec2(1.0/renderWidth, 1.0/renderHeight)) * 1.4;
        else c = vec4(0.0, 0.0, 0.0, 1.0);
    }

    return c;
}

void main()
{
    vec3 tc = PostFX(texture0, fragTexCoord).rgb;

    finalColor = vec4(tc, 1.0);
}#version 330

// Input vertex attributes (from vertex shader)
in vec2 fragTexCoord;
in vec4 fragColor;

// Output fragment color
out vec4 finalColor;

// Custom variables
#define PI 3.14159265358979323846
uniform float uTime = 0.0;

float divisions = 5.0;
float angle = 0.0;

vec2 VectorRotateTime(vec2 v, float speed)
{
    float time = uTime*speed;
    float localTime = fract(time);  // The time domain this works on is 1 sec.

    if ((localTime >= 0.0) && (localTime < 0.25)) angle = 0.0;
    else if ((localTime >= 0.25) && (localTime < 0.50)) angle = PI/4*sin(2*PI*localTime - PI/2);
    else if ((localTime >= 0.50) && (localTime < 0.75)) angle = PI*0.25;
    else if ((localTime >= 0.75) && (localTime < 1.00)) angle = PI/4*sin(2*PI*localTime);

    // Rotate vector by angle
    v -= 0.5;
    v =  mat2(cos(angle), -sin(angle), sin(angle), cos(angle))*v;
    v += 0.5;

    return v;
}

float Rectangle(in vec2 st, in float size, in float fill)
{
  float roundSize = 0.5 - size/2.0;
  float left = step(roundSize, st.x);
  float top = step(roundSize, st.y);
  float bottom = step(roundSize, 1.0 - st.y);
  float right = step(roundSize, 1.0 - st.x);

  return (left*bottom*right*top)*fill;
}

void main()
{
    vec2 fragPos = fragTexCoord;
    fragPos.xy += uTime/9.0;

    fragPos *= divisions;
    vec2 ipos = floor(fragPos);  // Get the integer coords
    vec2 fpos = fract(fragPos);  // Get the fractional coords

    fpos = VectorRotateTime(fpos, 0.2);

    float alpha = Rectangle(fpos, 0.216, 1.0);
    vec3 color = vec3(0.3, 0.3, 0.3);

    finalColor = vec4(color, alpha);
}#version 330 core
out vec4 finalColor;

in vec2 texCoord;
in vec2 texCoord2;

uniform sampler2D gPosition;
uniform sampler2D gNormal;
uniform sampler2D gAlbedoSpec;

struct Light {
    int enabled;
    int type; // Unused in this demo.
    vec3 position;
    vec3 target; // Unused in this demo.
    vec4 color;
};

const int NR_LIGHTS = 4;
uniform Light lights[NR_LIGHTS];
uniform vec3 viewPosition;

const float QUADRATIC = 0.032;
const float LINEAR = 0.09;

void main() {
    vec3 fragPosition = texture(gPosition, texCoord).rgb;
    vec3 normal = texture(gNormal, texCoord).rgb;
    vec3 albedo = texture(gAlbedoSpec, texCoord).rgb;
    float specular = texture(gAlbedoSpec, texCoord).a;

    vec3 ambient = albedo * vec3(0.1f);
    vec3 viewDirection = normalize(viewPosition - fragPosition);

    for(int i = 0; i < NR_LIGHTS; ++i)
    {
        if(lights[i].enabled == 0) continue;
        vec3 lightDirection = lights[i].position - fragPosition;
        vec3 diffuse = max(dot(normal, lightDirection), 0.0) * albedo * lights[i].color.xyz;

        vec3 halfwayDirection = normalize(lightDirection + viewDirection);
        float spec = pow(max(dot(normal, halfwayDirection), 0.0), 32.0);
        vec3 specular = specular * spec * lights[i].color.xyz;

        // Attenuation
        float distance = length(lights[i].position - fragPosition);
        float attenuation = 1.0 / (1.0 + LINEAR * distance + QUADRATIC * distance * distance);
        diffuse *= attenuation;
        specular *= attenuation;
        ambient += diffuse + specular;
    }

    finalColor = vec4(ambient, 1.0);
}

#version 330 core

layout (location = 0) in vec3 vertexPosition;
layout (location = 1) in vec2 vertexTexCoord;

out vec2 texCoord;

void main() {
    gl_Position = vec4(vertexPosition, 1.0);
    texCoord = vertexTexCoord;
}
#version 330

// Input vertex attributes (from vertex shader)
in vec2 fragTexCoord;
in vec4 fragColor;

// Input uniform values
uniform sampler2D texture0;     // Depth texture
uniform vec4 colDiffuse;

// Output fragment color
out vec4 finalColor;

// NOTE: Add here your custom variables

void main()
{
    float zNear = 0.01; // camera z near
    float zFar = 10.0;  // camera z far
    float z = texture(texture0, fragTexCoord).x;

    // Linearize depth value
    float depth = (2.0*zNear)/(zFar + zNear - z*(zFar - zNear));

    // Calculate final fragment color
    finalColor = vec4(depth, depth, depth, 1.0f);
}#version 330

// Input vertex attributes (from vertex shader)
in vec2 fragTexCoord;

// Input uniform values
uniform sampler2D texture0;

// Output fragment color
out vec4 finalColor;

// NOTE: Default parameters for Oculus Rift DK2 device
const vec2 LeftLensCenter = vec2(0.2863248, 0.5);
const vec2 RightLensCenter = vec2(0.7136753, 0.5);
const vec2 LeftScreenCenter = vec2(0.25, 0.5);
const vec2 RightScreenCenter = vec2(0.75, 0.5);
const vec2 Scale = vec2(0.25, 0.45);
const vec2 ScaleIn = vec2(4.0, 2.5);
const vec4 HmdWarpParam = vec4(1.0, 0.22, 0.24, 0.0);
const vec4 ChromaAbParam = vec4(0.996, -0.004, 1.014, 0.0);

void main()
{
    // The following two variables need to be set per eye
    vec2 LensCenter = fragTexCoord.x < 0.5 ? LeftLensCenter : RightLensCenter;
    vec2 ScreenCenter = fragTexCoord.x < 0.5 ? LeftScreenCenter : RightScreenCenter;

    // Scales input texture coordinates for distortion: vec2 HmdWarp(vec2 fragTexCoord, vec2 LensCenter)
    vec2 theta = (fragTexCoord - LensCenter)*ScaleIn;   // Scales to [-1, 1]
    float rSq = theta.x*theta.x + theta.y*theta.y;
    vec2 theta1 = theta*(HmdWarpParam.x + HmdWarpParam.y*rSq + HmdWarpParam.z*rSq*rSq + HmdWarpParam.w*rSq*rSq*rSq);
    //vec2 tc = LensCenter + Scale*theta1;

    // Detect whether blue texture coordinates are out of range since these will scaled out the furthest
    vec2 thetaBlue = theta1*(ChromaAbParam.z + ChromaAbParam.w*rSq);
    vec2 tcBlue = LensCenter + Scale*thetaBlue;

    if (any(bvec2(clamp(tcBlue, ScreenCenter - vec2(0.25, 0.5), ScreenCenter + vec2(0.25, 0.5)) - tcBlue))) finalColor = vec4(0.0, 0.0, 0.0, 1.0);
    else
    {
        // Do blue texture lookup
        float blue = texture(texture0, tcBlue).b;

        // Do green lookup (no scaling)
        vec2 tcGreen = LensCenter + Scale*theta1;
        float green = texture(texture0, tcGreen).g;

        // Do red scale and lookup
        vec2 thetaRed = theta1*(ChromaAbParam.x + ChromaAbParam.y*rSq);
        vec2 tcRed = LensCenter + Scale*thetaRed;
        float red = texture(texture0, tcRed).r;

        finalColor = vec4(red, green, blue, 1.0);
    }
}

#version 330

in vec2 fragTexCoord;

out vec4 fragColor;

uniform sampler2D texture0;
uniform vec4 colDiffuse;

// NOTE: Add here your custom variables

void main()
{
    vec4 color = texture(texture0, fragTexCoord);

    color += texture(texture0, fragTexCoord + 0.001);
    color += texture(texture0, fragTexCoord + 0.003);
    color += texture(texture0, fragTexCoord + 0.005);
    color += texture(texture0, fragTexCoord + 0.007);
    color += texture(texture0, fragTexCoord + 0.009);
    color += texture(texture0, fragTexCoord + 0.011);

    color += texture(texture0, fragTexCoord - 0.001);
    color += texture(texture0, fragTexCoord - 0.003);
    color += texture(texture0, fragTexCoord - 0.005);
    color += texture(texture0, fragTexCoord - 0.007);
    color += texture(texture0, fragTexCoord - 0.009);
    color += texture(texture0, fragTexCoord - 0.011);

    color.rgb = vec3((color.r + color.g + color.b)/3.0);
    color = color/9.5;

    fragColor = color;
}            #version 330

/*************************************************************************************

  The Sieve of Eratosthenes -- a simple shader by ProfJski
  An early prime number sieve: https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes

  The screen is divided into a square grid of boxes, each representing an integer value.
  Each integer is tested to see if it is a prime number.  Primes are colored white.
  Non-primes are colored with a color that indicates the smallest factor which evenly divdes our integer.

  You can change the scale variable to make a larger or smaller grid.
  Total number of integers displayed = scale squared, so scale = 100 tests the first 10,000 integers.

  WARNING: If you make scale too large, your GPU may bog down!

***************************************************************************************/

// Input vertex attributes (from vertex shader)
in vec2 fragTexCoord;
in vec4 fragColor;

// Output fragment color
out vec4 finalColor;

// Make a nice spectrum of colors based on counter and maxSize
vec4 Colorizer(float counter, float maxSize)
{
    float red = 0.0, green = 0.0, blue = 0.0;
    float normsize = counter/maxSize;

    red = smoothstep(0.3, 0.7, normsize);
    green = sin(3.14159*normsize);
    blue = 1.0 - smoothstep(0.0, 0.4, normsize);

    return vec4(0.8*red, 0.8*green, 0.8*blue, 1.0);
}

void main()
{
    vec4 color = vec4(1.0);
    float scale = 1000.0; // Makes 100x100 square grid. Change this variable to make a smaller or larger grid.
    int value = int(scale*floor(fragTexCoord.y*scale)+floor(fragTexCoord.x*scale));  // Group pixels into boxes representing integer values

    if ((value == 0) || (value == 1) || (value == 2)) finalColor = vec4(1.0);
    else
    {
        for (int i = 2; (i < max(2, sqrt(value) + 1)); i++)
        {
            if ((value - i*floor(float(value)/float(i))) == 0)
            {
                color = Colorizer(float(i), scale);
                //break;    // Uncomment to color by the largest factor instead
            }
        }

        finalColor = color;
    }
}
#version 330

in vec2 fragTexCoord;

out vec4 fragColor;

uniform sampler2D texture0;
uniform vec4 colDiffuse;

// NOTE: Add here your custom variables

const float PI = 3.1415926535;

void main()
{
    float aperture = 178.0;
    float apertureHalf = 0.5 * aperture * (PI / 180.0);
    float maxFactor = sin(apertureHalf);

    vec2 uv = vec2(0);
    vec2 xy = 2.0 * fragTexCoord.xy - 1.0;
    float d = length(xy);

    if (d < (2.0 - maxFactor))
    {
        d = length(xy * maxFactor);
        float z = sqrt(1.0 - d * d);
        float r = atan(d, z) / PI;
        float phi = atan(xy.y, xy.x);

        uv.x = r * cos(phi) + 0.5;
        uv.y = r * sin(phi) + 0.5;
    }
    else
    {
        uv = fragTexCoord.xy;
    }

    fragColor = texture(texture0, uv);
}#version 330

// Input vertex attributes (from vertex shader)
in vec2 fragTexCoord;
in vec4 fragColor;
in vec3 fragPosition;
in vec3 fragNormal;

// Input uniform values
uniform sampler2D texture0;
uniform vec4 colDiffuse;

// Output fragment color
out vec4 finalColor;

// NOTE: Add here your custom variables

#define     MAX_LIGHTS              4
#define     LIGHT_DIRECTIONAL       0
#define     LIGHT_POINT             1

struct MaterialProperty {
    vec3 color;
    int useSampler;
    sampler2D sampler;
};

struct Light {
    int enabled;
    int type;
    vec3 position;
    vec3 target;
    vec4 color;
};

// Input lighting values
uniform Light lights[MAX_LIGHTS];
uniform vec4 ambient;
uniform vec3 viewPos;
uniform float fogDensity;

void main()
{
    // Texel color fetching from texture sampler
    vec4 texelColor = texture(texture0, fragTexCoord);
    vec3 lightDot = vec3(0.0);
    vec3 normal = normalize(fragNormal);
    vec3 viewD = normalize(viewPos - fragPosition);
    vec3 specular = vec3(0.0);

    // NOTE: Implement here your fragment shader code

    for (int i = 0; i < MAX_LIGHTS; i++)
    {
        if (lights[i].enabled == 1)
        {
            vec3 light = vec3(0.0);

            if (lights[i].type == LIGHT_DIRECTIONAL) light = -normalize(lights[i].target - lights[i].position);
            if (lights[i].type == LIGHT_POINT) light = normalize(lights[i].position - fragPosition);

            float NdotL = max(dot(normal, light), 0.0);
            lightDot += lights[i].color.rgb*NdotL;

            float specCo = 0.0;
            if (NdotL > 0.0) specCo = pow(max(0.0, dot(viewD, reflect(-(light), normal))), 16.0); // Shine: 16.0
            specular += specCo;
        }
    }

    finalColor = (texelColor*((colDiffuse + vec4(specular,1))*vec4(lightDot, 1.0)));
    finalColor += texelColor*(ambient/10.0);

    // Gamma correction
    finalColor = pow(finalColor, vec4(1.0/2.2));

    // Fog calculation
    float dist = length(viewPos - fragPosition);

    // these could be parameters...
    const vec4 fogColor = vec4(0.5, 0.5, 0.5, 1.0);
    //const float fogDensity = 0.16;

    // Exponential fog
    float fogFactor = 1.0/exp((dist*fogDensity)*(dist*fogDensity));

    // Linear fog (less nice)
    //const float fogStart = 2.0;
    //const float fogEnd = 10.0;
    //float fogFactor = (fogEnd - dist)/(fogEnd - fogStart);

    fogFactor = clamp(fogFactor, 0.0, 1.0);

    finalColor = mix(fogColor, finalColor, fogFactor);
}
#version 330 core
layout (location = 0) out vec3 gPosition;
layout (location = 1) out vec3 gNormal;
layout (location = 2) out vec4 gAlbedoSpec;

in vec3 fragPosition;
in vec2 fragTexCoord;
in vec3 fragNormal;

uniform sampler2D diffuseTexture;
uniform sampler2D specularTexture;

void main() {
    // store the fragment position vector in the first gbuffer texture
    gPosition = fragPosition;
    // also store the per-fragment normals into the gbuffer
    gNormal = normalize(fragNormal);
    // and the diffuse per-fragment color
    gAlbedoSpec.rgb = texture(diffuseTexture, fragTexCoord).rgb;
    // store specular intensity in gAlbedoSpec's alpha component
    gAlbedoSpec.a = texture(specularTexture, fragTexCoord).r;
}
#version 330 core
layout (location = 0) in vec3 vertexPosition;
layout (location = 1) in vec2 vertexTexCoord;
layout (location = 2) in vec3 vertexNormal;

out vec3 fragPosition;
out vec2 fragTexCoord;
out vec3 fragNormal;

uniform mat4 matModel;
uniform mat4 matView;
uniform mat4 matProjection;

void main()
{
    vec4 worldPos = matModel * vec4(vertexPosition, 1.0);
    fragPosition = worldPos.xyz; 
    fragTexCoord = vertexTexCoord;

    mat3 normalMatrix = transpose(inverse(mat3(matModel)));
    fragNormal = normalMatrix * vertexNormal;

    gl_Position = matProjection * matView * worldPos;
}
#version 330

// Input vertex attributes (from vertex shader)
in vec2 fragTexCoord;
in vec4 fragColor;

// Input uniform values
uniform sampler2D texture0;
uniform vec4 colDiffuse;

// Output fragment color
out vec4 finalColor;

// NOTE: Add here your custom variables

void main()
{
    // Texel color fetching from texture sampler
    vec4 texelColor = texture(texture0, fragTexCoord)*colDiffuse*fragColor;

    // Convert texel color to grayscale using NTSC conversion weights
    float gray = dot(texelColor.rgb, vec3(0.299, 0.587, 0.114));

    // Calculate final fragment color
    finalColor = vec4(gray, gray, gray, texelColor.a);
}#version 330

// Input vertex attributes (from vertex shader)
in vec2 fragTexCoord;
in vec4 fragColor;

// Input uniform values
uniform sampler2D texture0;
uniform vec4 colDiffuse;

// Output fragment color
//out vec4 finalColor;

// NOTE: Add here your custom variables

void main()
{
    vec4 texelColor = texture(texture0, fragTexCoord);
    
    gl_FragColor = texelColor*colDiffuse*fragColor;
	gl_FragDepth = gl_FragCoord.z;
}# version 330

// Input vertex attributes (from vertex shader)
in vec2 fragTexCoord;
in vec4 fragColor;

// Input uniform values
uniform sampler2D texture0;
uniform vec4 colDiffuse;

// Custom Input Uniform
uniform vec3 camPos;
uniform vec3 camDir;
uniform vec2 screenCenter;

#define ZERO 0

// https://learnopengl.com/Advanced-OpenGL/Depth-testing
float CalcDepth(in vec3 rd, in float Idist){
    float local_z = dot(normalize(camDir),rd)*Idist;
    return (1.0/(local_z) - 1.0/0.01)/(1.0/1000.0 -1.0/0.01);
}

// https://iquilezles.org/articles/distfunctions/
float sdHorseshoe( in vec3 p, in vec2 c, in float r, in float le, vec2 w )
{
    p.x = abs(p.x);
    float l = length(p.xy);
    p.xy = mat2(-c.x, c.y, 
              c.y, c.x)*p.xy;
    p.xy = vec2((p.y>0.0 || p.x>0.0)?p.x:l*sign(-c.x),
                (p.x>0.0)?p.y:l );
    p.xy = vec2(p.x,abs(p.y-r))-vec2(le,0.0);
    
    vec2 q = vec2(length(max(p.xy,0.0)) + min(0.0,max(p.x,p.y)),p.z);
    vec2 d = abs(q) - w;
    return min(max(d.x,d.y),0.0) + length(max(d,0.0));
}

// r = sphere's radius
// h = cutting's plane's position
// t = thickness
float sdSixWayCutHollowSphere( vec3 p, float r, float h, float t )
{
    // Six way symetry Transformation
    vec3 ap = abs(p);
    if(ap.x < max(ap.y, ap.z)){
        if(ap.y < ap.z) ap.xz = ap.zx;
        else ap.xy = ap.yx;
    }

    vec2 q = vec2( length(ap.yz), ap.x );
    
    float w = sqrt(r*r-h*h);
    
    return ((h*q.x<w*q.y) ? length(q-vec2(w,h)) : 
                            abs(length(q)-r) ) - t;
}

// https://iquilezles.org/articles/boxfunctions
vec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) 
{
    vec3 m = 1.0/rd;
    vec3 n = m*ro;
    vec3 k = abs(m)*rad;
    vec3 t1 = -n - k;
    vec3 t2 = -n + k;
	return vec2( max( max( t1.x, t1.y ), t1.z ),
	             min( min( t2.x, t2.y ), t2.z ) );
}

vec2 opU( vec2 d1, vec2 d2 )
{
	return (d1.x<d2.x) ? d1 : d2;
}

vec2 map( in vec3 pos ){
    vec2 res = vec2( sdHorseshoe(  pos-vec3(-1.0,0.08, 1.0), vec2(cos(1.3),sin(1.3)), 0.2, 0.3, vec2(0.03,0.5) ), 11.5 ) ;
    res = opU(res, vec2( sdSixWayCutHollowSphere(  pos-vec3(0.0, 1.0, 0.0), 4.0, 3.5, 0.5 ), 4.5 )) ;
    return res;
}

// https://www.shadertoy.com/view/Xds3zN
vec2 raycast( in vec3 ro, in vec3 rd ){
    vec2 res = vec2(-1.0,-1.0);

    float tmin = 1.0;
    float tmax = 20.0;

    // raytrace floor plane
    float tp1 = (-ro.y)/rd.y;
    if( tp1>0.0 )
    {
        tmax = min( tmax, tp1 );
        res = vec2( tp1, 1.0 );
    }

    float t = tmin;
    for( int i=0; i<70 ; i++ )
    {
        if(t>tmax) break;
        vec2 h = map( ro+rd*t );
        if( abs(h.x)<(0.0001*t) )
        { 
            res = vec2(t,h.y); 
            break;
        }
        t += h.x;
    }

    return res;
}


// https://iquilezles.org/articles/rmshadows
float calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )
{
    // bounding volume
    float tp = (0.8-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );

    float res = 1.0;
    float t = mint;
    for( int i=ZERO; i<24; i++ )
    {
		float h = map( ro + rd*t ).x;
        float s = clamp(8.0*h/t,0.0,1.0);
        res = min( res, s );
        t += clamp( h, 0.01, 0.2 );
        if( res<0.004 || t>tmax ) break;
    }
    res = clamp( res, 0.0, 1.0 );
    return res*res*(3.0-2.0*res);
}


// https://iquilezles.org/articles/normalsSDF
vec3 calcNormal( in vec3 pos )
{
    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;
    return normalize( e.xyy*map( pos + e.xyy ).x + 
					  e.yyx*map( pos + e.yyx ).x + 
					  e.yxy*map( pos + e.yxy ).x + 
					  e.xxx*map( pos + e.xxx ).x );
}

// https://iquilezles.org/articles/nvscene2008/rwwtt.pdf
float calcAO( in vec3 pos, in vec3 nor )
{
	float occ = 0.0;
    float sca = 1.0;
    for( int i=ZERO; i<5; i++ )
    {
        float h = 0.01 + 0.12*float(i)/4.0;
        float d = map( pos + h*nor ).x;
        occ += (h-d)*sca;
        sca *= 0.95;
        if( occ>0.35 ) break;
    }
    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);
}

// https://iquilezles.org/articles/checkerfiltering
float checkersGradBox( in vec2 p )
{
    // filter kernel
    vec2 w = fwidth(p) + 0.001;
    // analytical integral (box filter)
    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;
    // xor pattern
    return 0.5 - 0.5*i.x*i.y;                  
}

// https://www.shadertoy.com/view/tdS3DG
vec4 render( in vec3 ro, in vec3 rd)
{ 
    // background
    vec3 col = vec3(0.7, 0.7, 0.9) - max(rd.y,0.0)*0.3;
    
    // raycast scene
    vec2 res = raycast(ro,rd);
    float t = res.x;
	float m = res.y;
    if( m>-0.5 )
    {
        vec3 pos = ro + t*rd;
        vec3 nor = (m<1.5) ? vec3(0.0,1.0,0.0) : calcNormal( pos );
        vec3 ref = reflect( rd, nor );
        
        // material        
        col = 0.2 + 0.2*sin( m*2.0 + vec3(0.0,1.0,2.0) );
        float ks = 1.0;
        
        if( m<1.5 )
        {
            float f = checkersGradBox( 3.0*pos.xz);
            col = 0.15 + f*vec3(0.05);
            ks = 0.4;
        }

        // lighting
        float occ = calcAO( pos, nor );
        
		vec3 lin = vec3(0.0);

        // sun
        {
            vec3  lig = normalize( vec3(-0.5, 0.4, -0.6) );
            vec3  hal = normalize( lig-rd );
            float dif = clamp( dot( nor, lig ), 0.0, 1.0 );
          //if( dif>0.0001 )
        	      dif *= calcSoftshadow( pos, lig, 0.02, 2.5 );
			float spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0);
                  spe *= dif;
                  spe *= 0.04+0.96*pow(clamp(1.0-dot(hal,lig),0.0,1.0),5.0);
                //spe *= 0.04+0.96*pow(clamp(1.0-sqrt(0.5*(1.0-dot(rd,lig))),0.0,1.0),5.0);
            lin += col*2.20*dif*vec3(1.30,1.00,0.70);
            lin +=     5.00*spe*vec3(1.30,1.00,0.70)*ks;
        }
        // sky
        {
            float dif = sqrt(clamp( 0.5+0.5*nor.y, 0.0, 1.0 ));
                  dif *= occ;
            float spe = smoothstep( -0.2, 0.2, ref.y );
                  spe *= dif;
                  spe *= 0.04+0.96*pow(clamp(1.0+dot(nor,rd),0.0,1.0), 5.0 );
          //if( spe>0.001 )
                  spe *= calcSoftshadow( pos, ref, 0.02, 2.5 );
            lin += col*0.60*dif*vec3(0.40,0.60,1.15);
            lin +=     2.00*spe*vec3(0.40,0.60,1.30)*ks;
        }
        // back
        {
        	float dif = clamp( dot( nor, normalize(vec3(0.5,0.0,0.6))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);
                  dif *= occ;
        	lin += col*0.55*dif*vec3(0.25,0.25,0.25);
        }
        // sss
        {
            float dif = pow(clamp(1.0+dot(nor,rd),0.0,1.0),2.0);
                  dif *= occ;
        	lin += col*0.25*dif*vec3(1.00,1.00,1.00);
        }
        
		col = lin;

        col = mix( col, vec3(0.7,0.7,0.9), 1.0-exp( -0.0001*t*t*t ) );
    }

	return vec4(vec3( clamp(col,0.0,1.0) ),t);
}

vec3 CalcRayDir(vec2 nCoord){
    vec3 horizontal = normalize(cross(camDir,vec3(.0 , 1.0, .0)));
    vec3 vertical   = normalize(cross(horizontal,camDir));
    return normalize(camDir + horizontal*nCoord.x + vertical*nCoord.y);
}

mat3 setCamera()
{
	vec3 cw = normalize(camDir);
	vec3 cp = vec3(0.0, 1.0 ,0.0);
	vec3 cu = normalize( cross(cw,cp) );
	vec3 cv =          ( cross(cu,cw) );
    return mat3( cu, cv, cw );
}

void main()
{
    vec2 nCoord = (gl_FragCoord.xy - screenCenter.xy)/screenCenter.y;
    mat3 ca = setCamera();

    // focal length
    float fl = length(camDir);
    vec3 rd = ca * normalize( vec3(nCoord,fl) );
    vec3 color = vec3(nCoord/2.0 + 0.5, 0.0);
    float depth = gl_FragCoord.z;
    {
        vec4 res = render( camPos - vec3(0.0, 0.0, 0.0) , rd );
        color = res.xyz;
        depth = CalcDepth(rd,res.w);
    }
    gl_FragColor = vec4(color , 1.0);
	gl_FragDepth = depth;
}#version 330

// Input vertex attributes (from vertex shader)
in vec2 fragTexCoord;
in vec4 fragColor;

// Output fragment color
out vec4 finalColor;

uniform vec2 c;                 // c.x = real, c.y = imaginary component. Equation done is z^2 + c
uniform vec2 offset;            // Offset of the scale.
uniform float zoom;             // Zoom of the scale.

const int maxIterations = 255;     // Max iterations to do.
const float colorCycles = 2.0f;    // Number of times the color palette repeats. Can show higher detail for higher iteration numbers.

// Square a complex number
vec2 ComplexSquare(vec2 z)
{
    return vec2(
        z.x*z.x - z.y*z.y,
        z.x*z.y*2.0f
    );
}

// Convert Hue Saturation Value (HSV) color into RGB
vec3 Hsv2rgb(vec3 c)
{
    vec4 K = vec4(1.0f, 2.0f/3.0f, 1.0f/3.0f, 3.0f);
    vec3 p = abs(fract(c.xxx + K.xyz)*6.0f - K.www);
    return c.z*mix(K.xxx, clamp(p - K.xxx, 0.0f, 1.0f), c.y);
}

void main()
{
    /**********************************************************************************************
      Julia sets use a function z^2 + c, where c is a constant.
      This function is iterated until the nature of the point is determined.

      If the magnitude of the number becomes greater than 2, then from that point onward
      the number will get bigger and bigger, and will never get smaller (tends towards infinity).
      2^2 = 4, 4^2 = 8 and so on.
      So at 2 we stop iterating.

      If the number is below 2, we keep iterating.
      But when do we stop iterating if the number is always below 2 (it converges)?
      That is what maxIterations is for.
      Then we can divide the iterations by the maxIterations value to get a normalized value that we can
      then map to a color.

      We use dot product (z.x * z.x + z.y * z.y) to determine the magnitude (length) squared.
      And once the magnitude squared is > 4, then magnitude > 2 is also true (saves computational power).
    *************************************************************************************************/

    // The pixel coordinates are scaled so they are on the mandelbrot scale
    // NOTE: fragTexCoord already comes as normalized screen coordinates but offset must be normalized before scaling and zoom
    vec2 z = vec2((fragTexCoord.x - 0.5f)*2.5f, (fragTexCoord.y - 0.5f)*1.5f)/zoom;
    z.x += offset.x;
    z.y += offset.y;

    int iterations = 0;
    for (iterations = 0; iterations < maxIterations; iterations++)
    {
        z = ComplexSquare(z) + c;  // Iterate function

        if (dot(z, z) > 4.0f) break;
    }

    // Another few iterations decreases errors in the smoothing calculation.
    // See http://linas.org/art-gallery/escape/escape.html for more information.
    z = ComplexSquare(z) + c;
    z = ComplexSquare(z) + c;

    // This last part smooths the color (again see link above).
    float smoothVal = float(iterations) + 1.0f - (log(log(length(z)))/log(2.0f));

    // Normalize the value so it is between 0 and 1.
    float norm = smoothVal/float(maxIterations);

    // If in set, color black. 0.999 allows for some float accuracy error.
    if (norm > 0.999f) finalColor = vec4(0.0f, 0.0f, 0.0f, 1.0f);
    else finalColor = vec4(Hsv2rgb(vec3(norm*colorCycles, 1.0f, 1.0f)), 1.0f);
}
#version 330

// Input vertex attributes (from vertex shader)
in vec3 fragPosition;
in vec2 fragTexCoord;
in vec4 fragColor;
in vec3 fragNormal;

// Input uniform values
uniform sampler2D texture0;
uniform vec4 colDiffuse;

// Output fragment color
out vec4 finalColor;

// NOTE: Add here your custom variables

#define     MAX_LIGHTS              4
#define     LIGHT_DIRECTIONAL       0
#define     LIGHT_POINT             1

struct Light {
    int enabled;
    int type;
    vec3 position;
    vec3 target;
    vec4 color;
};

// Input lighting values
uniform Light lights[MAX_LIGHTS];
uniform vec4 ambient;
uniform vec3 viewPos;

void main()
{
    // Texel color fetching from texture sampler
    vec4 texelColor = texture(texture0, fragTexCoord);
    vec3 lightDot = vec3(0.0);
    vec3 normal = normalize(fragNormal);
    vec3 viewD = normalize(viewPos - fragPosition);
    vec3 specular = vec3(0.0);

    vec4 tint = colDiffuse * fragColor;

    // NOTE: Implement here your fragment shader code

    for (int i = 0; i < MAX_LIGHTS; i++)
    {
        if (lights[i].enabled == 1)
        {
            vec3 light = vec3(0.0);

            if (lights[i].type == LIGHT_DIRECTIONAL)
            {
                light = -normalize(lights[i].target - lights[i].position);
            }

            if (lights[i].type == LIGHT_POINT)
            {
                light = normalize(lights[i].position - fragPosition);
            }

            float NdotL = max(dot(normal, light), 0.0);
            lightDot += lights[i].color.rgb*NdotL;

            float specCo = 0.0;
            if (NdotL > 0.0) specCo = pow(max(0.0, dot(viewD, reflect(-(light), normal))), 16.0); // 16 refers to shine
            specular += specCo;
        }
    }

    finalColor = (texelColor*((tint + vec4(specular, 1.0))*vec4(lightDot, 1.0)));
    finalColor += texelColor*(ambient/10.0)*tint;

    // Gamma correction
    finalColor = pow(finalColor, vec4(1.0/2.2));
}
#version 330

// Input vertex attributes
in vec3 vertexPosition;
in vec2 vertexTexCoord;
in vec3 vertexNormal;
in vec4 vertexColor;

// Input uniform values
uniform mat4 mvp;
uniform mat4 matModel;
uniform mat4 matNormal;

// Output vertex attributes (to fragment shader)
out vec3 fragPosition;
out vec2 fragTexCoord;
out vec4 fragColor;
out vec3 fragNormal;

// NOTE: Add here your custom variables

void main()
{
    // Send vertex attributes to fragment shader
    fragPosition = vec3(matModel*vec4(vertexPosition, 1.0));
    fragTexCoord = vertexTexCoord;
    fragColor = vertexColor;
    fragNormal = normalize(vec3(matNormal*vec4(vertexNormal, 1.0)));

    // Calculate final vertex position
    gl_Position = mvp*vec4(vertexPosition, 1.0);
}
#version 330

// Input vertex attributes
in vec3 vertexPosition;
in vec2 vertexTexCoord;
in vec3 vertexNormal;
//in vec4 vertexColor;      // Not required

in mat4 instanceTransform;

// Input uniform values
uniform mat4 mvp;
uniform mat4 matNormal;

// Output vertex attributes (to fragment shader)
out vec3 fragPosition;
out vec2 fragTexCoord;
out vec4 fragColor;
out vec3 fragNormal;

// NOTE: Add here your custom variables

void main()
{
    // Send vertex attributes to fragment shader
    fragPosition = vec3(instanceTransform*vec4(vertexPosition, 1.0));
    fragTexCoord = vertexTexCoord;
    fragColor = vec4(1.0);
    fragNormal = normalize(vec3(matNormal*vec4(vertexNormal, 1.0)));

    // Calculate final vertex position, note that we multiply mvp by instanceTransform
    gl_Position = mvp*instanceTransform*vec4(vertexPosition, 1.0);
}
#version 330

// Input vertex attributes (from vertex shader)
in vec2 fragTexCoord;
in vec2 fragTexCoord2;
in vec3 fragPosition;
in vec4 fragColor;

// Input uniform values
uniform sampler2D texture0;
uniform sampler2D texture1;

// Output fragment color
out vec4 finalColor;

void main()
{
    // Texel color fetching from texture sampler
    vec4 texelColor = texture(texture0, fragTexCoord);
    vec4 texelColor2 = texture(texture1, fragTexCoord2);

    finalColor = texelColor * texelColor2;
}
#version 330

// Input vertex attributes
in vec3 vertexPosition;
in vec2 vertexTexCoord;
in vec2 vertexTexCoord2;
in vec4 vertexColor;

// Input uniform values
uniform mat4 mvp;
uniform mat4 matModel;

// Output vertex attributes (to fragment shader)
out vec3 fragPosition;
out vec2 fragTexCoord;
out vec2 fragTexCoord2;
out vec4 fragColor;

void main()
{
    // Send vertex attributes to fragment shader
    fragPosition = vec3(matModel*vec4(vertexPosition, 1.0));
    fragTexCoord = vertexTexCoord;
    fragTexCoord2 = vertexTexCoord2;
    fragColor = vertexColor;

    // Calculate final vertex position
    gl_Position = mvp*vec4(vertexPosition, 1.0);
}
#version 330

// Input vertex attributes (from vertex shader)
in vec2 fragTexCoord;
in vec4 fragColor;

// Input uniform values
uniform sampler2D texture0;
uniform sampler2D mask;
uniform int frame;

// Output fragment color
out vec4 finalColor;

void main()
{
    vec4 maskColour = texture(mask, fragTexCoord + vec2(sin(-frame/150.0)/10.0, cos(-frame/170.0)/10.0));
    if (maskColour.r < 0.25) discard;
    vec4 texelColor = texture(texture0, fragTexCoord + vec2(sin(frame/90.0)/8.0, cos(frame/60.0)/8.0));

    finalColor = texelColor*maskColour;
}
#version 330

// Input vertex attributes (from vertex shader)
in vec2 fragTexCoord;
in vec4 fragColor;

// Input uniform values
uniform sampler2D texture0;
uniform vec4 colDiffuse;

uniform vec2 textureSize;
uniform float outlineSize;
uniform vec4 outlineColor;

// Output fragment color
out vec4 finalColor;

void main()
{
    vec4 texel = texture(texture0, fragTexCoord);   // Get texel color
    vec2 texelScale = vec2(0.0);
    texelScale.x = outlineSize/textureSize.x;
    texelScale.y = outlineSize/textureSize.y;

    // We sample four corner texels, but only for the alpha channel (this is for the outline)
    vec4 corners = vec4(0.0);
    corners.x = texture(texture0, fragTexCoord + vec2(texelScale.x, texelScale.y)).a;
    corners.y = texture(texture0, fragTexCoord + vec2(texelScale.x, -texelScale.y)).a;
    corners.z = texture(texture0, fragTexCoord + vec2(-texelScale.x, texelScale.y)).a;
    corners.w = texture(texture0, fragTexCoord + vec2(-texelScale.x, -texelScale.y)).a;

    float outline = min(dot(corners, vec4(1.0)), 1.0);
    vec4 color = mix(vec4(0.0), outlineColor, outline);
    finalColor = mix(color, texel, texel.a);
}#version 330

// Input vertex attributes (from vertex shader)
in vec2 fragTexCoord;
in vec4 fragColor;

// Input uniform values
uniform sampler2D texture0;
uniform vec4 colDiffuse;

// Output fragment color
out vec4 finalColor;

// NOTE: Add here your custom variables

void main()
{
    // To show overdraw, we just render all the fragments
    // with a solid color and some transparency

    // NOTE: This is not a postpro render,
    // it will only render all screen texture in a plain color

    finalColor = vec4(1.0, 0.0, 0.0, 0.2);
}

#version 330

const int MAX_INDEXED_COLORS = 8;

// Input fragment attributes (from fragment shader)
in vec2 fragTexCoord;
in vec4 fragColor;

// Input uniform values
uniform sampler2D texture0;
uniform ivec3 palette[MAX_INDEXED_COLORS];
//uniform sampler2D palette; // Alternative to ivec3, palette provided as a 256x1 texture

// Output fragment color
out vec4 finalColor;

void main()
{
    // Texel color fetching from texture sampler
    // NOTE: The texel is actually the a GRAYSCALE index color
    vec4 texelColor = texture(texture0, fragTexCoord)*fragColor;

    // Convert the (normalized) texel color RED component (GB would work, too)
    // to the palette index by scaling up from [0..1] to [0..255]
    int index = int(texelColor.r*255.0);
    ivec3 color = palette[index];
    
    //finalColor = texture(palette, texelColor.xy); // Alternative to ivec3

    // Calculate final fragment color. Note that the palette color components
    // are defined in the range [0..255] and need to be normalized to [0..1]
    finalColor = vec4(color/255.0, texelColor.a);
}
#version 330

#define MAX_LIGHTS              4
#define LIGHT_DIRECTIONAL       0
#define LIGHT_POINT             1
#define PI 3.14159265358979323846

struct Light {
    int enabled;
    int type;
    vec3 position;
    vec3 target;
    vec4 color;
    float intensity;
};

// Input vertex attributes (from vertex shader)
in vec3 fragPosition;
in vec2 fragTexCoord;
in vec4 fragColor;
in vec3 fragNormal;
in vec4 shadowPos;
in mat3 TBN;

// Output fragment color
out vec4 finalColor;

// Input uniform values
uniform int numOfLights;
uniform sampler2D albedoMap;
uniform sampler2D mraMap;
uniform sampler2D normalMap;
uniform sampler2D emissiveMap; // r: Hight g:emissive

uniform vec2 tiling;
uniform vec2 offset;

uniform int useTexAlbedo;
uniform int useTexNormal;
uniform int useTexMRA;
uniform int useTexEmissive;

uniform vec4  albedoColor;
uniform vec4  emissiveColor;
uniform float normalValue;
uniform float metallicValue;
uniform float roughnessValue;
uniform float aoValue;
uniform float emissivePower;

// Input lighting values
uniform Light lights[MAX_LIGHTS];
uniform vec3 viewPos;

uniform vec3 ambientColor;
uniform float ambient;

// Reflectivity in range 0.0 to 1.0
// NOTE: Reflectivity is increased when surface view at larger angle
vec3 SchlickFresnel(float hDotV,vec3 refl)
{
    return refl + (1.0 - refl)*pow(1.0 - hDotV, 5.0);
}

float GgxDistribution(float nDotH,float roughness)
{
    float a = roughness * roughness * roughness * roughness;
    float d = nDotH * nDotH * (a - 1.0) + 1.0;
    d = PI * d * d;
    return a / max(d,0.0000001);
}

float GeomSmith(float nDotV,float nDotL,float roughness)
{
    float r = roughness + 1.0;
    float k = r*r / 8.0;
    float ik = 1.0 - k;
    float ggx1 = nDotV/(nDotV*ik + k);
    float ggx2 = nDotL/(nDotL*ik + k);
    return ggx1*ggx2;
}

vec3 ComputePBR()
{
    vec3 albedo = texture(albedoMap,vec2(fragTexCoord.x*tiling.x + offset.x, fragTexCoord.y*tiling.y + offset.y)).rgb;
    albedo = vec3(albedoColor.x*albedo.x, albedoColor.y*albedo.y, albedoColor.z*albedo.z);
    
    float metallic = clamp(metallicValue, 0.0, 1.0);
    float roughness = clamp(roughnessValue, 0.0, 1.0);
    float ao = clamp(aoValue, 0.0, 1.0);
    
    if (useTexMRA == 1)
    {
        vec4 mra = texture(mraMap, vec2(fragTexCoord.x*tiling.x + offset.x, fragTexCoord.y*tiling.y + offset.y))*useTexMRA;
        metallic = clamp(mra.r + metallicValue, 0.04, 1.0);
        roughness = clamp(mra.g + roughnessValue, 0.04, 1.0);
        ao = (mra.b + aoValue)*0.5;
    }

    vec3 N = normalize(fragNormal);
    if (useTexNormal == 1)
    {
        N = texture(normalMap, vec2(fragTexCoord.x*tiling.x + offset.y, fragTexCoord.y*tiling.y + offset.y)).rgb;
        N = normalize(N*2.0 - 1.0);
        N = normalize(N*TBN);
    }

    vec3 V = normalize(viewPos - fragPosition);

    vec3 emissive = vec3(0);
    emissive = (texture(emissiveMap, vec2(fragTexCoord.x*tiling.x+offset.x, fragTexCoord.y*tiling.y+offset.y)).rgb).g * emissiveColor.rgb*emissivePower * useTexEmissive;

    // return N;//vec3(metallic,metallic,metallic);
    // if dia-electric use base reflectivity of 0.04 otherwise ut is a metal use albedo as base reflectivity
    vec3 baseRefl = mix(vec3(0.04), albedo.rgb, metallic);
    vec3 lightAccum = vec3(0.0);  // Acumulate lighting lum

    for (int i = 0; i < numOfLights; i++)
    {
        vec3 L = normalize(lights[i].position - fragPosition);      // Compute light vector
        vec3 H = normalize(V + L);                                  // Compute halfway bisecting vector
        float dist = length(lights[i].position - fragPosition);     // Compute distance to light
        float attenuation = 1.0/(dist*dist*0.23);                   // Compute attenuation
        vec3 radiance = lights[i].color.rgb*lights[i].intensity*attenuation; // Compute input radiance, light energy comming in

        // Cook-Torrance BRDF distribution function
        float nDotV = max(dot(N,V), 0.0000001);
        float nDotL = max(dot(N,L), 0.0000001);
        float hDotV = max(dot(H,V), 0.0);
        float nDotH = max(dot(N,H), 0.0);
        float D = GgxDistribution(nDotH, roughness);    // Larger the more micro-facets aligned to H
        float G = GeomSmith(nDotV, nDotL, roughness);   // Smaller the more micro-facets shadow
        vec3 F = SchlickFresnel(hDotV, baseRefl);       // Fresnel proportion of specular reflectance

        vec3 spec = (D*G*F)/(4.0*nDotV*nDotL);
        
        // Difuse and spec light can't be above 1.0
        // kD = 1.0 - kS  diffuse component is equal 1.0 - spec comonent
        vec3 kD = vec3(1.0) - F;
        
        // Mult kD by the inverse of metallnes, only non-metals should have diffuse light
        kD *= 1.0 - metallic;
        lightAccum += ((kD*albedo.rgb/PI + spec)*radiance*nDotL)*lights[i].enabled; // Angle of light has impact on result
    }
    
    vec3 ambientFinal = (ambientColor + albedo)*ambient*0.5;
    
    return ambientFinal + lightAccum*ao + emissive;
}

void main()
{
    vec3 color = ComputePBR();

    // HDR tonemapping
    color = pow(color, color + vec3(1.0));
    
    // Gamma correction
    color = pow(color, vec3(1.0/2.2));

    finalColor = vec4(color, 1.0);
}#version 330

// Input vertex attributes
in vec3 vertexPosition;
in vec2 vertexTexCoord;
in vec3 vertexNormal;
in vec3 vertexTangent;
in vec4 vertexColor;

// Input uniform values
uniform mat4 mvp;
uniform mat4 matModel;
uniform mat4 matNormal;
uniform vec3 lightPos;
uniform vec4 difColor;

// Output vertex attributes (to fragment shader)
out vec3 fragPosition;
out vec2 fragTexCoord;
out vec4 fragColor;
out vec3 fragNormal;
out mat3 TBN;

const float normalOffset = 0.1;

void main()
{
    // Compute binormal from vertex normal and tangent
    vec3 vertexBinormal = cross(vertexNormal, vertexTangent);
    
    // Compute fragment normal based on normal transformations
    mat3 normalMatrix = transpose(inverse(mat3(matModel)));
    
    // Compute fragment position based on model transformations
    fragPosition = vec3(matModel*vec4(vertexPosition, 1.0f));

    fragTexCoord = vertexTexCoord*2.0;
    fragNormal = normalize(normalMatrix*vertexNormal);
    vec3 fragTangent = normalize(normalMatrix*vertexTangent);
    fragTangent = normalize(fragTangent - dot(fragTangent, fragNormal)*fragNormal);
    vec3 fragBinormal = normalize(normalMatrix*vertexBinormal);
    fragBinormal = cross(fragNormal, fragTangent);

    TBN = transpose(mat3(fragTangent, fragBinormal, fragNormal));

    // Calculate final vertex position
    gl_Position = mvp*vec4(vertexPosition, 1.0);
}#version 330

// Input vertex attributes (from vertex shader)
in vec2 fragTexCoord;
in vec4 fragColor;

// Input uniform values
uniform sampler2D texture0;
uniform vec4 colDiffuse;

// Output fragment color
out vec4 finalColor;

// NOTE: Add here your custom variables

// NOTE: Render size values must be passed from code
const float renderWidth = 800;
const float renderHeight = 450;

uniform float pixelWidth = 5.0;
uniform float pixelHeight = 5.0;

void main()
{
    float dx = pixelWidth*(1.0/renderWidth);
    float dy = pixelHeight*(1.0/renderHeight);

    vec2 coord = vec2(dx*floor(fragTexCoord.x/dx), dy*floor(fragTexCoord.y/dy));

    vec3 tc = texture(texture0, coord).rgb;

    finalColor = vec4(tc, 1.0);
}#version 330

// Input vertex attributes (from vertex shader)
in vec2 fragTexCoord;
in vec4 fragColor;

// Input uniform values
uniform sampler2D texture0;
uniform vec4 colDiffuse;

// Output fragment color
out vec4 finalColor;

// NOTE: Add here your custom variables

float gamma = 0.6;
float numColors = 8.0;

void main()
{
    // Texel color fetching from texture sampler
    vec3 texelColor = texture(texture0, fragTexCoord.xy).rgb;

    texelColor = pow(texelColor, vec3(gamma, gamma, gamma));
    texelColor = texelColor*numColors;
    texelColor = floor(texelColor);
    texelColor = texelColor/numColors;
    texelColor = pow(texelColor, vec3(1.0/gamma));

    finalColor = vec4(texelColor, 1.0);
}#version 330

// Input vertex attributes (from vertex shader)
in vec2 fragTexCoord;
in vec4 fragColor;

// Input uniform values
uniform sampler2D texture0;
uniform vec4 colDiffuse;

// Output fragment color
out vec4 finalColor;

// NOTE: Add here your custom variables

void main()
{
    // Texel color fetching from texture sampler
    vec3 texelColor = texture(texture0, fragTexCoord).rgb;
    vec3 colors[3];
    colors[0] = vec3(0.0, 0.0, 1.0);
    colors[1] = vec3(1.0, 1.0, 0.0);
    colors[2] = vec3(1.0, 0.0, 0.0);

    float lum = (texelColor.r + texelColor.g + texelColor.b)/3.0;

    int ix = (lum < 0.5)? 0:1;

    vec3 tc = mix(colors[ix], colors[ix + 1], (lum - float(ix)*0.5)/0.5);

    finalColor = vec4(tc, 1.0);
}#version 330

// Input vertex attributes (from vertex shader)
in vec2 fragTexCoord;
in vec4 fragColor;

// Output fragment color
out vec4 finalColor;

uniform vec3 viewEye;
uniform vec3 viewCenter;
uniform float runTime;
uniform vec2 resolution;

// The MIT License
// Copyright  2013 Inigo Quilez
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

// A list of useful distance function to simple primitives, and an example on how to
// do some interesting boolean operations, repetition and displacement.
//
// More info here: http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm

#define AA 1   // make this 1 is your machine is too slow

//------------------------------------------------------------------

float sdPlane( vec3 p )
{
    return p.y;
}

float sdSphere( vec3 p, float s )
{
    return length(p)-s;
}

float sdBox( vec3 p, vec3 b )
{
    vec3 d = abs(p) - b;
    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));
}

float sdEllipsoid( in vec3 p, in vec3 r )
{
    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);
}

float udRoundBox( vec3 p, vec3 b, float r )
{
    return length(max(abs(p)-b,0.0))-r;
}

float sdTorus( vec3 p, vec2 t )
{
    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;
}

float sdHexPrism( vec3 p, vec2 h )
{
    vec3 q = abs(p);
#if 0
    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);
#else
    float d1 = q.z-h.y;
    float d2 = max((q.x*0.866025+q.y*0.5),q.y)-h.x;
    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);
#endif
}

float sdCapsule( vec3 p, vec3 a, vec3 b, float r )
{
    vec3 pa = p-a, ba = b-a;
    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );
    return length( pa - ba*h ) - r;
}

float sdEquilateralTriangle(  in vec2 p )
{
    const float k = sqrt(3.0);
    p.x = abs(p.x) - 1.0;
    p.y = p.y + 1.0/k;
    if( p.x + k*p.y > 0.0 ) p = vec2( p.x - k*p.y, -k*p.x - p.y )/2.0;
    p.x += 2.0 - 2.0*clamp( (p.x+2.0)/2.0, 0.0, 1.0 );
    return -length(p)*sign(p.y);
}

float sdTriPrism( vec3 p, vec2 h )
{
    vec3 q = abs(p);
    float d1 = q.z-h.y;
#if 1
    // distance bound
    float d2 = max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5;
#else
    // correct distance
    h.x *= 0.866025;
    float d2 = sdEquilateralTriangle(p.xy/h.x)*h.x;
#endif
    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);
}

float sdCylinder( vec3 p, vec2 h )
{
  vec2 d = abs(vec2(length(p.xz),p.y)) - h;
  return min(max(d.x,d.y),0.0) + length(max(d,0.0));
}

float sdCone( in vec3 p, in vec3 c )
{
    vec2 q = vec2( length(p.xz), p.y );
    float d1 = -q.y-c.z;
    float d2 = max( dot(q,c.xy), q.y);
    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);
}

float sdConeSection( in vec3 p, in float h, in float r1, in float r2 )
{
    float d1 = -p.y - h;
    float q = p.y - h;
    float si = 0.5*(r1-r2)/h;
    float d2 = max( sqrt( dot(p.xz,p.xz)*(1.0-si*si)) + q*si - r2, q );
    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);
}

float sdPryamid4(vec3 p, vec3 h ) // h = { cos a, sin a, height }
{
    // Tetrahedron = Octahedron - Cube
    float box = sdBox( p - vec3(0,-2.0*h.z,0), vec3(2.0*h.z) );

    float d = 0.0;
    d = max( d, abs( dot(p, vec3( -h.x, h.y, 0 )) ));
    d = max( d, abs( dot(p, vec3(  h.x, h.y, 0 )) ));
    d = max( d, abs( dot(p, vec3(  0, h.y, h.x )) ));
    d = max( d, abs( dot(p, vec3(  0, h.y,-h.x )) ));
    float octa = d - h.z;
    return max(-box,octa); // Subtraction
 }

float length2( vec2 p )
{
    return sqrt( p.x*p.x + p.y*p.y );
}

float length6( vec2 p )
{
    p = p*p*p; p = p*p;
    return pow( p.x + p.y, 1.0/6.0 );
}

float length8( vec2 p )
{
    p = p*p; p = p*p; p = p*p;
    return pow( p.x + p.y, 1.0/8.0 );
}

float sdTorus82( vec3 p, vec2 t )
{
    vec2 q = vec2(length2(p.xz)-t.x,p.y);
    return length8(q)-t.y;
}

float sdTorus88( vec3 p, vec2 t )
{
    vec2 q = vec2(length8(p.xz)-t.x,p.y);
    return length8(q)-t.y;
}

float sdCylinder6( vec3 p, vec2 h )
{
    return max( length6(p.xz)-h.x, abs(p.y)-h.y );
}

//------------------------------------------------------------------

float opS( float d1, float d2 )
{
    return max(-d2,d1);
}

vec2 opU( vec2 d1, vec2 d2 )
{
    return (d1.x<d2.x) ? d1 : d2;
}

vec3 opRep( vec3 p, vec3 c )
{
    return mod(p,c)-0.5*c;
}

vec3 opTwist( vec3 p )
{
    float  c = cos(10.0*p.y+10.0);
    float  s = sin(10.0*p.y+10.0);
    mat2   m = mat2(c,-s,s,c);
    return vec3(m*p.xz,p.y);
}

//------------------------------------------------------------------

vec2 map( in vec3 pos )
{
    vec2 res = opU( vec2( sdPlane(     pos), 1.0 ),
                    vec2( sdSphere(    pos-vec3( 0.0,0.25, 0.0), 0.25 ), 46.9 ) );
    res = opU( res, vec2( sdBox(       pos-vec3( 1.0,0.25, 0.0), vec3(0.25) ), 3.0 ) );
    res = opU( res, vec2( udRoundBox(  pos-vec3( 1.0,0.25, 1.0), vec3(0.15), 0.1 ), 41.0 ) );
    res = opU( res, vec2( sdTorus(     pos-vec3( 0.0,0.25, 1.0), vec2(0.20,0.05) ), 25.0 ) );
    res = opU( res, vec2( sdCapsule(   pos,vec3(-1.3,0.10,-0.1), vec3(-0.8,0.50,0.2), 0.1  ), 31.9 ) );
    res = opU( res, vec2( sdTriPrism(  pos-vec3(-1.0,0.25,-1.0), vec2(0.25,0.05) ),43.5 ) );
    res = opU( res, vec2( sdCylinder(  pos-vec3( 1.0,0.30,-1.0), vec2(0.1,0.2) ), 8.0 ) );
    res = opU( res, vec2( sdCone(      pos-vec3( 0.0,0.50,-1.0), vec3(0.8,0.6,0.3) ), 55.0 ) );
    res = opU( res, vec2( sdTorus82(   pos-vec3( 0.0,0.25, 2.0), vec2(0.20,0.05) ),50.0 ) );
    res = opU( res, vec2( sdTorus88(   pos-vec3(-1.0,0.25, 2.0), vec2(0.20,0.05) ),43.0 ) );
    res = opU( res, vec2( sdCylinder6( pos-vec3( 1.0,0.30, 2.0), vec2(0.1,0.2) ), 12.0 ) );
    res = opU( res, vec2( sdHexPrism(  pos-vec3(-1.0,0.20, 1.0), vec2(0.25,0.05) ),17.0 ) );
    res = opU( res, vec2( sdPryamid4(  pos-vec3(-1.0,0.15,-2.0), vec3(0.8,0.6,0.25) ),37.0 ) );
    res = opU( res, vec2( opS( udRoundBox(  pos-vec3(-2.0,0.2, 1.0), vec3(0.15),0.05),
                               sdSphere(    pos-vec3(-2.0,0.2, 1.0), 0.25)), 13.0 ) );
    res = opU( res, vec2( opS( sdTorus82(  pos-vec3(-2.0,0.2, 0.0), vec2(0.20,0.1)),
                               sdCylinder(  opRep( vec3(atan(pos.x+2.0,pos.z)/6.2831, pos.y, 0.02+0.5*length(pos-vec3(-2.0,0.2, 0.0))), vec3(0.05,1.0,0.05)), vec2(0.02,0.6))), 51.0 ) );
    res = opU( res, vec2( 0.5*sdSphere(    pos-vec3(-2.0,0.25,-1.0), 0.2 ) + 0.03*sin(50.0*pos.x)*sin(50.0*pos.y)*sin(50.0*pos.z), 65.0 ) );
    res = opU( res, vec2( 0.5*sdTorus( opTwist(pos-vec3(-2.0,0.25, 2.0)),vec2(0.20,0.05)), 46.7 ) );
    res = opU( res, vec2( sdConeSection( pos-vec3( 0.0,0.35,-2.0), 0.15, 0.2, 0.1 ), 13.67 ) );
    res = opU( res, vec2( sdEllipsoid( pos-vec3( 1.0,0.35,-2.0), vec3(0.15, 0.2, 0.05) ), 43.17 ) );

    return res;
}

vec2 castRay( in vec3 ro, in vec3 rd )
{
    float tmin = 0.2;
    float tmax = 30.0;

#if 1
    // bounding volume
    float tp1 = (0.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );
    float tp2 = (1.6-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>1.6 ) tmin = max( tmin, tp2 );
                                                 else           tmax = min( tmax, tp2 ); }
#endif

    float t = tmin;
    float m = -1.0;
    for( int i=0; i<64; i++ )
    {
        float precis = 0.0005*t;
        vec2 res = map( ro+rd*t );
        if( res.x<precis || t>tmax ) break;
        t += res.x;
        m = res.y;
    }

    if( t>tmax ) m=-1.0;
    return vec2( t, m );
}


float calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )
{
    float res = 1.0;
    float t = mint;
    for( int i=0; i<16; i++ )
    {
        float h = map( ro + rd*t ).x;
        res = min( res, 8.0*h/t );
        t += clamp( h, 0.02, 0.10 );
        if( h<0.001 || t>tmax ) break;
    }
    return clamp( res, 0.0, 1.0 );
}

vec3 calcNormal( in vec3 pos )
{
    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;
    return normalize( e.xyy*map( pos + e.xyy ).x +
                      e.yyx*map( pos + e.yyx ).x +
                      e.yxy*map( pos + e.yxy ).x +
                      e.xxx*map( pos + e.xxx ).x );
    /*
    vec3 eps = vec3( 0.0005, 0.0, 0.0 );
    vec3 nor = vec3(
        map(pos+eps.xyy).x - map(pos-eps.xyy).x,
        map(pos+eps.yxy).x - map(pos-eps.yxy).x,
        map(pos+eps.yyx).x - map(pos-eps.yyx).x );
    return normalize(nor);
    */
}

float calcAO( in vec3 pos, in vec3 nor )
{
    float occ = 0.0;
    float sca = 1.0;
    for( int i=0; i<5; i++ )
    {
        float hr = 0.01 + 0.12*float(i)/4.0;
        vec3 aopos =  nor * hr + pos;
        float dd = map( aopos ).x;
        occ += -(dd-hr)*sca;
        sca *= 0.95;
    }
    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );
}

// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm
float checkersGradBox( in vec2 p )
{
    // filter kernel
    vec2 w = fwidth(p) + 0.001;
    // analytical integral (box filter)
    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;
    // xor pattern
    return 0.5 - 0.5*i.x*i.y;
}

vec3 render( in vec3 ro, in vec3 rd )
{
    vec3 col = vec3(0.7, 0.9, 1.0) +rd.y*0.8;
    vec2 res = castRay(ro,rd);
    float t = res.x;
    float m = res.y;
    if( m>-0.5 )
    {
        vec3 pos = ro + t*rd;
        vec3 nor = calcNormal( pos );
        vec3 ref = reflect( rd, nor );

        // material
        col = 0.45 + 0.35*sin( vec3(0.05,0.08,0.10)*(m-1.0) );
        if( m<1.5 )
        {

            float f = checkersGradBox( 5.0*pos.xz );
            col = 0.3 + f*vec3(0.1);
        }

        // lighting
        float occ = calcAO( pos, nor );
        vec3  lig = normalize( vec3(cos(-0.4 * runTime), sin(0.7 * runTime), -0.6) );
        vec3  hal = normalize( lig-rd );
        float amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );
        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );
        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);
        float dom = smoothstep( -0.1, 0.1, ref.y );
        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );

        dif *= calcSoftshadow( pos, lig, 0.02, 2.5 );
        dom *= calcSoftshadow( pos, ref, 0.02, 2.5 );

        float spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0)*
                    dif *
                    (0.04 + 0.96*pow( clamp(1.0+dot(hal,rd),0.0,1.0), 5.0 ));

        vec3 lin = vec3(0.0);
        lin += 1.30*dif*vec3(1.00,0.80,0.55);
        lin += 0.40*amb*vec3(0.40,0.60,1.00)*occ;
        lin += 0.50*dom*vec3(0.40,0.60,1.00)*occ;
        lin += 0.50*bac*vec3(0.25,0.25,0.25)*occ;
        lin += 0.25*fre*vec3(1.00,1.00,1.00)*occ;
        col = col*lin;
        col += 10.00*spe*vec3(1.00,0.90,0.70);

        col = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.0002*t*t*t ) );
    }

    return vec3( clamp(col,0.0,1.0) );
}

mat3 setCamera( in vec3 ro, in vec3 ta, float cr )
{
    vec3 cw = normalize(ta-ro);
    vec3 cp = vec3(sin(cr), cos(cr),0.0);
    vec3 cu = normalize( cross(cw,cp) );
    vec3 cv = normalize( cross(cu,cw) );
    return mat3( cu, cv, cw );
}

void main()
{
    vec3 tot = vec3(0.0);
#if AA>1
    for( int m=0; m<AA; m++ )
    for( int n=0; n<AA; n++ )
    {
        // pixel coordinates
        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;
        vec2 p = (-resolution.xy + 2.0*(gl_FragCoord.xy+o))/resolution.y;
#else
        vec2 p = (-resolution.xy + 2.0*gl_FragCoord.xy)/resolution.y;
#endif

        // RAY: Camera is provided from raylib
        //vec3 ro = vec3( -0.5+3.5*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, 0.5 + 4.0*sin(0.1*time + 6.0*mo.x) );

        vec3 ro = viewEye;
        vec3 ta = viewCenter;

        // camera-to-world transformation
        mat3 ca = setCamera( ro, ta, 0.0 );
        // ray direction
        vec3 rd = ca * normalize( vec3(p.xy,2.0) );

        // render
        vec3 col = render( ro, rd );

        // gamma
        col = pow( col, vec3(0.4545) );

        tot += col;
#if AA>1
    }
    tot /= float(AA*AA);
#endif

    finalColor = vec4( tot, 1.0 );
}
#version 330

// Input vertex attributes (from vertex shader)
in vec2 fragTexCoord;           // Texture coordinates (sampler2D)
in vec4 fragColor;              // Tint color

// Output fragment color
out vec4 finalColor;            // Output fragment color

// Uniform inputs
uniform vec2 resolution;        // Viewport resolution (in pixels)
uniform vec2 mouse;             // Mouse pixel xy coordinates
uniform float time;             // Total run time (in secods)

// Draw circle
vec4 DrawCircle(vec2 fragCoord, vec2 position, float radius, vec3 color)
{
    float d = length(position - fragCoord) - radius;
    float t = clamp(d, 0.0, 1.0);
    return vec4(color, 1.0 - t);
}

void main()
{
    vec2 fragCoord = gl_FragCoord.xy;
    vec2 position = vec2(mouse.x, resolution.y - mouse.y);
    float radius = 40.0;

    // Draw background layer
    vec4 colorA = vec4(0.2,0.2,0.8, 1.0);
    vec4 colorB = vec4(1.0,0.7,0.2, 1.0);
    vec4 layer1 = mix(colorA, colorB, abs(sin(time*0.1)));

    // Draw circle layer
    vec3 color = vec3(0.9, 0.16, 0.21);
    vec4 layer2 = DrawCircle(fragCoord, position, radius, color);

    // Blend the two layers
    finalColor = mix(layer1, layer2, layer2.a);
}
#version 330

// Input vertex attributes (from vertex shader)
in vec2 fragTexCoord;
in vec4 fragColor;

// Input uniform values
uniform sampler2D texture0;
uniform vec4 colDiffuse;

// Output fragment color
out vec4 finalColor;

// NOTE: Add here your custom variables

// NOTE: Render size values must be passed from code
const float renderWidth = 800;
const float renderHeight = 450;
float offset = 0.0;

uniform float time;

void main()
{
    float frequency = renderHeight/3.0;
/*
    // Scanlines method 1
    float tval = 0; //time
    vec2 uv = 0.5 + (fragTexCoord - 0.5)*(0.9 + 0.01*sin(0.5*tval));

    vec4 color = texture(texture0, fragTexCoord);

    color = clamp(color*0.5 + 0.5*color*color*1.2, 0.0, 1.0);
    color *= 0.5 + 0.5*16.0*uv.x*uv.y*(1.0 - uv.x)*(1.0 - uv.y);
    color *= vec4(0.8, 1.0, 0.7, 1);
    color *= 0.9 + 0.1*sin(10.0*tval + uv.y*1000.0);
    color *= 0.97 + 0.03*sin(110.0*tval);

    fragColor = color;
*/
    // Scanlines method 2
    float globalPos = (fragTexCoord.y + offset) * frequency;
    float wavePos = cos((fract(globalPos) - 0.5)*3.14);

    // Texel color fetching from texture sampler
    vec4 texelColor = texture(texture0, fragTexCoord);

    finalColor = mix(vec4(0.0, 0.3, 0.0, 0.0), texelColor, wavePos);
}#version 330

// This shader is based on the basic lighting shader
// This only supports one light, which is directional, and it (of course) supports shadows

// Input vertex attributes (from vertex shader)
in vec3 fragPosition;
in vec2 fragTexCoord;
//in vec4 fragColor;
in vec3 fragNormal;

// Input uniform values
uniform sampler2D texture0;
uniform vec4 colDiffuse;

// Output fragment color
out vec4 finalColor;

// Input lighting values
uniform vec3 lightDir;
uniform vec4 lightColor;
uniform vec4 ambient;
uniform vec3 viewPos;

// Input shadowmapping values
uniform mat4 lightVP; // Light source view-projection matrix
uniform sampler2D shadowMap;

uniform int shadowMapResolution;

void main()
{
    // Texel color fetching from texture sampler
    vec4 texelColor = texture(texture0, fragTexCoord);
    vec3 lightDot = vec3(0.0);
    vec3 normal = normalize(fragNormal);
    vec3 viewD = normalize(viewPos - fragPosition);
    vec3 specular = vec3(0.0);

    vec3 l = -lightDir;

    float NdotL = max(dot(normal, l), 0.0);
    lightDot += lightColor.rgb*NdotL;

    float specCo = 0.0;
    if (NdotL > 0.0) specCo = pow(max(0.0, dot(viewD, reflect(-(l), normal))), 16.0); // 16 refers to shine
    specular += specCo;

    finalColor = (texelColor*((colDiffuse + vec4(specular, 1.0))*vec4(lightDot, 1.0)));

    // Shadow calculations
    vec4 fragPosLightSpace = lightVP * vec4(fragPosition, 1);
    fragPosLightSpace.xyz /= fragPosLightSpace.w; // Perform the perspective division
    fragPosLightSpace.xyz = (fragPosLightSpace.xyz + 1.0f) / 2.0f; // Transform from [-1, 1] range to [0, 1] range
    vec2 sampleCoords = fragPosLightSpace.xy;
    float curDepth = fragPosLightSpace.z;
    // Slope-scale depth bias: depth biasing reduces "shadow acne" artifacts, where dark stripes appear all over the scene.
    // The solution is adding a small bias to the depth
    // In this case, the bias is proportional to the slope of the surface, relative to the light
    float bias = max(0.0002 * (1.0 - dot(normal, l)), 0.00002) + 0.00001;
    int shadowCounter = 0;
    const int numSamples = 9;
    // PCF (percentage-closer filtering) algorithm:
    // Instead of testing if just one point is closer to the current point,
    // we test the surrounding points as well.
    // This blurs shadow edges, hiding aliasing artifacts.
    vec2 texelSize = vec2(1.0f / float(shadowMapResolution));
    for (int x = -1; x <= 1; x++)
    {
        for (int y = -1; y <= 1; y++)
        {
            float sampleDepth = texture(shadowMap, sampleCoords + texelSize * vec2(x, y)).r;
            if (curDepth - bias > sampleDepth)
            {
                shadowCounter++;
            }
        }
    }
    finalColor = mix(finalColor, vec4(0, 0, 0, 1), float(shadowCounter) / float(numSamples));

    // Add ambient lighting whether in shadow or not
    finalColor += texelColor*(ambient/10.0)*colDiffuse;

    // Gamma correction
    finalColor = pow(finalColor, vec4(1.0/2.2));
}
#version 330

// Input vertex attributes
in vec3 vertexPosition;
in vec2 vertexTexCoord;
in vec3 vertexNormal;
in vec4 vertexColor;

// Input uniform values
uniform mat4 mvp;
uniform mat4 matModel;
uniform mat4 matNormal;

// Output vertex attributes (to fragment shader)
out vec3 fragPosition;
out vec2 fragTexCoord;
out vec4 fragColor;
out vec3 fragNormal;

// NOTE: Add here your custom variables

void main()
{
    // Send vertex attributes to fragment shader
    fragPosition = vec3(matModel*vec4(vertexPosition, 1.0));
    fragTexCoord = vertexTexCoord;
    fragColor = vertexColor;
    fragNormal = normalize(vec3(matNormal*vec4(vertexNormal, 1.0)));

    // Calculate final vertex position
    gl_Position = mvp*vec4(vertexPosition, 1.0);
}
#version 330

// Input vertex attributes (from vertex shader)
in vec2 fragTexCoord;
in vec4 fragColor;

// Input uniform values
uniform sampler2D texture0;
uniform vec4 colDiffuse;

// Output fragment color
out vec4 finalColor;

// NOTE: Add here your custom variables
uniform vec2 resolution = vec2(800, 450);

void main()
{
    float x = 1.0/resolution.x;
    float y = 1.0/resolution.y;

    vec4 horizEdge = vec4(0.0);
    horizEdge -= texture(texture0, vec2(fragTexCoord.x - x, fragTexCoord.y - y))*1.0;
    horizEdge -= texture(texture0, vec2(fragTexCoord.x - x, fragTexCoord.y    ))*2.0;
    horizEdge -= texture(texture0, vec2(fragTexCoord.x - x, fragTexCoord.y + y))*1.0;
    horizEdge += texture(texture0, vec2(fragTexCoord.x + x, fragTexCoord.y - y))*1.0;
    horizEdge += texture(texture0, vec2(fragTexCoord.x + x, fragTexCoord.y    ))*2.0;
    horizEdge += texture(texture0, vec2(fragTexCoord.x + x, fragTexCoord.y + y))*1.0;

    vec4 vertEdge = vec4(0.0);
    vertEdge -= texture(texture0, vec2(fragTexCoord.x - x, fragTexCoord.y - y))*1.0;
    vertEdge -= texture(texture0, vec2(fragTexCoord.x    , fragTexCoord.y - y))*2.0;
    vertEdge -= texture(texture0, vec2(fragTexCoord.x + x, fragTexCoord.y - y))*1.0;
    vertEdge += texture(texture0, vec2(fragTexCoord.x - x, fragTexCoord.y + y))*1.0;
    vertEdge += texture(texture0, vec2(fragTexCoord.x    , fragTexCoord.y + y))*2.0;
    vertEdge += texture(texture0, vec2(fragTexCoord.x + x, fragTexCoord.y + y))*1.0;

    vec3 edge = sqrt((horizEdge.rgb*horizEdge.rgb) + (vertEdge.rgb*vertEdge.rgb));

    finalColor = vec4(edge, texture(texture0, fragTexCoord).a);
}#version 330

// Input vertex attributes (from vertex shader)
in vec2 fragTexCoord;
in vec4 fragColor;

// Output fragment color
out vec4 finalColor;

// NOTE: Add here your custom variables

#define MAX_SPOTS   3

struct Spot {
    vec2 pos;        // window coords of spot
    float inner;    // inner fully transparent centre radius
    float radius;    // alpha fades out to this radius
};

uniform Spot spots[MAX_SPOTS];      // Spotlight positions array
uniform float screenWidth;          // Width of the screen

void main()
{
    float alpha = 1.0;

    // Get the position of the current fragment (screen coordinates!)
    vec2 pos = vec2(gl_FragCoord.x, gl_FragCoord.y);

    // Find out which spotlight is nearest
    float d = 65000;  // some high value
    int fi = -1;      // found index

    for (int i = 0; i < MAX_SPOTS; i++)
    {
        for (int j = 0; j < MAX_SPOTS; j++)
        {
            float dj = distance(pos, spots[j].pos) - spots[j].radius + spots[i].radius;

            if (d > dj)
            {
                d = dj;
                fi = i;
            }
        }
    }

    // d now equals distance to nearest spot...
    // allowing for the different radii of all spotlights
    if (fi != -1)
    {
        if (d > spots[fi].radius) alpha = 1.0;
        else
        {
            if (d < spots[fi].inner) alpha = 0.0;
            else alpha = (d - spots[fi].inner) / (spots[fi].radius - spots[fi].inner);
        }
    }

    // Right hand side of screen is dimly lit,
    // could make the threshold value user definable
    if ((pos.x > screenWidth/2.0) && (alpha > 0.9)) alpha = 0.9;

    finalColor = vec4(0, 0, 0, alpha);
}
#version 330

// Input vertex attributes (from vertex shader)
in vec2 fragTexCoord;
in vec4 fragColor;

// Input uniform values
uniform sampler2D texture0;
uniform vec4 colDiffuse;

// Output fragment color
out vec4 finalColor;

// NOTE: Add here your custom variables

// NOTE: Render size values should be passed from code
const float renderWidth = 800;
const float renderHeight = 450;

float radius = 250.0;
float angle = 0.8;

uniform vec2 center = vec2(200.0, 200.0);

void main()
{
    vec2 texSize = vec2(renderWidth, renderHeight);
    vec2 tc = fragTexCoord*texSize;
    tc -= center;

    float dist = length(tc);

    if (dist < radius)
    {
        float percent = (radius - dist)/radius;
        float theta = percent*percent*angle*8.0;
        float s = sin(theta);
        float c = cos(theta);

        tc = vec2(dot(tc, vec2(c, -s)), dot(tc, vec2(s, c)));
    }

    tc += center;
    vec4 color = texture(texture0, tc/texSize)*colDiffuse*fragColor;;

    finalColor = vec4(color.rgb, 1.0);;
}#version 330 core

uniform sampler2D diffuseMap;
uniform vec2 tiling;

in vec2 fragTexCoord;

out vec4 fragColor;

void main()
{
    vec2 texCoord = fragTexCoord * tiling;
    fragColor = texture(diffuseMap, texCoord);
}
#version 330

// Input fragment attributes (from fragment shader)
in vec2 fragTexCoord;
in float height;

// Output fragment color
out vec4 finalColor;

void main()
{
    vec4 darkblue = vec4(0.0, 0.13, 0.18, 1.0);
    vec4 lightblue = vec4(1.0, 1.0, 1.0, 1.0);
    // interplate between two colors based on height
    finalColor = mix(darkblue, lightblue, height);
}#version 330

// Input vertex attributes
in vec3 vertexPosition;
in vec2 vertexTexCoord;
in vec3 vertexNormal;
in vec4 vertexColor;

// Input uniform values
uniform mat4 mvp;
uniform mat4 matModel;
uniform mat4 matNormal;

uniform float time; 

uniform sampler2D perlinNoiseMap;

// Output vertex attributes (to fragment shader)
out vec3 fragPosition;
out vec2 fragTexCoord;
out vec3 fragNormal;
out float height;

void main()
{
    // Calculate animated texture coordinates based on time and vertex position
    vec2 animatedTexCoord = sin(vertexTexCoord + vec2(sin(time + vertexPosition.x * 0.1), cos(time + vertexPosition.z * 0.1)) * 0.3);

    // Normalize animated texture coordinates to range [0, 1]
    animatedTexCoord = animatedTexCoord * 0.5 + 0.5;

    // Fetch displacement from the perlin noise map
    float displacement = texture(perlinNoiseMap, animatedTexCoord).r * 7; // Amplified displacement

    // Displace vertex position
    vec3 displacedPosition = vertexPosition + vec3(0.0, displacement, 0.0);

    // Send vertex attributes to fragment shader
    fragPosition = vec3(matModel*vec4(displacedPosition, 1.0));
    fragTexCoord = vertexTexCoord;
    fragNormal = normalize(vec3(matNormal*vec4(vertexNormal, 1.0)));
    height = displacedPosition.y * 0.2; // send height to fragment shader for coloring

    // Calculate final vertex position
    gl_Position = mvp*vec4(displacedPosition , 1.0);
}
#version 330

// Input vertex attributes (from vertex shader)
in vec2 fragTexCoord;
in vec4 fragColor;

// Input uniform values
uniform sampler2D texture0;
uniform vec4 colDiffuse;

// Output fragment color
out vec4 finalColor;

uniform float seconds;

uniform vec2 size;

uniform float freqX;
uniform float freqY;
uniform float ampX;
uniform float ampY;
uniform float speedX;
uniform float speedY;

void main() {
    float pixelWidth = 1.0 / size.x;
    float pixelHeight = 1.0 / size.y;
    float aspect = pixelHeight / pixelWidth;
    float boxLeft = 0.0;
    float boxTop = 0.0;

    vec2 p = fragTexCoord;
    p.x += cos((fragTexCoord.y - boxTop) * freqX / ( pixelWidth * 750.0) + (seconds * speedX)) * ampX * pixelWidth;
    p.y += sin((fragTexCoord.x - boxLeft) * freqY * aspect / ( pixelHeight * 750.0) + (seconds * speedY)) * ampY * pixelHeight;

    finalColor = texture(texture0, p)*colDiffuse*fragColor;
}
#version 330

// Input vertex attributes (from vertex shader)
in vec2 fragTexCoord;
in vec4 fragColor;

// Input uniform values
uniform sampler2D texture0;
uniform vec4 colDiffuse;

// Output fragment color
out vec4 finalColor;

void main()
{
    vec4 texelColor = texture(texture0, fragTexCoord);
    
    finalColor = texelColor*colDiffuse*fragColor;
    gl_FragDepth = 1.0 - finalColor.z;
}
#version 100
precision mediump float;

#define MAX_CUBES 100
#define AA 1   // Anti-aliasing level

// Input vertex attributes
varying vec2 fragTexCoord;
varying vec4 fragColor;

// Uniforms
uniform vec3 viewEye;
uniform vec3 viewCenter;
uniform vec2 resolution;
uniform vec3 lightPos;
uniform int numCubes;
uniform vec3 cubePositions[MAX_CUBES];
uniform vec3 cubeSizes[MAX_CUBES];
uniform vec3 cubeColors[MAX_CUBES];

// Modified map function to handle cube indexing
struct MapResult {
    float dist;
    float material;
    float index;
};

float sdBox(vec3 p, vec3 b)
{
    vec3 d = abs(p) - b;
    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));
}

float sdPlane(vec3 p)
{
    return p.y;
}

MapResult map(in vec3 pos)
{
    MapResult res;
    res.dist = 1e10;  // Initialize to large distance
    res.material = 1.0;
    res.index = -1.0;
    
    // Check cubes first
    for(int i = 0; i < MAX_CUBES; i++) {
        if(i >= numCubes) break;
        float d = sdBox(pos - cubePositions[i], cubeSizes[i]);
        if(d < res.dist) {
            res.dist = d;
            res.material = 2.0;
            res.index = float(i);
        }
    }
    
    // Check plane last
    float planeDist = sdPlane(pos);
    if(planeDist < res.dist) {
        res.dist = planeDist;
        res.material = 1.0;
        res.index = -1.0;
    }
    
    return res;
}

vec3 calcNormal(in vec3 pos)
{
    vec2 e = vec2(0.001, 0.0);
    float a = map(pos + e.xyy).dist;
    float b = map(pos - e.xyy).dist;
    float c = map(pos + e.yxy).dist;
    float d = map(pos - e.yxy).dist;
    float e1 = map(pos + e.yyx).dist;
    float f = map(pos - e.yyx).dist;
    return normalize(vec3(a-b, c-d, e1-f));
}

// float calcAO(in vec3 pos, in vec3 nor)
// {
//     float occ = 0.0;
//     float sca = 1.0;
//     for(int i = 0; i < 5; i++) {
//         float hr = 0.01 + 0.12*float(i)/4.0;
//         vec3 aopos = nor * hr + pos;
//         float dd = map(aopos).dist;
//         occ += -(dd-hr)*sca;
//         sca *= 0.95;
//     }
//     return clamp(1.0 - 3.0*occ, 0.0, 1.0);
// }

// float calcSoftshadow(in vec3 ro, in vec3 rd, float mint, float tmax)
// {
//     float res = 1.0;
//     float t = mint;
    
//     for(int i = 0; i < 16; i++) {
//         float h = map(ro + rd*t).dist;
//         res = min(res, 8.0*h/t);
//         t += clamp(h, 0.02, 0.10);
//         if(h < 0.001 || t > tmax) break;
//     }
//     return clamp(res, 0.0, 1.0);
// }

vec3 getCubeColor(float index) {
    vec3 col = vec3(1.0);  // Default white
    for(int i = 0; i < MAX_CUBES; i++) {
        if(float(i) == index) {
            col = cubeColors[i];
            break;
        }
    }
    return col;
}

void main()
{
    vec2 p = (-resolution.xy + 2.0*gl_FragCoord.xy)/resolution.y;
    
    // camera
    vec3 ro = viewEye;
    vec3 ta = viewCenter;
    vec3 ww = normalize(ta - ro);
    vec3 uu = normalize(cross(ww,vec3(0.0,1.0,0.0)));
    vec3 vv = normalize(cross(uu,ww));
    vec3 rd = normalize(p.x*uu + p.y*vv + 2.0*ww);

    // render
    vec3 col = vec3(5.7, 10.9, 1.0) + rd.y*0.8;
    float t = 0.0;
    MapResult res;
    
    // raymarch
    for(int i = 0; i < 32; i++) {
        vec3 pos = ro + rd * t;
        res = map(pos);
        
        if(res.dist < 0.001 || t > 10.0) break;
        t += res.dist;
    }

    if(t < 20.0) {
        vec3 pos = ro + t*rd;
        vec3 nor = calcNormal(pos);
        vec3 lig = normalize(lightPos);
        
        // material
        vec3 matCol;
        if(res.material < 1.5) {
            matCol = vec3(0.3);  // ground color
        } else {
            matCol = getCubeColor(res.index);
        }

        // simplified lighting
        float dif = clamp(dot(nor, lig), 0.0, 1.0);
        float amb = 0.3;
        
        vec3 lin = vec3(0.0);
        lin += dif * vec3(1.0, 0.8, 0.6);
        lin += amb * vec3(1.0);
        
        col = matCol * lin;
        
        // fog
        col = mix(col, vec3(0.8, 0.9, 1.0), 1.0-exp(-0.0002*t*t*t));
    }

    // gamma
    col = pow(col, vec3(0.4545));
    
    gl_FragColor = vec4(col, 1.0);
}